<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker部署FastDFS</title>
      <link href="/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2%20FastDFS/"/>
      <url>/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2%20FastDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker部署FastDFS"><a href="#Docker部署FastDFS" class="headerlink" title="Docker部署FastDFS"></a>Docker部署FastDFS</h1><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><h3 id="一、Docker-镜像地址"><a href="#一、Docker-镜像地址" class="headerlink" title="一、Docker 镜像地址"></a>一、Docker 镜像地址</h3><p>百度网盘中</p><h3 id="二、镜像导入"><a href="#二、镜像导入" class="headerlink" title="二、镜像导入"></a>二、镜像导入</h3><p>docker load &lt; FastDFS.jar</p><h3 id="三、使用容器运行镜像"><a href="#三、使用容器运行镜像" class="headerlink" title="三、使用容器运行镜像"></a>三、使用容器运行镜像</h3><h5 id="开启tracker"><a href="#开启tracker" class="headerlink" title="开启tracker"></a>开启tracker</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name tracker --network&#x3D;host -v &#x2F;var&#x2F;fdfs&#x2F;tracker:&#x2F;var&#x2F;fdfs delron&#x2F;fastdfs tracker</span><br></pre></td></tr></table></figure><h5 id="开启storage"><a href="#开启storage" class="headerlink" title="开启storage"></a>开启storage</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --name storage --network&#x3D;host -e TRACKER_SERVER&#x3D;192.168.19.137:22122 -v &#x2F;var&#x2F;fdfs&#x2F;storage:&#x2F;var&#x2F;fdfs delron&#x2F;fastdfs storage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Elasticsearch</title>
      <link href="/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2Elasticsearch/"/>
      <url>/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker部署Elasticsearch"><a href="#Docker部署Elasticsearch" class="headerlink" title="Docker部署Elasticsearch"></a>Docker部署Elasticsearch</h1><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull delron&#x2F;elasticsearch-ik:2.4.6-1.0</span><br><span class="line">#或直接百度网盘下载</span><br><span class="line">docker load &lt; ***.jar</span><br></pre></td></tr></table></figure><h3 id="配置elasticsearch-yml的IP"><a href="#配置elasticsearch-yml的IP" class="headerlink" title="配置elasticsearch.yml的IP"></a>配置elasticsearch.yml的IP</h3><ul><li>把下载下来的文件拷贝到home目录下</li><li>并修改/home/python/elasticsearc-2.4.6/config/elasticsearch.yml第54行为真是IP</li></ul><h3 id="运行image"><a href="#运行image" class="headerlink" title="运行image"></a>运行image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --name&#x3D;elasticsearch --network&#x3D;host -v &#x2F;home&#x2F;python&#x2F;elasticsearch-2.4.6&#x2F;config:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config delron&#x2F;elasticsearch-ik:2.4.6-1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署MySQL</title>
      <link href="/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2MySQL/"/>
      <url>/blog/2019/08/12/Docker%E9%83%A8%E7%BD%B2MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker部署MySQL5-7"><a href="#Docker部署MySQL5-7" class="headerlink" title="Docker部署MySQL5.7"></a>Docker部署MySQL5.7</h1><ol><li><p>拉取镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br><span class="line">或</span><br><span class="line">百度网盘中/docker_images/mysql5.<span class="number">7</span>.jar</span><br><span class="line">docker load mysql5.<span class="number">7</span>.jar</span><br></pre></td></tr></table></figure></li><li><p>创建运行本地mysql所需的配置文件目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="literal">-p</span> /etc/mysql/conf</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>创建并运行虚拟环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker container run <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> -<span class="literal">-name</span> mysql_server <span class="literal">-v</span> /etc/mysql/conf/:/etc/mysql/conf.d <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123456</span> <span class="literal">-d</span> mysql:<span class="number">5.7</span></span><br><span class="line"><span class="comment"># 命令格式：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"><span class="comment"># 配置说明</span></span><br><span class="line"><span class="comment"># -p 3306:3306  把容器的3306端口(第二个3306)映射到主机的3306端口(第一个3306)</span></span><br><span class="line"><span class="comment"># --name 容器实例名称</span></span><br><span class="line"><span class="comment"># -v /etc/mysql/conf/:/etc/mysql/conf.d 把容器的mysql配置目录(/etc/mysql/conf.d)映射到到主机的对应目录(/etc/mysql/conf/)</span></span><br><span class="line"><span class="comment"># -e MYSQL_ROOT_PASSWORD=123456 设置密码为123456</span></span><br><span class="line"><span class="comment"># -d mysql:5.7 指定使用那个镜像</span></span><br></pre></td></tr></table></figure></li><li><p>进入mysql的shell界面</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> mysql_server mysql <span class="literal">-uroot</span> <span class="literal">-p123456</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Gitblit</title>
      <link href="/blog/2019/08/12/Dockre%E9%83%A8%E7%BD%B2Gitblit/"/>
      <url>/blog/2019/08/12/Dockre%E9%83%A8%E7%BD%B2Gitblit/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker部署Gitblit"><a href="#Docker部署Gitblit" class="headerlink" title="Docker部署Gitblit"></a>Docker部署Gitblit</h1><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><h3 id="一、Docker-镜像地址"><a href="#一、Docker-镜像地址" class="headerlink" title="一、Docker 镜像地址"></a>一、Docker 镜像地址</h3><p>百度网盘中/docker_images/gitblit.jar</p><h3 id="二、镜像导入"><a href="#二、镜像导入" class="headerlink" title="二、镜像导入"></a>二、镜像导入</h3><p>docker load &lt; gitblit.jar</p><h3 id="三、使用容器运行镜像"><a href="#三、使用容器运行镜像" class="headerlink" title="三、使用容器运行镜像"></a>三、使用容器运行镜像</h3><p>命令：docker run -dit -p 10101:10101 -p 8443:8443 -p 29418:29418 gitblit-wy<br>            注解：映射了几个常用端口，其中10101是http请求下gitblit网页访问端口，8443是https端口，29418是ssh端口。</p><h3 id="四、进入docker容器"><a href="#四、进入docker容器" class="headerlink" title="四、进入docker容器"></a>四、进入docker容器</h3><p>命令：docker exec -it 容器id /bin/bash<br>或<br>命令： docker attach 容器id<br>注解：exec和attach区别在于exec不随exit命令关闭容器，而attach随着exit命令在关闭终端时候关闭容器</p><h3 id="五、启动gitblit"><a href="#五、启动gitblit" class="headerlink" title="五、启动gitblit"></a>五、启动gitblit</h3><p>1、cd /opt/gitblit/gitblit-1.8.0/<br>2、java -jar gitblit.jar &amp;</p><h3 id="六、访问-docker宿主机的ip-10101"><a href="#六、访问-docker宿主机的ip-10101" class="headerlink" title="六、访问 docker宿主机的ip:10101"></a>六、访问 docker宿主机的ip:10101</h3><p>初始账号为：admin 密码为：admin</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Gitblit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTRL</title>
      <link href="/blog/2019/08/12/FTRL/"/>
      <url>/blog/2019/08/12/FTRL/</url>
      
        <content type="html"><![CDATA[<h1 id="FTRL（在线优化算法）"><a href="#FTRL（在线优化算法）" class="headerlink" title="FTRL（在线优化算法）"></a>FTRL（在线优化算法）</h1><p>由于在一些特定情景中(推荐系统)，线上得模型需要对于最新的少量数据来对模型进行在线训练，使其能对最新的数据做出快速反应，研究出来的一种算法。</p><h3 id="Follow-The-Regularized-Leader"><a href="#Follow-The-Regularized-Leader" class="headerlink" title="Follow The Regularized Leader"></a>Follow The Regularized Leader</h3><ul><li>一种获得稀疏模型并且防止过拟合的优化方法</li></ul><p><img src="/blog/img/FTRL_1.png"></p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化，即在成本函数中加入一个正则化惩罚项，惩罚模型的复杂度，防止网络模型过拟合</p><p>L1正则化可以使模型变得更稀疏；L2正则化可以使模型过拟合，使模型变得更简单</p><h5 id="FTRL在线优化算法就是把L1正则项和L2正则项加入模型中，使得模型稀疏且简单，使其能够对最新得数据，做出最及时的调整"><a href="#FTRL在线优化算法就是把L1正则项和L2正则项加入模型中，使得模型稀疏且简单，使其能够对最新得数据，做出最及时的调整" class="headerlink" title="FTRL在线优化算法就是把L1正则项和L2正则项加入模型中，使得模型稀疏且简单，使其能够对最新得数据，做出最及时的调整"></a>FTRL在线优化算法就是把L1正则项和L2正则项加入模型中，使得模型稀疏且简单，使其能够对最新得数据，做出最及时的调整</h5><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="TensorFlow使用"><a href="#TensorFlow使用" class="headerlink" title="TensorFlow使用"></a>TensorFlow使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module=tf.estimator.LinearClassifier(feature_columns=feature_cl,</span><br><span class="line">optimizer=tf.train.FtrlOptimizer(learning_rate=<span class="number">0.01</span>,l1_regularization_strength=<span class="number">10</span>,l2_regularization_strength=<span class="number">15</span>,))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FM</title>
      <link href="/blog/2019/08/12/FM/"/>
      <url>/blog/2019/08/12/FM/</url>
      
        <content type="html"><![CDATA[<h1 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h1><p><strong>FM称为因子分解机：有称为因子分解机</strong>，在对一批进行过特征交叉或大规模稀疏数据得特征向量M(NxN)进行训练时有于向量的维度过大，导致训练过程时间复杂和空间复杂度过大，难以进行大批量的训练，从而可以把M(NxN)分解成一个向量Q(NxK,K&lt;&lt;N),使M=Q*QT，从而把原本的特征个数从原来的N^N,变成N^K,也可以使得模型变得简单</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU镜像生成</title>
      <link href="/blog/2019/08/12/GPU%E9%95%9C%E5%83%8F%E7%94%9F%E6%88%90/"/>
      <url>/blog/2019/08/12/GPU%E9%95%9C%E5%83%8F%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> UBUNTU_VERSION=<span class="number">16.04</span></span><br><span class="line"><span class="keyword">ARG</span> ARCH=</span><br><span class="line"><span class="keyword">ARG</span> CUDA=<span class="number">10.1</span></span><br><span class="line"><span class="keyword">FROM</span> nvidia/cuda$&#123;ARCH:+-$ARCH&#125;:$&#123;CUDA&#125;-base-ubuntu$&#123;UBUNTU_VERSION&#125; as base</span><br><span class="line">     </span><br><span class="line"><span class="keyword">ARG</span> ARCH</span><br><span class="line"><span class="keyword">ARG</span> CUDA</span><br><span class="line"><span class="keyword">ARG</span> CUDNN=<span class="number">7.6</span>.<span class="number">4.38</span>-<span class="number">1</span></span><br><span class="line"><span class="keyword">ARG</span> CUDNN_MAJOR_VERSION=<span class="number">7</span></span><br><span class="line"><span class="keyword">ARG</span> LIB_DIR_PREFIX=x86_64</span><br><span class="line"><span class="keyword">ARG</span> LIBNVINFER=<span class="number">6.0</span>.<span class="number">1</span>-<span class="number">1</span></span><br><span class="line"><span class="keyword">ARG</span> LIBNVINFER_MAJOR_VERSION=<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i s:/archive.ubuntu.com:/mirrors.aliyun.com/ubuntu:g /etc/apt/sources.list;\</span></span><br><span class="line"><span class="bash">    sed -i s:/archive.ubuntu.com:/mirrors.tuna.tsinghua.edu.cn/ubuntu:g /etc/apt/sources.list &amp;&amp; apt-get clean &amp;&amp; apt-get -y update --fix-missing;\</span></span><br><span class="line"><span class="bash">    apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">        build-essential \</span></span><br><span class="line"><span class="bash">        cuda-command-line-tools-<span class="variable">$&#123;CUDA/./-&#125;</span> \</span></span><br><span class="line"><span class="bash">        libcublas10 \</span></span><br><span class="line"><span class="bash">        cuda-cufft-<span class="variable">$&#123;CUDA/./-&#125;</span> \</span></span><br><span class="line"><span class="bash">        cuda-curand-<span class="variable">$&#123;CUDA/./-&#125;</span> \</span></span><br><span class="line"><span class="bash">        cuda-cusolver-<span class="variable">$&#123;CUDA/./-&#125;</span> \</span></span><br><span class="line"><span class="bash">        cuda-cusparse-<span class="variable">$&#123;CUDA/./-&#125;</span> \</span></span><br><span class="line"><span class="bash">        curl \</span></span><br><span class="line"><span class="bash">        libcudnn7=<span class="variable">$&#123;CUDNN&#125;</span>+cuda<span class="variable">$&#123;CUDA&#125;</span> \</span></span><br><span class="line"><span class="bash">        libfreetype6-dev \</span></span><br><span class="line"><span class="bash">        libhdf5-serial-dev \</span></span><br><span class="line"><span class="bash">        libzmq3-dev \</span></span><br><span class="line"><span class="bash">        pkg-config \</span></span><br><span class="line"><span class="bash">        software-properties-common \</span></span><br><span class="line"><span class="bash">        unzip zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [[ <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> = <span class="string">&quot;ppc64le&quot;</span> ]] || &#123; apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="bash">        apt-get install -y --no-install-recommends libnvinfer<span class="variable">$&#123;LIBNVINFER_MAJOR_VERSION&#125;</span>=<span class="variable">$&#123;LIBNVINFER&#125;</span>+cuda<span class="variable">$&#123;CUDA&#125;</span> \</span></span><br><span class="line"><span class="bash">        libnvinfer-plugin<span class="variable">$&#123;LIBNVINFER_MAJOR_VERSION&#125;</span>=<span class="variable">$&#123;LIBNVINFER&#125;</span>+cuda<span class="variable">$&#123;CUDA&#125;</span> \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="bash">        &amp;&amp; rm -rf /var/lib/apt/lists/*; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LD_LIBRARY_PATH /usr/local/cuda/extras/CUPTI/lib64:/usr/local/cuda/lib64:/ln:/usr/cuda_files:$LD_LIBRARY_PATH</span><br><span class="line"><span class="keyword">ARG</span> USE_PYTHON_3_NOT_2</span><br><span class="line"><span class="keyword">ARG</span> _PY_SUFFIX=$&#123;USE_PYTHON_3_NOT_2:+<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">ARG</span> PIP=pip3</span><br><span class="line"><span class="keyword">ARG</span> TF_PACKAGE=tensorflow-gpu</span><br><span class="line"><span class="keyword">ARG</span> TF_PACKAGE_VERSION=<span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> huanjin.txt /root/huanjin.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hadoop /hadoop</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hive_client /hive_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/cuda/lib64/stubs/libcuda.so /usr/<span class="built_in">local</span>/cuda/lib64/stubs/libcuda.so.1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;/usr/local/cuda/lib64/stubs&quot;</span> &gt; /etc/ld.so.conf.d/z-cuda-stubs.conf \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ldconfig;\</span></span><br><span class="line"><span class="bash">    apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    python3.5 \</span></span><br><span class="line"><span class="bash">    python3-pip \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    libkrb5-dev \</span></span><br><span class="line"><span class="bash">    lrzsz \</span></span><br><span class="line"><span class="bash">    libsasl2-dev \</span></span><br><span class="line"><span class="bash">    libsasl2-2 \</span></span><br><span class="line"><span class="bash">    libsasl2-modules-gssapi-mit \</span></span><br><span class="line"><span class="bash">    openjdk-8-*</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="variable">$&#123;PIP&#125;</span> --no-cache-dir install --upgrade -i https://pypi.douban.com/simple \</span></span><br><span class="line"><span class="bash">    pip \</span></span><br><span class="line"><span class="bash">    setuptools;\</span></span><br><span class="line"><span class="bash">    ln -s $(<span class="built_in">which</span> <span class="variable">$&#123;PYTHON&#125;</span>) /usr/<span class="built_in">local</span>/bin/python;\</span></span><br><span class="line"><span class="bash">    <span class="variable">$&#123;PIP&#125;</span> install <span class="variable">$&#123;TF_PACKAGE&#125;</span><span class="variable">$&#123;TF_PACKAGE_VERSION:+==<span class="variable">$&#123;TF_PACKAGE_VERSION&#125;</span>&#125;</span> -i https://pypi.douban.com/simple;\</span></span><br><span class="line"><span class="bash">    <span class="variable">$&#123;PIP&#125;</span> install -r /root/huanjin.txt -i https://pypi.douban.com/simple;\</span></span><br><span class="line"><span class="bash">    mkdir /ln;ln -s /usr/<span class="built_in">local</span>/cuda-10.1/targets/x86_64-linux/lib/libcudart.so.10.1 /ln/libcudart.so.10.0;ln -s /usr/lib64/stubs/libcublas.so /ln/libcublas.so.10.0;ln -s /usr/<span class="built_in">local</span>/cuda-10.1/targets/x86_64-linux/lib/libcufft.so.10 /ln/libcufft.so.10.0;ln -s /usr/<span class="built_in">local</span>/cuda-10.1/targets/x86_64-linux/lib/libcurand.so.10 /ln/libcurand.so.10.0;ln -s /usr/<span class="built_in">local</span>/cuda-10.1/targets/x86_64-linux/lib/libcusolver.so.10 /ln/libcusolver.so.10.0;ln -s /usr/<span class="built_in">local</span>/cuda-10.1/targets/x86_64-linux/lib/libcusparse.so.10 /ln/libcusparse.so.10.0;ln -s /hadoop/lib/native/libhdfs.so /ln/libhdfs.so;ln -s /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server/libjvm.so /ln/libjvm.so</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /hadoop/bin/:$PATH</span><br><span class="line"><span class="keyword">ENV</span> HADOOP_HOME /hadoop</span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/lib/jvm/java-<span class="number">8</span>-openjdk-amd64</span><br><span class="line"><span class="keyword">ENV</span> HOME /root</span><br></pre></td></tr></table></figure><h2 id="huanjin-txt"><a href="#huanjin-txt" class="headerlink" title="huanjin.txt"></a>huanjin.txt</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############huanjin.txt############</span></span><br><span class="line">pip install -i https://pypi.douban.com/simple</span><br><span class="line">pandas==<span class="number">0.22</span>.<span class="number">0</span></span><br><span class="line">pyarrow==<span class="number">0.9</span>.<span class="number">0</span></span><br><span class="line">impyla==<span class="number">0.14</span>.<span class="number">1</span></span><br><span class="line">krbcontext==<span class="number">0.9</span></span><br><span class="line">pure_sasl==<span class="number">0.5</span>.<span class="number">1</span></span><br><span class="line">thrift_sasl==<span class="number">0.2</span>.<span class="number">1</span></span><br><span class="line">thrift==<span class="number">0.9</span>.<span class="number">3</span></span><br><span class="line">bitarray==<span class="number">0.8</span>.<span class="number">3</span></span><br><span class="line">thriftpy==<span class="number">0.3</span>.<span class="number">9</span></span><br><span class="line">Cython==<span class="number">0.29</span>.<span class="number">21</span></span><br><span class="line"></span><br><span class="line">torch==<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">torchvision==<span class="number">0.2</span>.<span class="number">2</span></span><br><span class="line">jieba==<span class="number">0.39</span></span><br><span class="line">scikit-learn==<span class="number">0.19</span>.<span class="number">1</span></span><br><span class="line">scikit-image==<span class="number">0.14</span>.<span class="number">1</span></span><br><span class="line">joblib==<span class="number">0.14</span>.<span class="number">1</span></span><br><span class="line">pytorch_pretrained_bert==<span class="number">0.6</span>.<span class="number">2</span></span><br><span class="line">gensim==<span class="number">3.5</span>.<span class="number">0</span></span><br><span class="line">Cython==<span class="number">0.29</span>.<span class="number">21</span></span><br></pre></td></tr></table></figure><h1 id="安装keytab文件认证"><a href="#安装keytab文件认证" class="headerlink" title="安装keytab文件认证"></a>安装keytab文件认证</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############安装#############</span></span><br><span class="line">docker build -t forecast:1.2 . </span><br><span class="line">apt-get install krb5-user -y</span><br><span class="line"></span><br><span class="line">CN.YUMCHINA.COM</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dockerfile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase</title>
      <link href="/blog/2019/08/12/HBase/"/>
      <url>/blog/2019/08/12/HBase/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase简介"><a href="#HBase简介" class="headerlink" title="HBase简介"></a>HBase简介</h1><h3 id="什么是HBase"><a href="#什么是HBase" class="headerlink" title="什么是HBase"></a>什么是HBase</h3><ul><li>HBase是一个分布式的、面向列的开源数据库</li><li>HBase是Google BigTable的开源实现</li><li>HBase不同于一般的关系型数据库，适合非结构化数据存储</li></ul><h3 id="BigTable"><a href="#BigTable" class="headerlink" title="BigTable"></a>BigTable</h3><ul><li>Big Table是Google设计的分布式数据存储系统，用来处理海量数据的一种非关系型数据库<ul><li>适合大规模海量数据，PB级数据</li><li>分布式、并发数据处理，效率极高</li><li>易于拓展，支持动态伸缩</li><li>适用于廉价设备</li><li>不适用于传统关系型数据存储</li></ul></li></ul><h3 id="面向列的数据库"><a href="#面向列的数据库" class="headerlink" title="面向列的数据库"></a>面向列的数据库</h3><p>HBase 与 传统关系数据库的区别</p><table><thead><tr><th></th><th>HBase</th><th>关系型数据库</th></tr></thead><tbody><tr><td>数据库大小</td><td>PB级别</td><td>GB TB</td></tr><tr><td>数据类型</td><td>Bytes</td><td>丰富的数据类型</td></tr><tr><td>事务支持</td><td>ACID只支持单个Row级别</td><td>全面的ACID支持, 对Row和表</td></tr><tr><td>索引</td><td>只支持Row-key</td><td>支持</td></tr><tr><td>吞吐量</td><td>百万写入/秒</td><td>数千写入/秒</td></tr></tbody></table><ul><li>关系型数据库中数据示例</li></ul><table><thead><tr><th>ID</th><th>FILE NAME</th><th>FILE PATH</th><th>FILE TYPE</th><th>FILE SIZE</th><th>CREATOR</th></tr></thead><tbody><tr><td>1</td><td>file1.txt</td><td>/home</td><td>txt</td><td>1024</td><td>tom</td></tr><tr><td>2</td><td>file2.txt</td><td>/home/pics</td><td>jpg</td><td>5032</td><td>jerry</td></tr></tbody></table><ul><li>同样数据保存到列式数据库中</li></ul><table><thead><tr><th>RowKey</th><th>FILE INFO</th><th>SAVE INFO</th></tr></thead><tbody><tr><td>1</td><td>name:file1.txt type:txt size:1024</td><td>path:/home/pics creator:Jerry</td></tr><tr><td>2</td><td>name:file2.jpg type:jpg size:5032</td><td>path:/home creator:Tom</td></tr></tbody></table><h3 id="非结构化数据存储"><a href="#非结构化数据存储" class="headerlink" title="非结构化数据存储"></a>非结构化数据存储</h3><ul><li>结构化数据<ul><li>适合二维表来展示数据</li></ul></li><li>非结构化数据<ul><li>非结构化数据是数据结构不规则或不完整</li><li>没有预定义的数据模型</li><li>不方便用数据库二维逻辑来表现</li><li>文本、图片、XML、HTML、各类报表、图像和音频视频信息等</li></ul></li></ul><h3 id="HBase在Hadoop生态中的地位"><a href="#HBase在Hadoop生态中的地位" class="headerlink" title="HBase在Hadoop生态中的地位"></a>HBase在Hadoop生态中的地位</h3><ul><li>HBase是Apache基金会顶级项目</li><li>HBase基于HDFS进行数据存储</li><li>HBase可以存储超大数据并适合用来进行大数据实时查询</li></ul><p><img src="/blog/img/HBase_1.png"></p><h3 id="HBase与HDFS"><a href="#HBase与HDFS" class="headerlink" title="HBase与HDFS"></a>HBase与HDFS</h3><ul><li>HBase建立在Hadoop文件系统上，利用了HDFS的容错能力</li><li>HBase提供对数据的随机实时读/写访问功能</li><li>HBase内部使用哈希表，并存储索引，可以快速查找HDFS中数据</li></ul><h3 id="HBase使用场景"><a href="#HBase使用场景" class="headerlink" title="HBase使用场景"></a>HBase使用场景</h3><ul><li>瞬间写入量很大</li><li>大量数据需要长期保存，且数量会持续增长</li><li>HBase不适合有join，多级索引，表关系复杂的数据模型</li></ul><h1 id="HBase的数据模型"><a href="#HBase的数据模型" class="headerlink" title="HBase的数据模型"></a>HBase的数据模型</h1><ul><li>NameSpace：对应关系型数据库的“数据库”（database）</li><li>表(table):用于存储管理数据，具有稀疏性、面向列的特点。Hbase中的每一张表，可以有上亿行，上百万列，对于为值为空的列，并不占用存储空间，因此表可以设计的非常稀疏。</li><li>行(Row):在表里面，每一行代表着一个数据对象，每一行都是以一个行键(Row Key)来进行唯一标识的，行键并没有什么特定的数据类型，以二进制的字节来存储</li><li>列(Column):HBase的列由Column family和Column qualifier组成，由冒号：进行行间隔，如family：qualifier</li><li>行键(RoeKey)：类似于MySQL中的主键，HBase根据行键来快速索引数据，一个行键对应一条记录。于MySQL主键不同的是，HBase的行键是天然固有的，每一行都有且仅有一个行键</li><li>列族(ColumnFamily):是列的集合。列族在表定义时需要指定，而列在插入数据时动态指定。列中的数据都是以二进制形式存在，没有数据类型。在物理存储结构上，每个表中的每个列族单独以一个文件存储。一个表可以有多个列族。</li><li>时间戳(TimeStamp):是列的一个属性，是一个64位整数。由行键和列确定的单元格，可以存储多个数据，每个数据含有时间戳属性，数据具有版本特性。可根据版本（VERSIONS）或时间戳来指定查询历史版本数据，如果都不指定，则默认返回最新版本数据。</li><li>区域(Region):HBase自动把表水平划分成多个区域，划分的区域随着数据的增大而增多。</li></ul><h1 id="HBase安装和shell操作"><a href="#HBase安装和shell操作" class="headerlink" title="HBase安装和shell操作"></a>HBase安装和shell操作</h1><h3 id="HBase的安装"><a href="#HBase的安装" class="headerlink" title="HBase的安装"></a>HBase的安装</h3><ul><li><p>下载安装包<a href="http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz">http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz</a></p></li><li><p>配置伪分布式环境</p><ul><li>环境变量配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HBASE_HOME=/root/bigdata/hbase</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><ul><li>配置hbase-evn.sh</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/root/bigdata/jdk</span><br><span class="line">export HBASE_MANAGES_ZK=false  --如果你是使用hbase自带的zk就是true，如果使用自己的zk就是false</span><br></pre></td></tr></table></figure><ul><li>配置hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop-master:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop-master:60000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop-master:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/bigdata/zookeeper-3.4.14/dataDir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动hbase（在hadoop集群已经启动的情况下）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hbase/bin/start-hbase.sh</span><br></pre></td></tr></table></figure><ul><li>输入hbase shell（进入shell命令行）</li></ul></li></ul><h3 id="HBase-shell"><a href="#HBase-shell" class="headerlink" title="HBase shell"></a>HBase shell</h3><ul><li>HBase DDL和DML命令</li></ul><table><thead><tr><th>名称</th><th>命令表达式</th></tr></thead><tbody><tr><td>创建表</td><td>create ‘表名’, ‘列族名1’,’列族名2’,’列族名n’</td></tr><tr><td>添加记录</td><td>put ‘表名’,’行名’,’列名:’,’值</td></tr><tr><td>查看记录</td><td>get ‘表名’,’行名’</td></tr><tr><td>查看表中的记录总数</td><td>count ‘表名’</td></tr><tr><td>删除记录</td><td>delete ‘表名’, ‘行名’,’列名’</td></tr><tr><td>删除一张表</td><td>第一步 disable ‘表名’ 第二步 drop ‘表名’</td></tr><tr><td>查看所有记录</td><td>scan “表名称”</td></tr><tr><td>查看指定表指定列所有数据</td><td>scan ‘表名’ ,{COLUMNS=&gt;’列族名:列名’}</td></tr><tr><td>更新记录</td><td>重写覆盖</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接集群</span></span><br><span class="line">hbase shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建表</span></span><br><span class="line">create &#x27;表名&#x27;, &#x27;列族名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除表</span></span><br><span class="line">disable &#x27;表名&#x27;</span><br><span class="line">drop &#x27;表名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建名称空间</span></span><br><span class="line">create_namespace &#x27;库名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示现有名称空间</span></span><br><span class="line">list_namespace</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建表的时候添加namespace</span></span><br><span class="line">create &#x27;库名:表名&#x27;, &#x27;列族名&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个命名空间下由哪些表</span></span><br><span class="line">list_namespace_tables &#x27;库名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入数据</span></span><br><span class="line">put &#x27;表名&#x27;, &#x27;RowKey&#x27;, &#x27;列族:列标识符&#x27;, &#x27;值&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询表中所有数据</span></span><br><span class="line">scan &#x27;表名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> scan 条件查询  通过COLUMNS  LIMIT STARTROW 等条件缩小查询范围</span></span><br><span class="line">scan &#x27;名称空间:表名&#x27;, &#123;COLUMNS =&gt; [&#x27;列族1&#x27;, &#x27;列族1&#x27;], LIMIT =&gt; 显示条数, STARTROW =&gt; &#x27;起始的rowkey&#x27;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> scan查询添加rowkey前置过滤器</span></span><br><span class="line">scan &#x27;表名&#x27;, &#123;ROWPREFIXFILTER =&gt; &quot;rowkey前缀&quot;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除表中数据</span></span><br><span class="line">delete &#x27;表名&#x27;, &#x27;rowkey&#x27;, &#x27;列族名：列修饰符&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空数据</span></span><br><span class="line">truncate &#x27;表名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作列簇</span></span><br><span class="line">alter &#x27;表名&#x27;, NAME =&gt; &#x27;列族名&#x27;</span><br><span class="line">alter &#x27;user&#x27;, &#x27;delete&#x27; =&gt; &#x27;列族名&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> HBase 追加型数据库 会保留多个版本数据 VERSIONS=&gt;<span class="string">&#x27;1&#x27;</span>说明最多可以显示一个版本 修改数据</span></span><br><span class="line">desc &#x27;user&#x27; Table user is ENABLED user COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;base_info&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_B</span><br><span class="line">HE_DATA_ON_WRITE =&gt; &#x27;false&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MI</span><br><span class="line">ER =&gt; &#x27;NONE&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOM</span><br><span class="line">se&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;false&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定显示多个版本</span></span><br><span class="line">get &#x27;表名&#x27;,&#x27;rowkey&#x27;,&#123;COLUMN=&gt;&#x27;列族名:列修饰符&#x27;,VERSIONS=&gt;2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改可以显示的版本数</span></span><br><span class="line">alter &#x27;表名&#x27;,NAME=&gt;&#x27;列族名&#x27;,VERSIONS=&gt;10</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定时间戳查询</span></span><br><span class="line">scan &#x27;表名&#x27;,&#123;COLUMNS =&gt; &#x27;列族名&#x27;, TIMERANGE =&gt; [时间戳, 时间戳]&#125;</span><br><span class="line">get &#x27;表名&#x27;, &#x27;rowkey&#x27;, &#123;COLUMN=&gt;&#x27;列族名:列修饰符&#x27;,VERSIONS=&gt;2,TIMERANGE =&gt; [时间戳, 时间戳]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过时间戳过滤器 指定具体时间戳的值</span></span><br><span class="line">scan &#x27;表名&#x27;,&#123;FILTER =&gt; &#x27;TimestampsFilter (时间戳, 时间戳)&#x27;&#125;</span><br><span class="line">get &#x27;表名&#x27;,&#x27;rowkey&#x27;,&#123;COLUMN=&gt;&#x27;列族名:列修饰符&#x27;,VERSIONS=&gt;2,FILTER =&gt; &#x27;TimestampsFilter (时间戳, 时间戳)&#x27;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取最近多个版本的数据</span></span><br><span class="line">get &#x27;表名&#x27;,&#x27;rowkey&#x27;,&#123;COLUMN=&gt;&#x27;列族名:列修饰符&#x27;,VERSIONS=&gt;10&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过指定时间戳获取不同版本的数据</span></span><br><span class="line">get &#x27;表名&#x27;,&#x27;rowkey&#x27;,&#123;COLUMN=&gt;&#x27;列族名:列修饰符&#x27;,TIMESTAMP=&gt;时间戳&#125;</span><br></pre></td></tr></table></figure><ul><li>命令表</li></ul><p><img src="/blog/img/HBase_2.jpg"></p><h1 id="使用HappyBase操作HBase"><a href="#使用HappyBase操作HBase" class="headerlink" title="使用HappyBase操作HBase"></a>使用HappyBase操作HBase</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">pip install happybase</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立连接</span></span><br><span class="line">import happybase</span><br><span class="line">conn = happybase.Connection(&#x27;IP&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取HBase中所有的表</span></span><br><span class="line">conn.tables()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建表</span></span><br><span class="line">conn.create_table(&#x27;表名&#x27;, &#123;&#x27;列族&#x27;: dict()&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建表之后可以传入表名获取Table实例</span></span><br><span class="line">table = conn.table(&#x27;表名&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全表查询</span></span><br><span class="line">table.scan()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询一行</span></span><br><span class="line">table.row(&#x27;rowkey&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询多行</span></span><br><span class="line">table.rows([&#x27;rowkey&#x27;,&#x27;rowkey&#x27;])</span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入数据</span></span><br><span class="line">table.put(&#x27;rowkey&#x27;, &#123;&#x27;列族名：列修饰符&#x27;：&#x27;值&#x27;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除数据</span></span><br><span class="line">table.delete(&#x27;rowkey&#x27;, [&#x27;列族名:列修饰符&#x27;])</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除表</span></span><br><span class="line">conn.delete_table(&#x27;表名&#x27;, True)</span><br></pre></td></tr></table></figure><h1 id="HBase组件"><a href="#HBase组件" class="headerlink" title="HBase组件"></a>HBase组件</h1><h3 id="HBase基础组件"><a href="#HBase基础组件" class="headerlink" title="HBase基础组件"></a>HBase基础组件</h3><p><img src="/blog/img/HBase_3.jpg"></p><ul><li><p><strong>Client</strong></p><ul><li>与zookeeper通信，找到数据入口地址</li><li>使用HBase RPC机制与HMaster和HRegionServer进行通信</li><li>Client与HMaster进行通信进行管理类操作</li><li>Client与HRegionServer进行数据读写类操作</li></ul></li><li><p><strong>Zookeeper</strong></p><ul><li>保证任何时候，集群中只有一个running master，避免单点问题</li><li>存储所有Region的寻址入口，包括ROOT表地址、HMaster地址</li><li>实时监控Region Server的状态，将Region Server的上线和下线信息，实时通知给Master</li><li>存储HBase的schema，包括有哪些table，每个table有哪些column family。</li></ul></li><li><p><strong>HMaster</strong></p><ul><li>可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行</li><li>角色功能：<ul><li>为Region server分配region</li><li>负责region server的负载均衡</li><li>发现失效的region serve并重新分配上其他的region</li><li>HDFS上的垃圾文件回收</li><li>处理用户对表的增删改查操作</li></ul></li></ul></li><li><p><strong>HRegionServer</strong></p><ul><li>HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据</li><li>作用：<ul><li>维护Master分配给它的region，处理对这些region的IO请求</li><li>负责切分在运行过程中变得过大得region</li><li>此外，HRegionServer管理一系列HRegion对象，每个HRegion对应Table中一个Region，HRegion由多个HStore组成，每个HStore对应Table中一个Column Family的存储，Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效。</li></ul></li></ul></li><li><p><strong>HStore</strong></p><ul><li>HBase存储核心，由MemStore和StoreFile组成</li></ul><p><img src="/blog/img/HBase_4.png"></p><ul><li>用户写入数据流程为：Client访问ZK，ZK返回RefionServer地址–&gt;Client访问RegionServer写入数据–&gt;数据存入MemStore，一直到MemStore满–&gt;存入StoreFile</li></ul></li><li><p><strong>HRegion</strong></p><ul><li>一个表最开始存储得时候，是一个region。</li><li>一个Region中会有多个store，每个store用来存储一个列族。如果只有一个column family，就只有一个store。</li><li>region会随着插入数据越来越多，会进行拆分。默认大小10G一个</li></ul></li><li><p><strong>HLog</strong></p><ul><li>在分布式系统中，无法避免系统出错或者宕机，一旦HRegionServer意外退出，MemStore中的内存数据就会丢失，引入HLog就是防止这种情况。</li></ul></li></ul><h3 id="HBase模块协作"><a href="#HBase模块协作" class="headerlink" title="HBase模块协作"></a>HBase模块协作</h3><ul><li><strong>HBase</strong>启动<ul><li>HMaster启动，注册到Zookeeper，等待RegionServer汇报</li><li>RegionServer注册到Zookeeper，并向HMaster汇报</li><li>对各个RegionServer（包括失效的）的数据进行整理，分配Region和meta信息</li></ul></li><li><strong>RegionServer</strong>失效<ul><li>HMaster将失效RegionServer上的Region分配到其他节点</li><li>HMaster更新hbase：meta表以保证数据正常访问</li></ul></li><li><strong>HMaster</strong>失效<ul><li>处于Backup状态的其他HMaster节点推选出一个转为Active状态</li><li>数据能正常读写，但是不能创建删除表，也不能更改表结构</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS</title>
      <link href="/blog/2019/08/12/HDFS/"/>
      <url>/blog/2019/08/12/HDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS安装"><a href="#HDFS安装" class="headerlink" title="HDFS安装"></a>HDFS安装</h1><ul><li>下载jdk和hadoop放到<del>/software目录下，然后解压到</del>/app目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 压缩包名字 -C ~/app/</span><br></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加内容</span></span><br><span class="line">export JAVA_HOME=/root/bigdata/jdk</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export HADOOP_HOME=/root/bigdata/hadoop</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash">保存后</span></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><ul><li><p>进入解压后的Hadoop目录，修改配置文件</p><ul><li>配置文件的作用<ul><li>core-site.xml:指定HDFS的访问方式</li><li>hdfs-site.xml:指定namenode和datanode的数据存储位置</li><li>mapred-site.xml:配置MapReduce</li><li>yarn-site.xml:配置yarn</li></ul></li><li>修改hadoop-env.sh</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ect/hadoop</span><br><span class="line">vim hadoop-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">添加内容</span></span><br><span class="line">export_JAVA_HOME=/root/bigdata/jdk</span><br></pre></td></tr></table></figure><ul><li>修改core-site.xml 在节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/root/bigdata/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop-master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改hdfs-site.xml 在 configuration节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/bigdata/hadoop/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/bigdata/hadoop/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改 mapred-site.xml</li><li>默认没有这个 从模板文件复制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><ul><li> 在mapred-site.xml 的configuration 节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改yarn-site.xml configuration 节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>来到hadoop的bin目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hadoop namenode -format (这个命令只运行一次)</span><br></pre></td></tr></table></figure><ul><li>启动hdfs 进入到 sbin</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-dfs.sh</span><br></pre></td></tr></table></figure><ul><li>启动启动yarn 在sbin中</li></ul></li></ul><h1 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h1><ul><li>1个NameNode(Master)带DataNode(Slaves)结构</li><li>1个文件会被拆分成多个Block</li><li><strong>NameNode(NN)</strong><ul><li>负责客户端请求的响应</li><li>负责元数据(文件名称、副本系数、Block存放的DN)的管理<ul><li>元数据是文件的描述数据</li></ul></li><li>监控DataNode健康状况，10分钟没有收到DataNode报告认为DataNode死掉了</li></ul></li><li><strong>DataNode(ND)</strong><ul><li>存储用户的文件对应的数据块(Block)</li><li>定期向NN发送心跳信息，汇报本身及其所有的block信息，健康状况</li></ul></li><li>分布式集群NameNode和DataNode部署在不同机器上</li><li><img src="/blog/img/HDFS_1.jpg" alt="img"></li><li>HDFS优缺点<ul><li>优点<ul><li>数据冗余、硬件容错</li><li>适合存储大文件</li><li>处理流式数据</li><li>可构建在廉价机器上</li></ul></li><li>缺点<ul><li>数据访问延时高</li><li>不适合小文件存储</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/blog/2019/08/12/Hadoop/"/>
      <url>/blog/2019/08/12/Hadoop/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h1><h2 id="Hadoop概念："><a href="#Hadoop概念：" class="headerlink" title="Hadoop概念："></a>Hadoop概念：</h2><p>Hadoop是一个<strong>开源的</strong>，<strong>可靠的</strong>，<strong>可扩展</strong>的<strong>分布式计算框架</strong>。</p><ul><li>允许使用简单的编程模型跨计算机集群分布式处理大型数据集</li><li><strong>可扩展</strong>：从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储</li><li><strong>可靠的</strong>：不依赖硬件来提供高可用，而是在应用层检测和处理故障，从而在计算机集群之上提供高可用服务</li></ul><h2 id="Hadoop能做什么？"><a href="#Hadoop能做什么？" class="headerlink" title="Hadoop能做什么？"></a>Hadoop能做什么？</h2><ul><li>搭建大型数据仓库</li><li>PB级数据的存储、处理、分析、统计等业务</li></ul><h2 id="Hadoop优势"><a href="#Hadoop优势" class="headerlink" title="Hadoop优势"></a>Hadoop优势</h2><ul><li>高可靠<ul><li>数据存储：数据块多副本</li><li>数据计算：某个节点崩溃，会自动重新调度作业计算</li></ul></li><li>高扩展性<ul><li>存储/计算资源不够时，可以横向的线性扩展机器</li><li>一个集群中可以包含数以千计的节点</li><li>集群可以使用廉价机器，成本低</li></ul></li><li>Hadoop生态系统成熟</li></ul><h1 id="2-Hadoop核心组件"><a href="#2-Hadoop核心组件" class="headerlink" title="2.Hadoop核心组件"></a>2.Hadoop核心组件</h1><h3 id="Hadoop-Common：hadoop核心组件"><a href="#Hadoop-Common：hadoop核心组件" class="headerlink" title="Hadoop Common：hadoop核心组件"></a>Hadoop Common：hadoop核心组件</h3><h3 id="HDFS：分布式文件系统"><a href="#HDFS：分布式文件系统" class="headerlink" title="HDFS：分布式文件系统"></a>HDFS：分布式文件系统</h3><ul><li>源自于Google的GFS论文，论文发表于2003年10月</li><li>HDFS是GFS的开源实现</li><li>HDFS的特点：扩展性&amp;容错性&amp;海量数量存储</li><li>将文件切分成指定大小的数据块，并在多台机器上保存多个副本</li><li>数据切分，多副本、容错等操作对用户是透明的</li></ul><h3 id="Hadoop-MapReduce：分布式计算框架"><a href="#Hadoop-MapReduce：分布式计算框架" class="headerlink" title="Hadoop MapReduce：分布式计算框架"></a>Hadoop MapReduce：分布式计算框架</h3><ul><li>源于Google的MapReduce论文，发表于2004年12月</li><li>MapReduce是GoogleMapReduce的开源实现</li><li>MapReduce特点：扩展性&amp;容错性&amp;海量数据离线处理</li></ul><h3 id="Hadoop-YARN：资源调度系统"><a href="#Hadoop-YARN：资源调度系统" class="headerlink" title="Hadoop YARN：资源调度系统"></a>Hadoop YARN：资源调度系统</h3><ul><li>负责整个集群资源的管理和调度</li><li>YARN特点：扩展性&amp;容错性&amp;多框架资源统一调度</li></ul><h1 id="3-Hadoop生态系统"><a href="#3-Hadoop生态系统" class="headerlink" title="3.Hadoop生态系统"></a>3.Hadoop生态系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hadoop生态系统是一个很庞大的概念，Hadoop是其中最重要最基础的一个部分，生态系统中每一个子系统只解决某一个特点的问题域，不搞统一型的全能系统，而是小而精的多个小系统；</p><p><img src="/blog/img/Hadoop_1.png"></p><p>Hive:数据仓库</p><p>R：数据分析</p><p>Mahout：机器学习库</p><p>pig：脚本语言，跟Hive类似</p><p>Oozie：工作流引擎，管理作业执行顺序</p><p>Zookeeper：主节点挂掉自动选择从节点作为主的</p><p>Flume：日志收集框架</p><p>Sqoop：数据交换框架</p><p>Hbase：海量数据中的查询，相当于分布式文件系统中的数据库</p><p>Spark：分布式的计算框架，基于内存</p><ul><li>spark core</li><li>spark sql</li><li>spark streaming 准实时的一个标准的流式计算</li><li>spark ML</li></ul><p>Kafka：消息队列</p><p>Storm：分布式的流式计算框架</p><p>Flink：分布式的流式计算框架</p><h3 id="Hadoop生态的特点"><a href="#Hadoop生态的特点" class="headerlink" title="Hadoop生态的特点"></a>Hadoop生态的特点</h3><ul><li>开源、社区活跃</li><li>囊括了大数据处理的方方面面</li><li>成熟的生态圈</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-近邻算法</title>
      <link href="/blog/2019/08/12/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/08/12/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="K-Nearest-Neighbor算法"><a href="#K-Nearest-Neighbor算法" class="headerlink" title="K Nearest Neighbor算法"></a>K Nearest Neighbor算法</h1><p>K-近邻算法又叫KNN算法，这个算是机器学习里面一个较为经典的算法。</p><ul><li>定义：如果一个样本在特征空间中的<strong>K个最相似的样本中大多数属于某个类别，则该样本也属于这个类别</strong></li></ul><h2 id="距离度量方式"><a href="#距离度量方式" class="headerlink" title="距离度量方式"></a>距离度量方式</h2><h3 id="欧式距离（Euclidean-Distance）"><a href="#欧式距离（Euclidean-Distance）" class="headerlink" title="欧式距离（Euclidean Distance）"></a>欧式距离（Euclidean Distance）</h3><p>欧式距离是最直接的度量方法，直接计算两个坐标点之间的距离</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_1.png"></p><h3 id="曼哈顿距离（Manhattan-Distance）"><a href="#曼哈顿距离（Manhattan-Distance）" class="headerlink" title="曼哈顿距离（Manhattan Distance）"></a>曼哈顿距离（Manhattan Distance）</h3><p>曼哈顿距离指的是城市街道之间的路程距离，有称为“城市街区距离”</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_2.png"></p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_3.png"></p><h3 id="切比雪夫距离（Chebyshev-Distance）"><a href="#切比雪夫距离（Chebyshev-Distance）" class="headerlink" title="切比雪夫距离（Chebyshev Distance）"></a>切比雪夫距离（Chebyshev Distance）</h3><p>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动当相邻8个方格中的任意一个，计算从格子1走到格子2最少需要多少步，这个距离就叫切比雪夫距离。</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_4.png"></p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_5.png"></p><h3 id="闵可夫斯基距离（Minkowski-Distance）"><a href="#闵可夫斯基距离（Minkowski-Distance）" class="headerlink" title="闵可夫斯基距离（Minkowski Distance）"></a>闵可夫斯基距离（Minkowski Distance）</h3><p>闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。两个n维变量a(x11,x12,…,x1n)与b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_6.png"></p><p>其中p是一个变参数：</p><p>当p=1时，就是曼哈顿距离；</p><p>当p=2时，就是欧氏距离；</p><p>当p→∞时，就是切比雪夫距离。</p><p>根据p的不同，闵氏距离可以表示某一类/种的距离。</p><p>以上几种距离的缺点就是：每个分量的单位当成同样看待了</p><h3 id="标准化欧式距离（Standardized-EuclideanDistance）"><a href="#标准化欧式距离（Standardized-EuclideanDistance）" class="headerlink" title="标准化欧式距离（Standardized EuclideanDistance）"></a>标准化欧式距离（Standardized EuclideanDistance）</h3><p>标准化欧式距离是针对欧式距离的缺点而做的一种改进，思路就是把每一个分量上的数值进行标准化处理</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_7.png"></p><p>如果将方差的倒数看成一个权重，也可以乘之为加权欧式距离</p><h3 id="余弦距离（Cosine-Distance）"><a href="#余弦距离（Cosine-Distance）" class="headerlink" title="余弦距离（Cosine Distance）"></a>余弦距离（Cosine Distance）</h3><p>几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异。</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_8.png"></p><p>夹角余弦取值范围为[-1,1]。余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大。当两个向量的方向重合时余弦取最大值1，当两个向量的方向完全相反余弦取最小值-1。</p><h3 id="汉明距离（Hamming-Distance）"><a href="#汉明距离（Hamming-Distance）" class="headerlink" title="汉明距离（Hamming Distance）"></a>汉明距离（Hamming Distance）</h3><p>两个等长字符串s1与s2的汉明距离为：将其中一个变为另一个字符所要替换的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The Hamming distance between &quot;1011101&quot; and &quot;1001001&quot; is 2. </span><br><span class="line">The Hamming distance between &quot;2143896&quot; and &quot;2233796&quot; is 3. </span><br><span class="line">The Hamming distance between &quot;toned&quot; and &quot;roses&quot; is 3.</span><br></pre></td></tr></table></figure><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_9.png"></p><h3 id="杰卡德距离（Jaccard-Distance）"><a href="#杰卡德距离（Jaccard-Distance）" class="headerlink" title="杰卡德距离（Jaccard Distance）"></a>杰卡德距离（Jaccard Distance）</h3><p>杰卡德相似系数：两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数：</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_10.png"></p><p>杰卡德距离：与杰卡德相似系数相反，用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度：</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_11.png"></p><h3 id="马氏距离（Mahalanobis-Distance）"><a href="#马氏距离（Mahalanobis-Distance）" class="headerlink" title="马氏距离（Mahalanobis Distance）"></a>马氏距离（Mahalanobis Distance）</h3><p>下图有两个正态分布图，它们的均值分别为a和b，但方差不一样，则图中的A点离哪个总体更近？或者说A有更大的概率属于谁？显然，A离左边的更近，A属于左边总体的概率更大，尽管A与a的欧式距离远一些。这就是马氏距离的直观解释。</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_12.png"></p><p>马氏距离是基于样本分布的一种距离。</p><p>马氏距离是由印度统计学家马哈拉诺比斯提出的，表示数据的协方差距离。它是一种有效的计算两个位置样本集的相似度的方法。</p><p>与欧式距离不同的是，它考虑到各种特性之间的联系，即独立于测量尺度。</p><p><strong>马氏距离定义：</strong>设总体G为m维总体（考察m个指标），均值向量为μ=（μ1，μ2，… …，μm，）`,协方差阵为∑=（σij）,</p><p>则样本X=（X1，X2，… …，Xm，）`与总体G的马氏距离定义为：</p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_13.png"></p><p>马氏距离也可以定义为两个服从同一分布并且其协方差矩阵为∑的随机变量的差异程度：如果协方差矩阵为单位矩阵，马氏距离就简化为欧式距离；如果协方差矩阵为对角矩阵，则其也可称为正规化的欧式距离。</p><p><strong>马氏距离特性：</strong></p><p>1.<strong>量纲无关</strong>，排除变量之间的相关性的干扰；</p><p>2.<strong>马氏距离的计算是建立在总体样本的基础上的</strong>，如果拿同样的两个样本，放入两个不同的总体中，最后计算得出的两个样本间的马氏距离通常是不相同的，除非这两个总体的协方差矩阵碰巧相同；</p><p>3 .计算马氏距离过程中，<strong>要求总体样本数大于样本的维数</strong>，否则得到的总体样本协方差矩阵逆矩阵不存在，这种情况下，用欧式距离计算即可。</p><p>4.还有一种情况，满足了条件总体样本数大于样本的维数，但是协方差矩阵的逆矩阵仍然不存在，比如三个样本点（3，4），（5，6），（7，8），这种情况是因为这三个样本在其所处的二维空间平面内共线。这种情况下，也采用欧式距离计算。</p><p><strong>欧式距离&amp;马氏距离：</strong></p><p><img src="/blog/img/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95_14.png"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 集群搭建</title>
      <link href="/blog/2019/08/12/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/blog/2019/08/12/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka-集群搭建"><a href="#Kafka-集群搭建" class="headerlink" title="Kafka 集群搭建"></a>Kafka 集群搭建</h1><h3 id="一，-Zookeeper-集群安装"><a href="#一，-Zookeeper-集群安装" class="headerlink" title="一， Zookeeper 集群安装"></a>一， Zookeeper 集群安装</h3><p>  0, 准备工作： 修改机器打开文件句柄数量为最大，格式化磁盘xfs格式， 注意：尽量保持kafka的数据放到单独的磁盘</p><p>   1, 创建日志目录和数据目录</p><p>​          mkdir /data/zookeeper/logs  &amp;&amp; mkdir /data/zookeeper/data</p><p>   2, 解压zookeeper压缩包: </p><p>​           tar –xvf zookeeper-xxx.tar.gz</p><p>   3,  拷贝配置文件</p><p>​           cd zookeeper-xxx  &amp;&amp; cp conf/zoo_sample.cfg conf/zoo.cfg</p><p>   4,  修改配置文件zoo.cfg </p><p>​           设置 dataDir=/data/zookeeper/data  设置 dataLogDir=/data/zookeeper/logs</p><p>   5, 修改集群配置（如有三台机）</p><p>​           server.1=192.168.1.1:2888:3888       </p><p>​          server.2=192.168.1.2:2888:3888     </p><p>​           server.3=192.168.1.3:2888:3888</p><p>   6, 创建主机标识ID:</p><p>​       在第一台机器上执行： echo “1”&gt; /data/zookeeper/data/myid</p><p>​       在第二台机器上执行： echo “2”&gt; /data/zookeeper/data/myid</p><p>​       在第三台机器上执行： echo “3”&gt; /data/zookeeper/data/myid</p><p>​    7，启动zookeeper: cd zookeeper-xxx/bin &amp;&amp; sh zkServer.sh start</p><p>​    8, 查看启动日志  cd zookeeper-xx &amp;&amp; tail –f zookeeper.out</p><h3 id="二，-Kafka-集群安装"><a href="#二，-Kafka-集群安装" class="headerlink" title="二， Kafka 集群安装"></a>二， Kafka 集群安装</h3><p>1, 解压缩kafka文件</p><p>​          tar –xvf kafka_2.11-xxx.tgz</p><p>2, 创建kafka数据目录</p><p>​         mkdir /data/kafka/data</p><p>3, 修改配置文件server.properties</p><p>​         1）修改broker编号</p><p>​          broker.id=1(第一台机配置文件中修改为)</p><p>​          broker.id=2(第二台机配置文件中修改为)</p><p>​          broker.id=3(第三台机配置文件中修改为)</p><p>​        2） 修改数据目录</p><p>​          log.dir=/data/kafka/data</p><p>​         3）修改zookeeper 连接地址</p><p>​              zookeeper.connect=192.168.1.1:2181,192.168.1.2:2181, 192.168.1.3:2181</p><p>​         4）修改备份因子配置：</p><p>​                default.replication.factor=2</p><p>​         5）配置监听IP和端口</p><p>​         listeners=<a href="plaintext://192.168.1.1:9092">PLAINTEXT://192.168.1.1:9092</a>(第一台机配置文件中修改为)</p><p>​         listeners=<a href="plaintext://192.168.1.2:9092">PLAINTEXT://192.168.1.2:9092</a>(第二台机配置文件中修改为)</p><p>​         listeners=<a href="plaintext://192.168.1.3:9092">PLAINTEXT://192.168.1.3:9092</a>(第三台机配置文件中修改为)</p><p>   4, 启动kafka</p><p>​              cd kafka-xxx &amp;&amp; nohup bin/kafka-server.sh config/server.properties &amp;</p><p>  5, 查看启动日志</p><p>​              cd kafka-xxx/logs &amp;&amp; tail –f server.log</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之cat</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bcat/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bcat/</url>
      
        <content type="html"><![CDATA[<h1 id="cat-命令用于连接文件并打印到标准输出设备上"><a href="#cat-命令用于连接文件并打印到标准输出设备上" class="headerlink" title="cat 命令用于连接文件并打印到标准输出设备上"></a><strong>cat 命令用于连接文件并打印到标准输出设备上</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;cat [-nbse]  fileName&#96;&#96;cat -参数 文件名&#96;&#96;cat -n &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-n 由 1 开始对所有输出的行数编号</li><li>-b 和 -n 相似，只不过对于空白行不编号</li><li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-e 在每行结束处显示 $</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>cat /tmp/test/txt1.txt</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>设定原文档内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;111&#96; &#96;222&#96;&#96;333&#96;&#96;444&#96;   &#96;555&#96;&#96;666&#96;&#96;777&#96;&#96;888&#96;&#96;999&#96;</span><br></pre></td></tr></table></figure><p>带行号输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:test jingjian$ cat -n &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;&#96;     &#96;&#96;1&#96;  &#96;111&#96;&#96;     &#96;&#96;2&#96;&#96;     &#96;&#96;3&#96;  &#96;222&#96;&#96;     &#96;&#96;4&#96;  &#96;333&#96;&#96;     &#96;&#96;5&#96;  &#96;444&#96;&#96;     &#96;&#96;6&#96;&#96;     &#96;&#96;7&#96;&#96;     &#96;&#96;8&#96;&#96;     &#96;&#96;9&#96;  &#96;555&#96;&#96;    &#96;&#96;10&#96;  &#96;666&#96;&#96;    &#96;&#96;11&#96;  &#96;777&#96;&#96;    &#96;&#96;12&#96;  &#96;888&#96;&#96;    &#96;&#96;13&#96;  &#96;999&#96;</span><br></pre></td></tr></table></figure><p>忽略空行行号，多行空行合并，行末尾标记，带行号输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:test jingjian$ cat -nbse &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;&#96;     &#96;&#96;1&#96;  &#96;111&#96;&#96;$&#96;&#96;$&#96;&#96;     &#96;&#96;2&#96;  &#96;222&#96;&#96;$&#96;&#96;     &#96;&#96;3&#96;  &#96;333&#96;&#96;$&#96;&#96;     &#96;&#96;4&#96;  &#96;444&#96;&#96;$&#96;&#96;$&#96;&#96;     &#96;&#96;5&#96;  &#96;555&#96;&#96;$&#96;&#96;     &#96;&#96;6&#96;  &#96;666&#96;&#96;$&#96;&#96;     &#96;&#96;7&#96;  &#96;777&#96;&#96;$&#96;&#96;     &#96;&#96;8&#96;  &#96;888&#96;&#96;$&#96;&#96;     &#96;&#96;9&#96;  &#96;999&#96;&#96;$&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之cd</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bcd/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bcd/</url>
      
        <content type="html"><![CDATA[<h1 id="cd命令用于切换当前工作目录至-dirName-目录参数"><a href="#cd命令用于切换当前工作目录至-dirName-目录参数" class="headerlink" title="cd命令用于切换当前工作目录至 dirName(目录参数)"></a><strong>cd命令用于切换当前工作目录至 dirName(目录参数)</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;cd [dirName]&#96;&#96;cd 目录&#96;&#96;cd &#x2F;tmp&#x2F;test&#96;</span><br></pre></td></tr></table></figure><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>跳转到/tmp/test目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ cd &#x2F;tmp&#x2F;test&#96;&#96;jingjiandeMacBook-Pro:test jingjian$&#96;</span><br></pre></td></tr></table></figure><p>跳转到自己的home目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:test jingjian$ cd ~&#96;&#96;jingjiandeMacBook-Pro:~ jingjian$&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之ifconfig</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bifconfig/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bifconfig/</url>
      
        <content type="html"><![CDATA[<h1 id="ifconfig-命令可用于显示或设置网络设备"><a href="#ifconfig-命令可用于显示或设置网络设备" class="headerlink" title="ifconfig 命令可用于显示或设置网络设备"></a><strong>ifconfig 命令可用于显示或设置网络设备</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc add&lt;地址&gt; del&lt;地址&gt;]</span><br><span class="line">ifconfig  网络设备名  选项</span><br><span class="line"></span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>add&lt;地址&gt; 设置网络设备IPv6的IP地址。</li><li>del&lt;地址&gt; 删除网络设备IPv6的IP地址。</li><li>down 关闭指定的网络设备。</li><li>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。</li><li>io_addr&lt;I/O地址&gt; 设置网络设备的I/O地址。</li><li>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。</li><li>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。</li><li>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。</li><li>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。</li><li>mtu&lt;字节&gt; 设置网络设备的MTU。</li><li>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。</li><li>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。</li><li>up 启动指定的网络设备。</li><li>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。</li><li>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。</li><li>-promisc 关闭或启动指定网络设备的promiscuous模式。</li><li>[IP地址] 指定网络设备的IP地址。</li><li>[网络设备] 指定网络设备的名称。</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>ifconfig</li><li>ifconfig eth0 down</li><li>ifconfig eth0 up</li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>查看所有网卡信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">     inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">     inet6 addr: fe80::250:56ff:fe0a:b0c&#x2F;64 Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">     RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:1000 </span><br><span class="line">     RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</span><br><span class="line">     Interrupt:185 Base address:0x2024 </span><br><span class="line"></span><br><span class="line">lo    Link encap:Local Loopback </span><br><span class="line">     inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">     inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">     UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">     RX packets:2022 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:0 </span><br><span class="line">     RX bytes:2459063 (2.3 MiB) TX bytes:2459063 (2.3 MiB)</span><br></pre></td></tr></table></figure><p>关闭/启动指定网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 down   &#x2F;&#x2F; 关闭eth0网卡</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 up       &#x2F;&#x2F; 开启eth0网卡</span><br></pre></td></tr></table></figure><p>为网卡配置和删除IPv6地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 add 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡设置IPv6地址</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 del 33ffe:3240:800:1005::2&#x2F; 64 &#x2F;&#x2F;为网卡删除IPv6地址</span><br></pre></td></tr></table></figure><p>用ifconfig修改MAC地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 down &#x2F;&#x2F;关闭网卡</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE &#x2F;&#x2F;修改MAC地址</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 up &#x2F;&#x2F;启动网卡</span><br><span class="line"></span><br><span class="line">$ ifconfig eth1 hw ether 00:1D:1C:1D:1E &#x2F;&#x2F;关闭网卡并修改MAC地址</span><br><span class="line"></span><br><span class="line">$ ifconfig eth1 up &#x2F;&#x2F;启动网卡</span><br></pre></td></tr></table></figure><p>配置IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 192.168.1.56 &#x2F;&#x2F;给eth0网卡配置IP地址</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 192.168.1.56 netmask 255.255.255.0 &#x2F;&#x2F; 给eth0网卡配置IP地址,并加上子掩码</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255 &#x2F;&#x2F; 给eth0网卡配置IP地址,加上子掩码,加上个广播地址</span><br></pre></td></tr></table></figure><p>启用和关闭ARP协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 arp &#x2F;&#x2F;开启</span><br><span class="line"></span><br><span class="line">$ ifconfig eth0 -arp &#x2F;&#x2F;关闭</span><br></pre></td></tr></table></figure><p>设置最大传输单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 mtu 1500  &#x2F;&#x2F;设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令之ls</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/</url>
      
        <content type="html"><![CDATA[<h1 id="ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录"><a href="#ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录" class="headerlink" title="ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)"></a><strong>ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)</strong></h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls [-alrtAFR] [name...]</span><br><span class="line">ls -参数 目标路径   </span><br><span class="line">ls -l &#x2F;tmp&#x2F;test</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-T 显示完整的年月日时分秒时间</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)  </li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>ls</li><li>ls -l</li><li>ls -A</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>列出/tmp/test目录下的所有的文件及目录(包括.和..）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jingjiandeMacBook-Pro:&#x2F; jingjian$ ls -a &#x2F;tmp&#x2F;test</span><br><span class="line">.       ..      .ssh        folder1     folder2     txt1.txt    txt2.txt</span><br></pre></td></tr></table></figure><p>按创建时间先后顺序展示区分目录下所有的目录及文件的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jingjiandeMacBook-Pro:&#x2F; jingjian$ ls -ltrFA &#x2F;tmp&#x2F;test</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  6 jingjian  wheel  192  6 17 15:00 .ssh&#x2F;</span><br><span class="line">-rw-r--r--  1 jingjian  wheel    0  6 17 15:00 txt1.txt</span><br><span class="line">-rw-r--r--  1 jingjian  wheel    0  6 17 15:00 txt2.txt</span><br><span class="line">drwxr-xr-x  2 jingjian  wheel   64  6 17 15:01 folder2&#x2F;</span><br><span class="line">drwxr-xr-x  4 jingjian  wheel  128  6 17 15:01 folder1&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之mkdir</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bmkdir/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bmkdir/</url>
      
        <content type="html"><![CDATA[<h1 id="mkdir-命令可用于创建一个新的文件夹"><a href="#mkdir-命令可用于创建一个新的文件夹" class="headerlink" title="mkdir 命令可用于创建一个新的文件夹"></a><strong>mkdir 命令可用于创建一个新的文件夹</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;mkdir [-p] [dirname]&#96; &#96;mkdir -参数 文件夹&#96; &#96;mkdir -p &#x2F;tmp&#x2F;test&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-p 确保目录名称存在，不存在就创建一个</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>mkdir text</li><li>mkdir -p text1/text2/text3</li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>创建文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir text </span><br><span class="line">$ ls text&#x2F;</span><br></pre></td></tr></table></figure><p>一次性创建多层文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p text1&#x2F;text2&#x2F;text3 </span><br><span class="line"></span><br><span class="line">$ ls </span><br><span class="line">text&#x2F; text1&#x2F; </span><br><span class="line"></span><br><span class="line">$ cd text1&#x2F; </span><br><span class="line"></span><br><span class="line">$ ls </span><br><span class="line">text2&#x2F; </span><br><span class="line"></span><br><span class="line">$ cd text2&#x2F; </span><br><span class="line"></span><br><span class="line">$ ls </span><br><span class="line">text3&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之ping</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bping/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bping/</url>
      
        <content type="html"><![CDATA[<h1 id="ping-命令可用于检测主机于目标主机之间网络是否通畅"><a href="#ping-命令可用于检测主机于目标主机之间网络是否通畅" class="headerlink" title="ping 命令可用于检测主机于目标主机之间网络是否通畅"></a><strong>ping 命令可用于检测主机于目标主机之间网络是否通畅</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ping [-dfnqrRvciIlpst] [addressname]&#96; &#96;ping -参数 地址&#96; &#96;ping www.baidu.com&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-d 使用Socket的SO_DEBUG功能。</li><li>-c&lt;完成次数&gt; 设置完成要求回应的次数。</li><li>-f 极限检测。</li><li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li><li>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。</li><li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li><li>-n 只输出数值。</li><li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li><li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li><li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-R 记录路由过程。</li><li>-s&lt;数据包大小&gt; 设置数据包的大小。</li><li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li><li>-v 详细显示指令的执行过程。</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>ping <a href="http://www.baidu.com/">www.baidu.com</a></li><li>ping -c 2 <a href="http://www.baidu.com/">www.baidu.com</a></li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>测试主机是否与外部网络连通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@bufan ~]#  ping www.baidu.com</span><br><span class="line"></span><br><span class="line">PING www.a.shifen.com (180.101.49.12) 56(84) bytes of data.</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;1 ttl&#x3D;128 time&#x3D;8.50 ms</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;2 ttl&#x3D;128 time&#x3D;10.9 ms</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;3 ttl&#x3D;128 time&#x3D;10.4 ms</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;4 ttl&#x3D;128 time&#x3D;10.2 ms</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;5 ttl&#x3D;128 time&#x3D;10.8 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4007ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 8.501&#x2F;10.209&#x2F;10.965&#x2F;0.897 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要手动Ctrl+c终止</span><br></pre></td></tr></table></figure><p>指定接收包的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@bufan ~]# ping -c 2 www.baidu.com</span><br><span class="line">PING www.a.shifen.com (180.101.49.12) 56(84) bytes of data.</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;1 ttl&#x3D;128 time&#x3D;13.6 ms</span><br><span class="line">64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;2 ttl&#x3D;128 time&#x3D;10.5 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1005ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 10.582&#x2F;12.098&#x2F;13.615&#x2F;1.520 ms</span><br></pre></td></tr></table></figure><p>多参数使用（-i：每3秒发送一次，-s：包大小为1024）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@bufan ~]# ping -i 3 -s 1024 www.baidu.com</span><br><span class="line">PING www.a.shifen.com (180.101.49.12) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;1 ttl&#x3D;128 time&#x3D;10.9 ms</span><br><span class="line">1032 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;2 ttl&#x3D;128 time&#x3D;12.2 ms</span><br><span class="line">1032 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;3 ttl&#x3D;128 time&#x3D;13.7 ms</span><br><span class="line">1032 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;4 ttl&#x3D;128 time&#x3D;14.1 ms</span><br><span class="line">1032 bytes from 180.101.49.12 (180.101.49.12): icmp_seq&#x3D;5 ttl&#x3D;128 time&#x3D;16.7 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 12048ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 10.977&#x2F;13.569&#x2F;16.732&#x2F;1.945 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之rm</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Brm/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Brm/</url>
      
        <content type="html"><![CDATA[<h1 id="rm命令用于删除一个文件或者目录"><a href="#rm命令用于删除一个文件或者目录" class="headerlink" title="rm命令用于删除一个文件或者目录"></a><strong>rm命令用于删除一个文件或者目录</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;rm [-ifr] name...&#96;&#96;rm -参数 目录&#x2F;文件&#96;&#96;rm -rf &#x2F;&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-i 删除前逐一询问确认</li><li>-f 强行删除，无需逐一确认</li><li>-r 将目录及其下所有亦逐一删除</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>rm</li><li>rm -r</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>逐一删除/tmp/test下的所有目录/文件  并取消</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ rm -ir &#x2F;tmp&#x2F;test&#x2F;*&#96;&#96;examine files in directory &#x2F;tmp&#x2F;test&#x2F;folder1? n&#96;&#96;examine files in directory &#x2F;tmp&#x2F;test&#x2F;folder2? n&#96;&#96;remove &#x2F;tmp&#x2F;test&#x2F;txt1.txt? n&#96;&#96;remove &#x2F;tmp&#x2F;test&#x2F;txt2.txt? n&#96;</span><br></pre></td></tr></table></figure><p>强制删除/tmp/test/folder1下面的所有文件及目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ rm -rf &#x2F;tmp&#x2F;test&#x2F;folder1&#x2F;*&#96;&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ ls &#x2F;tmp&#x2F;test&#x2F;folder1&#96;&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$&#96;</span><br></pre></td></tr></table></figure><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p>rm -rf 使用需谨慎再谨慎</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之tail</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btail/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btail/</url>
      
        <content type="html"><![CDATA[<h1 id="tail-命令可用于查看文件的内容，有一个常用的参数-f-常用于查阅正在改变的日志文件"><a href="#tail-命令可用于查看文件的内容，有一个常用的参数-f-常用于查阅正在改变的日志文件" class="headerlink" title="tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件"></a><strong>tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;tail [-fn] [filename]&#96;&#96;tail -参数 文件&#96;&#96;tail -f &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-f 循环读取</li><li>-n &lt;行数&gt; 显示文件的尾部 n 行内容</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>tail -f /tmp/test/txt1.txt</li><li>tail -n 5 /tmp/test/txt1.txt</li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>持续查看/tmp/test/txt1.txt文件最新内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ tail -f &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;&#96;333&#96;&#96;444&#96;   &#96;555&#96;&#96;666&#96;&#96;777&#96;&#96;888&#96;&#96;999&#96;</span><br></pre></td></tr></table></figure><p>查看/tmp/test/txt1.txt文件末五行内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$ tail -n &#96;&#96;5&#96; &#96;&#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;&#96;555&#96;&#96;666&#96;&#96;777&#96;&#96;888&#96;&#96;999&#96;&#96;jingjiandeMacBook-Pro:&#x2F; jingjian$&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之touch</title>
      <link href="/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btouch/"/>
      <url>/blog/2019/08/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btouch/</url>
      
        <content type="html"><![CDATA[<h1 id="torch-命令可用于创建一个新文件"><a href="#torch-命令可用于创建一个新文件" class="headerlink" title="torch 命令可用于创建一个新文件"></a><strong>torch 命令可用于创建一个新文件</strong></h1><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;touch [-acdfmrt] [filename]&#96; &#96;touch -参数 文件&#96; &#96;touch &#x2F;tmp&#x2F;test&#x2F;txt1.txt&#96;</span><br></pre></td></tr></table></figure><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-a   或–time=atime或–time=access或–time=use 　只更改存取时间。</li><li>-c   或–no-create 　不建立任何文档。</li><li>-d 　使用指定的日期时间，而非现在的时间。</li><li>-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</li><li>-m   或–time=mtime或–time=modify 　只更改变动时间。</li><li>-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</li><li>-t 　使用指定的日期时间，而非现在的时间。</li></ul><h2 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h2><ul><li>torch text.txt</li><li>torch text1.txt text2.txt</li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>创建单个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch text.txt $ ls text.txt</span><br></pre></td></tr></table></figure><p>一次性创建多个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch text1.txt text2.txt </span><br><span class="line">$ ls </span><br><span class="line">text.txt text1.txt text2.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/blog/2019/08/12/MapReduce/"/>
      <url>/blog/2019/08/12/MapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="MapReduce简介"><a href="#MapReduce简介" class="headerlink" title="MapReduce简介"></a>MapReduce简介</h1><h2 id="什么是MapReduce"><a href="#什么是MapReduce" class="headerlink" title="什么是MapReduce"></a>什么是MapReduce</h2><ul><li>源于Google的MapReduce论文(2004年12月)</li><li>Hadoop的MapReduce是Google论文的开源实现</li><li>MapReduce优点：海量数据离线处理&amp;易开发</li><li>MapRedecu缺点：实时流式计算</li></ul><h2 id="MapReduce编程模型"><a href="#MapReduce编程模型" class="headerlink" title="MapReduce编程模型"></a>MapReduce编程模型</h2><ul><li><p>MapReduce分而治之的思想：就是数据在那台计算机上，这台计算机上的数据就归这台计算机处理，处理完成后进行汇总</p></li><li><p>MapReduce编程分Map和Reduce阶段</p><ul><li>将作业拆分成Map和Reduce阶段</li><li>Map阶段：将复杂问题分解成若干个简单的任务</li><li>Reduce阶段：对Map阶段返回的数据进行汇总处理</li><li>Word Count词频统计案例：</li></ul><p><img src="/blog/img/MapReduce_1.png" alt="MapReduce_1"></p></li></ul><h1 id="MapReduce实例"><a href="#MapReduce实例" class="headerlink" title="MapReduce实例"></a>MapReduce实例</h1><h2 id="mrjob简介"><a href="#mrjob简介" class="headerlink" title="mrjob简介"></a>mrjob简介</h2><ul><li>使用python开发在Hadoop上运行的程序，mrjob是最简单的方式</li><li>mejob程序可以在本地测试运行也可以部署在Hadoop集群上运行</li><li>使用pip安装：pip install mejob</li></ul><h2 id="mrjob实现词频统计"><a href="#mrjob实现词频统计" class="headerlink" title="mrjob实现词频统计"></a>mrjob实现词频统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MRWordCount</span>(<span class="params">MRJob</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#每一行从line中输入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, _, line</span>):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> line.split():</span><br><span class="line">            <span class="keyword">yield</span> word,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># word相同的 会走到同一个reduce</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span>(<span class="params">self, word, counts</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> word, <span class="built_in">sum</span>(counts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    MRWordCount.run()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mr_word_count.py 文档路径</span><br></pre></td></tr></table></figure><h2 id="运行MRJOB的不同方式"><a href="#运行MRJOB的不同方式" class="headerlink" title="运行MRJOB的不同方式"></a>运行MRJOB的不同方式</h2><ul><li><p>内嵌(-r inline)方式</p><ul><li>特点是调试方便，启动单一进程模拟任务执行状态和结果，默认(-r inline)可以省略，输出文件使用 &gt; output-file 或-o output-file，比如下面两种运行方式是等价的</li><li>python word_count.py -r inline input.txt &gt; output.txt python word_count.py input.txt &gt; output.txt</li></ul></li><li><p>本地(-r local)方式</p><ul><li>用于本地模拟Hadoop调试，与内嵌(inline)方式的区别是启动了多进程执行每一个任务。如：</li><li>python word_count.py -r local input.txt &gt; output1.txt</li></ul></li><li><p>Hadoop(-r hadoop)方式</p><ul><li>用于hadoop环境，支持Hadoop运行调度控制参数，如：</li></ul></li><li><p>指定Hadoop任务调度优先级(VERY_HIGH|HIGH),如：–jobconf mapreduce.job.priority=VERY_HIGH。</p></li><li><p>Map及Reduce任务个数限制，如：–jobconf mapreduce.map.tasks=2 –jobconf mapreduce.reduce.tasks=5</p><ul><li>python word_count.py -r hadoop hdfs:///test.txt -o hdfs:///output</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N-Garm</title>
      <link href="/blog/2019/08/12/N-garm/"/>
      <url>/blog/2019/08/12/N-garm/</url>
      
        <content type="html"><![CDATA[<h1 id="N-garm"><a href="#N-garm" class="headerlink" title="N-garm"></a>N-garm</h1><p>概念：在<strong>计算某一个单词出现的概率的时候，不考虑它的全部的历史，只考虑最接近的N个词语，从而近似的逼近该单词的在该句子中出现的概率</strong></p><p>如：二元语法模型</p><p><img src="/blog/img/N-garm_1.jpg"></p><p>一个单词出现只和它之前的有限个词语相关，这种假设也被称为<strong>马尔科夫假设</strong></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy</title>
      <link href="/blog/2019/08/12/Numpy/"/>
      <url>/blog/2019/08/12/Numpy/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><h2 id="Numpy简介"><a href="#Numpy简介" class="headerlink" title="Numpy简介"></a>Numpy简介</h2><p>Numpy是开源的Python科学计算库，用于快速处理任意维度的数组。</p><p>Numpy支持常见的数组和矩阵操作。对于同样的数值的计算任务，使用Numpy比直接使用Python要简洁的多。</p><p>Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。</p><ul><li>ndarray的优势<ul><li><strong>内存块风格</strong>：ndarray在存储数据时是连续存储的，不像python的list先得寻址再找数据</li><li><strong>ndarray支持并行化运算</strong>：Numpy底层使用C语言编写，内部杰出了GIL锁，器对数组得操作速度不受python解释器的限制。</li></ul></li></ul><h2 id="N维数组-ndarray"><a href="#N维数组-ndarray" class="headerlink" title="N维数组-ndarray"></a>N维数组-ndarray</h2><ul><li><strong>生成ndarray方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 按照输入的列表生成一个数组</span><br><span class="line">np1 &#x3D; np.array([[1,2,3],[4,5,6]])</span><br><span class="line"># 生成全为0的3行4列的数组</span><br><span class="line">np1 &#x3D; np.zeros([3,4])</span><br><span class="line"># 生成全为1的3行4列的数组</span><br><span class="line">np1 &#x3D; np.ones([3,4])</span><br><span class="line"># 依照现有数组的形状生成一个新的全为0的数组</span><br><span class="line">np2 &#x3D; np.ones_like(np1)</span><br><span class="line"># 依照现有数组的形状生成一个新的全为1的数组</span><br><span class="line">np3 &#x3D; np.zeros_like(np2)</span><br><span class="line"># 生成一个固定范围内的等间隔数组值0开始，5结束，6个元素，包含结束值（默认为true包含）</span><br><span class="line">np3 &#x3D; np.linspace(0，5，6，true)  # array([0.,1.,2.,3.,4.,5.])</span><br><span class="line"># 生成一个固定步长的等间隔数组值0开始，5结束，步长为1</span><br><span class="line">np3 &#x3D; np.arange(0，5，1)  # array([0,1,2,3,4])</span><br><span class="line"># 生成一个均匀分布的[0,1)3行4列的数组</span><br><span class="line">np3 &#x3D; np.random.rand(3,4)</span><br><span class="line"># 生成一个[0,1)之间均匀分布的大小为10小数数组</span><br><span class="line">np3 &#x3D; np.random.uniform(low&#x3D;0.0,high&#x3D;1.0,size&#x3D;10)</span><br><span class="line"># 生成一个[0,10)之间均匀分布大小为10的整数数组</span><br><span class="line">np3 &#x3D; np.random.ranint(10,size&#x3D;10)</span><br><span class="line"># 生成一个[1,10)之间均匀分布大小为10的整数数组</span><br><span class="line">np3 &#x3D; np.random.ranint(1,high&#x3D;10,size&#x3D;10)</span><br><span class="line"># 生成一个标准正太分布的3行4列的数组</span><br><span class="line">np4 &#x3D; np.random.randn(3,4)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>ndarray的属性</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">np1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 获取数组形状（2，3）</span></span><br><span class="line">np1.shape</span><br><span class="line"><span class="comment"># 获取数组的类型 numpy.int64,也可以创建的时候定义np.array([[1,2,3],[4,5,6]],dtype=np.float32)</span></span><br><span class="line">np1.dtype</span><br><span class="line"><span class="comment"># 获取数组的维度 2</span></span><br><span class="line">np1.ndim</span><br><span class="line"><span class="comment"># 获取数组中元素数量 6</span></span><br><span class="line">np1.size</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">简写</th></tr></thead><tbody><tr><td align="center">np.bool</td><td align="center">用一个字节存储的布尔类型（True或False）</td><td align="center">‘b’</td></tr><tr><td align="center">np.int8</td><td align="center">一个字节大小，-128 至 127</td><td align="center">‘i’</td></tr><tr><td align="center">np.int16</td><td align="center">整数，-32768 至 32767</td><td align="center">‘i2’</td></tr><tr><td align="center">np.int32</td><td align="center">整数，-2 <strong>31 至 2</strong> 32 -1</td><td align="center">‘i4’</td></tr><tr><td align="center">np.int64</td><td align="center">整数，-2 <strong>63 至 2</strong> 63 - 1</td><td align="center">‘i8’</td></tr><tr><td align="center">np.uint8</td><td align="center">无符号整数，0 至 255</td><td align="center">‘u’</td></tr><tr><td align="center">np.uint16</td><td align="center">无符号整数，0 至 65535</td><td align="center">‘u2’</td></tr><tr><td align="center">np.uint32</td><td align="center">无符号整数，0 至 2 ** 32 - 1</td><td align="center">‘u4’</td></tr><tr><td align="center">np.uint64</td><td align="center">无符号整数，0 至 2 ** 64 - 1</td><td align="center">‘u8’</td></tr><tr><td align="center">np.float16</td><td align="center">半精度浮点数：16位，正负号1位，指数5位，精度10位</td><td align="center">‘f2’</td></tr><tr><td align="center">np.float32</td><td align="center">单精度浮点数：32位，正负号1位，指数8位，精度23位</td><td align="center">‘f4’</td></tr><tr><td align="center">np.float64</td><td align="center">双精度浮点数：64位，正负号1位，指数11位，精度52位</td><td align="center">‘f8’</td></tr><tr><td align="center">np.complex64</td><td align="center">复数，分别用两个32位浮点数表示实部和虚部</td><td align="center">‘c8’</td></tr><tr><td align="center">np.complex128</td><td align="center">复数，分别用两个64位浮点数表示实部和虚部</td><td align="center">‘c16’</td></tr><tr><td align="center">np.object_</td><td align="center">python对象</td><td align="center">‘O’</td></tr><tr><td align="center">np.string_</td><td align="center">字符串</td><td align="center">‘S’</td></tr><tr><td align="center">np.unicode_</td><td align="center">unicode类型</td><td align="center">‘U’</td></tr></tbody></table><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>索引切片</p><ul><li>索引：直接由外到内依次进行索引（用”,”隔开）[num,num,…]</li><li>切片：和python一样也是由外到内进行切片[num:num,num:num,…]</li></ul></li><li><p>形状改变</p><ul><li>ndarray.reshape(shape, order):返回一个具有相同数据域，但是shape不一样的array（装换前元素个数个转换后的个数必须一样）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np1 &#x3D; np.array([[1,2,3],[4,5,6]])</span><br><span class="line">np2 &#x3D; np1.reshape([3,2]) # array([[1,2],[3,4],[5,6]])</span><br><span class="line">np2 &#x3D; np1.reshape([-1,2])  # -1 表示待计算，只有np1元素总个数能够整除2就行</span><br></pre></td></tr></table></figure><ul><li>ndarray.resize(shape):在array原本的基础上进行修改，不返回新的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np1 &#x3D; np.array([[1,2,3],[4,5,6]])</span><br><span class="line">np1.resize([3,2])</span><br></pre></td></tr></table></figure><ul><li>ndarray.T:对数组进行转置,返回新的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np1.T</span><br></pre></td></tr></table></figure></li><li><p>类型改变</p><ul><li>ndarray.astype(type):返回新的改变类型后的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np2 &#x3D; np1.astype(np.float)</span><br></pre></td></tr></table></figure><ul><li>ndarray.tostring()或ndarray.tobytes()：把数组转换成base64的字符串</li></ul></li><li><p>数组取重</p><ul><li>np.unique(array):把数组拉平然后返回一个拉平后的去重数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np1 &#x3D; np.array([[1,2,3,4],[3,4,5,6]])</span><br><span class="line">np2 &#x3D; np.unique(np1) # array([1,2,3,4,5,6])</span><br></pre></td></tr></table></figure><h2 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a>ndarray运算</h2></li><li><p>逻辑运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np1 &#x3D; np.array([[1,2,3,4],[3,4,5,6]])</span><br><span class="line">np1&gt;3 # 返回一个相同形状的True和Flase的矩阵，大于3的为True，否则为Flase</span><br><span class="line"></span><br><span class="line">np1[np1&gt;3]&#x3D;0 # 把是所有大于3的数据赋值为0</span><br></pre></td></tr></table></figure></li><li><p>通用判断</p><ul><li>np.all(array):判断array是否全为True</li><li>np.any(array):判断array中是否有True</li></ul></li><li><p>三元逻辑运算</p><ul><li>np.where(array&gt;num, 1, 0):把array中元素大于num的设置成1，否则设置成0.</li><li>复合逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.logical_and(array&gt;num1, array&lt;num2) #同and，返回一个与array形状相同的True&#x2F;Flase矩阵，满足条件的为True</span><br><span class="line">np.logical_or(array&gt;num1, array&lt;num2) #同or，返回一个与array形状相同的True&#x2F;Flase矩阵，满足条件的为True</span><br></pre></td></tr></table></figure></li><li><p>统计运算</p><ul><li>np.min(array,axis):返回沿axis轴最小值</li><li>np.max(array,axis):返回沿axis轴最大值</li><li>np.median(array,axis):返回沿axis轴中值</li><li>np.mean(array,axis):返回沿axis轴平均值</li><li>np.std(array,axis):返回沿axis轴标准差</li><li>np.var(array,axis):返回沿axis轴方差</li><li>np.argmax(array,axis):返回沿axis轴最大值的下标</li><li>np.argmin(array,axis):返回沿axis轴最小值的下标</li></ul></li></ul><h2 id="ndarray间的运算"><a href="#ndarray间的运算" class="headerlink" title="ndarray间的运算"></a>ndarray间的运算</h2><ul><li><p>数组与数之间的运算，分别对每个元素进行运算</p></li><li><p>数组与数组间的运算</p><ul><li><p>加、减：shape得一样或者对低维数组使用广播机制进行拓展之后可以使它们的shape一样</p></li><li><p>乘：前面的数组的行与后门数组的列必须使一致的，才能进行计算(M,N)*(N,L)=(M,L)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.matmul(array,array)</span><br><span class="line">np.dot(array,array)</span><br><span class="line"># 区别在于matmul禁止使用矩阵与标量相乘</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop</title>
      <link href="/blog/2019/08/12/Sqoop/"/>
      <url>/blog/2019/08/12/Sqoop/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqoop简介"><a href="#Sqoop简介" class="headerlink" title="Sqoop简介"></a>Sqoop简介</h1><p>Sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库<em>（例如 ： MySQL ,Oracle ,Postgres等）</em>中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><p>Sqoop项目开始于2009年，最早是作为Hadoop的一个第三方模块存在，后来为了让使用者能够快速部署，也为了让开发人员能够更快速的迭代开发，Sqoop独立成为一个<a href="https://baike.baidu.com/item/Apache/6265">Apache</a>项目。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow</title>
      <link href="/blog/2019/08/12/Tensorflow/"/>
      <url>/blog/2019/08/12/Tensorflow/</url>
      
        <content type="html"><![CDATA[<h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow&#x3D;&#x3D;1.12 -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple</span><br></pre></td></tr></table></figure><h2 id="TensorFlow结构分析"><a href="#TensorFlow结构分析" class="headerlink" title="TensorFlow结构分析"></a>TensorFlow结构分析</h2><p>TensorFlow程序通常被组织成一个构建图阶段和一个执行图阶段 </p><ul><li><p>构建阶段：数据与操作的执行步骤被描述成一个图</p></li><li><p>执行阶段：使用会话执行构建好的图中的操作</p></li><li><p>图和会话：</p><ul><li>图（graph）：这是TensorFlow将计算表示为指令之间的依赖关系的一种表示法</li><li>会话（session）：TensorFlow跨一个或多个本地或远程设备运行数据流图的机制</li></ul></li><li><p>张量（Tensor）：TensorFlow中的基本数据对象</p></li><li><p>节点（operation）：提供图当中执行的操作</p></li></ul><h2 id="图与TensorBoard"><a href="#图与TensorBoard" class="headerlink" title="图与TensorBoard"></a>图与TensorBoard</h2><h3 id="什么是图结构"><a href="#什么是图结构" class="headerlink" title="什么是图结构"></a>什么是图结构</h3><p>图包含了一组tf.Operation代表的计算单元对象和tf.Tensor代表的计算单元之间流动的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 获取默认图</span></span><br><span class="line">tf.get_default_graph()</span><br><span class="line"><span class="comment"># 通过Tensor获取该元素属于哪个图</span></span><br><span class="line">tensor.graph()</span><br><span class="line"><span class="comment"># 新建图并对图进行操作</span></span><br><span class="line">new_g = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> new_g.as_default():</span><br><span class="line">    new_a = tf.constant(<span class="number">10</span>)</span><br><span class="line">    new_b = tf.constant(<span class="number">20</span>)</span><br><span class="line">    new_c = tf.add(new_a,new_b)</span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=new_g) <span class="keyword">as</span> sess:</span><br><span class="line">    sum_new = sess.run(new_c)</span><br><span class="line">    print(sum_new)</span><br></pre></td></tr></table></figure><h3 id="TensorBoard-可视化工具"><a href="#TensorBoard-可视化工具" class="headerlink" title="TensorBoard:可视化工具"></a>TensorBoard:可视化工具</h3><p>TensorFlow可用于训练大规模深度神经网络，所需要的计算次数、时间往往都很长，而为了方便对TensorFlow程序的调试和优化，TensorFlow提供了TensorBoard可视化工具</p><ul><li><p><strong>开启TensorBoard步骤</strong></p><ul><li>TensorBoard通过读取TensorFLow的事件文件来运行，需要将数据生成一个序列化的Summary protobuf对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.summary.FileWriter(<span class="string">&#x27;/tmp/summary/&#x27;</span>, graph=sess.graph)</span><br></pre></td></tr></table></figure><ul><li>在这个指定的目录下会生一个event文件，器格式名如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">events.out.tfevents.&#123;timestamp&#125;.&#123;hostname&#125;</span><br></pre></td></tr></table></figure><ul><li>启动TensorBoard</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=&quot;/tmp/summary/&quot;</span><br></pre></td></tr></table></figure><ul><li>然后再浏览器中打开127.0.0.1:6006,就能看到TensorBoard网页了</li></ul></li><li><p><strong>收集其他变量</strong></p><ul><li>收集0维值<ul><li><strong>tf.summary.scalar(“变量名”，变量)</strong></li></ul></li><li>收集高维值<ul><li><strong>tf.summary.histogram(“变量名”，变量)</strong></li></ul></li><li>整合结果<ul><li>merge = tf.summary.merge_all()</li></ul></li><li>获取值<ul><li>sum_mary = sess.run(merge)</li></ul></li><li>写入值<ul><li>filewriter.add_summary(sum_mary,i)</li></ul></li></ul></li></ul><h3 id="OP"><a href="#OP" class="headerlink" title="OP"></a>OP</h3><p>OP是一个操作对象（Operation），是TensorFlow图中的一个节点，可以接收0个或多个输入Tensor，并且可以输出0个或多个Tensor，Operation对象是通过op构造函数（tf.add()）创建的。</p><p>OP运算包括下面这些：</p><table><thead><tr><th align="center">类型</th><th align="left">实例</th></tr></thead><tbody><tr><td align="center">标量运算</td><td align="left">add,sub,mul,div,exp,log,greater,less,equal</td></tr><tr><td align="center">向量运算</td><td align="left">concat,slice,splot,constant,rank,shape,shuffle</td></tr><tr><td align="center">矩阵运算</td><td align="left">matmul,matrixinverse,matrixdateminant</td></tr><tr><td align="center">带状态运算</td><td align="left">Variable,assgin,assginadd</td></tr><tr><td align="center">神经网络组件</td><td align="left">softmax,singmoid,relu,convolution,max_pool</td></tr><tr><td align="center">存储、恢复</td><td align="left">Save,Restroe</td></tr><tr><td align="center">队列及同步运算</td><td align="left">Enqueue,Dequeue,MutexAcquire,MutexRelease</td></tr><tr><td align="center">控制流</td><td align="left">Merge,Switch,Enter,Leave,Nextlteration</td></tr></tbody></table><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>一个运行TensorFlow operation的类，会话包含以下两种开启方式</p><ul><li>tf.Session：用于完整的程序中</li><li>tf.InteractiveSession：用于交互式上下文中的TensorFlow，例如shell</li></ul><p><strong>tf.Session(target=””,graph=None,config=None)</strong></p><ul><li>target:如果将次参数留空(默认设置)，会话将仅使用本地计算机设备，也可以指定远程设备。</li><li>graph:默认情况下，绑定当前程序的默认图</li><li>config:此参数允许您指定一个 tf.ConfigProto 以便控制会话的行为。例如，ConfigProto协议用于打印设备使用信息</li></ul><p><strong>run(fetches,feed_dict=None,options=None，run_metadata=None)</strong></p><ul><li>通过sess.run()来运行operation；多个以列表输入，返回结果也是多个</li><li>fetches:一个或多个operation；多个以列表输入，返回结果也是多个</li><li>feed_dict：参数允许调用者覆盖图中张量的值，运行时赋值<ul><li>与tf.placeholder搭配使用，会检查值得形状是否与占位符兼容</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 定义占位符tensor</span></span><br><span class="line">a = tf.placeholder(tf.float32)</span><br><span class="line">b = tf.placeholder(tf.float32)</span><br><span class="line">sum_ab = tf.add(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启会话</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sum_ab_value = sess.run(sum_ab,feed_dict=&#123;a:<span class="number">3.0</span>,b:<span class="number">4.0</span>&#125;)</span><br><span class="line">    print(sum_ab_value)</span><br></pre></td></tr></table></figure><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>TensorFlow的张量就时一个n维数组，类型维tf.Tensor。Tensor具有两个重要的属性</p><ul><li>type：数据类型</li></ul><p><img src="/blog/img/TensorFlow_1.png"></p><ul><li>shape：形状</li></ul><p><img src="/blog/img/TensorFlow_2.png"></p><h3 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h3><p>创建固定值张量</p><ul><li><strong>tf.zeros(shape,dtype=tf.float32,name=None)</strong><ul><li>创建一个shape形状，类型为tf.float32,值全为0的张量</li></ul></li><li><strong>tf.zeros_like(tensor)</strong><ul><li>根据已有tensor类型、形状，创建一个全为0的张量</li></ul></li><li><strong>tf.ones(shape,dtype=tf.float32,name=None)</strong><ul><li>创建一个shape形状，类型为tf.float32,值全为1的张量</li></ul></li><li><strong>tf.ones_like(tensor)</strong><ul><li>根据已有tensor类型、形状，创建一个全为1的张量</li></ul></li><li><strong>tf.fill(shape,value,name=None)</strong><ul><li>创建一个形状为shape，值为value的张量</li></ul></li><li><strong>tf.constant(value,dtype=None,shape=None,name=”Const”)</strong><ul><li>创建一个常数张量</li></ul></li></ul><p>创建随机张量</p><ul><li><strong>tf.random_normal(shape,mean=0.0,stddev=1.0,dtype=tf.float32)</strong><ul><li>从标准正太分布随机输出值，构成一个shape形状的矩阵</li></ul></li></ul><h3 id="张量的变换"><a href="#张量的变换" class="headerlink" title="张量的变换"></a>张量的变换</h3><ul><li><p><strong>类型改变</strong></p><ul><li><strong>tf.cast(tensor,dtype,name=None)</strong><ul><li>tensor:输入的tensor，</li><li>dtype：转换后的tensor类型</li></ul></li></ul></li><li><p><strong>形状改变</strong></p><ul><li>静态形状改变：只能更改还没有定义的形状如tf.placeholder(tf.float32,shape=[None,None])<ul><li><strong>tensor.set_shape(shape)</strong></li></ul></li><li>动态形状改变:可以改变tensor的形状，但是改变之后的元素总数得相同<ul><li><strong>tf.reshape(tensor，shape)</strong></li></ul></li></ul></li><li><p><strong>张量的运算</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">ts1 = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">ts1 = tf.constant(<span class="number">2.0</span>)</span><br><span class="line"><span class="comment"># 加</span></span><br><span class="line">ts_add = tf.add(ts1, ts2)</span><br><span class="line"><span class="comment"># 减</span></span><br><span class="line">ts_sub = tf.subtract(ts1, ts2)</span><br><span class="line"><span class="comment"># 乘</span></span><br><span class="line">ts_mul = tf.multiply(ts1, ts2)</span><br><span class="line"><span class="comment"># 除</span></span><br><span class="line">ts_div = tf.divide(ts1, ts2)</span><br><span class="line"><span class="comment"># 取余</span></span><br><span class="line">ts_mod = tf.mod(ts1, ts2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对值</span></span><br><span class="line">ts_abs = tf.<span class="built_in">abs</span>(ts1)</span><br><span class="line"><span class="comment"># 取反</span></span><br><span class="line">ts_neg = tf.negative(ts1)</span><br><span class="line"><span class="comment"># 四舍五入</span></span><br><span class="line">ts_rou = tf.<span class="built_in">round</span>(ts1)</span><br><span class="line"><span class="comment"># 取符号</span></span><br><span class="line">ts_sig = tf.sign(ts1)</span><br><span class="line"><span class="comment"># 取倒数</span></span><br><span class="line">ts_rec = tf.reciprocal(ts1)</span><br><span class="line"><span class="comment"># 向上取整</span></span><br><span class="line">ts_cei = tf.ceil(ts1)</span><br><span class="line"><span class="comment"># 向下取整</span></span><br><span class="line">ts_flo = tf.floor(ts1)</span><br><span class="line"><span class="comment"># 取最接近的整数</span></span><br><span class="line">ts_int = tf.rint(ts1)</span><br><span class="line"><span class="comment"># 取最大值</span></span><br><span class="line">ts_max = tf.maximum(ts1, ts2)</span><br><span class="line"><span class="comment"># 取最小值</span></span><br><span class="line">ts_min = tf.minimum(ts1, ts2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平方</span></span><br><span class="line">ts_squ = tf.square(ts1)</span><br><span class="line"><span class="comment"># 开根号</span></span><br><span class="line">ts_sqr = tf.sqrt(ts1)</span><br><span class="line"><span class="comment"># ts1^ts2,如果两个都是tensor就对应位置次幂</span></span><br><span class="line">ts_pow = tf.<span class="built_in">pow</span>(ts1, ts2)</span><br><span class="line"><span class="comment"># e^ts1</span></span><br><span class="line">ts_exp = tf.exp(ts1)</span><br><span class="line"><span class="comment"># log(ts1),e为底</span></span><br><span class="line">ts_log = tf.log(ts1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cos</span></span><br><span class="line">ts_cos = tf.cos(ts1)</span><br><span class="line"><span class="comment"># sin</span></span><br><span class="line">ts_sin = tf.sin(ts1)</span><br><span class="line"><span class="comment"># tan</span></span><br><span class="line">ts_tan = tf.tan(ts1)</span><br><span class="line"><span class="comment"># cos是已知角度求值，acos是已知值求角度</span></span><br><span class="line">ts_aco = tf.acos(ts1)</span><br><span class="line"><span class="comment"># asin</span></span><br><span class="line">ts_asi = tf.asin(ts1)</span><br><span class="line"><span class="comment"># atan</span></span><br><span class="line">ts_ata = tf.atan(ts1)</span><br></pre></td></tr></table></figure><h2 id="变量OP"><a href="#变量OP" class="headerlink" title="变量OP"></a>变量OP</h2><p><strong>tf.Variable(initial_value=None,trainable=True,collections=None,name=None)</strong></p><ul><li>initial_value:初始化的值</li><li>trainable：是否被训练</li><li>collections:新变量将添加到列出的图的集合中collections，默认为[GraphKeys.GLOBAL_VARIABLES],如果trainable是True变量也添加到图形集合GraphKeys.TRAINABLE_VARIABLES</li><li>特点：该变量可以存储到硬盘上；可以修改值，可以指定被训练</li><li>变量需要显式初始化，才能运行值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_demo</span>():</span></span><br><span class="line">    <span class="comment"># 定义变量</span></span><br><span class="line">    a = tf.Variable(initial_value=<span class="number">30</span>)</span><br><span class="line">    b = tf.Variable(initial_value=<span class="number">40</span>)</span><br><span class="line">    <span class="built_in">sum</span> = tf.add(a, b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化变量</span></span><br><span class="line">    init = tf.global_variavles_initializer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启会话</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="comment"># 变量初始化</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">        print(<span class="string">&quot;sum:\n&quot;</span>,sess.run(<span class="built_in">sum</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>使用tf.variable_scope()修改变量的命名空间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;name&quot;</span>):</span><br><span class="line">    var = tf.Variable(name=<span class="string">&quot;var&quot;</span>,initial_value=[<span class="number">4</span>],dtype=tf.float32)</span><br><span class="line">    var_value = tf.Variable(name=<span class="string">&quot;var&quot;</span>,initial_value=[<span class="number">4</span>],dtype=tf.float32)</span><br><span class="line">print(var)</span><br><span class="line">print(var_1)</span><br><span class="line"></span><br><span class="line">&lt;tf.Variable <span class="string">&#x27;name/var:0&#x27;</span> shape=() dtype=float32_ref&gt;</span><br><span class="line">&lt;tf.Variable <span class="string">&#x27;name/var_1:0&#x27;</span> shape=() dtype=float32_ref&gt;</span><br></pre></td></tr></table></figure><h2 id="模型保存于加载"><a href="#模型保存于加载" class="headerlink" title="模型保存于加载"></a>模型保存于加载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">saver.save(sess, <span class="string">&quot;./model/Lr.ckpt&quot;</span>)</span><br><span class="line"><span class="comment"># 判断模式是否存在</span></span><br><span class="line">checkpoint = tf.train.latest_checkpoint(<span class="string">&#x27;./model/&#x27;</span>)</span><br><span class="line"><span class="comment"># 加载模型,或者直接替换成路径</span></span><br><span class="line">saver.restore(sess, checkpoint)</span><br></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parameter &#x3D; model.get_layer(i).get_weights()# 获取该模型第i层的权重</span><br><span class="line">model.get_layer(i).set_weights(parameter)# 获取老模型参更新到新模型(当前层的权重个数一致时可以)</span><br></pre></td></tr></table></figure><h1 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tf.debugging.set_log_device_placement(True)   #打印信息的显示某个变量在哪个设备上设置为True</span><br><span class="line">tf.config.experimental.set_visible_devices(gpu_list[1], &quot;GPU&quot;)   # 设置哪些GPU设备部对当前进程可见的 </span><br><span class="line">gpu_list &#x3D; tf.config.experimental.list_logical_devices(&quot;GPU&quot;)   # 获取所有的逻辑设备</span><br><span class="line">log_gpu_list &#x3D; tf.config.experimental.list_physical_devices(&quot;GPU&quot;)  # 获取所有的物理设备</span><br><span class="line">tf.config.experimental.set_memory_growth(log_gpu_list[1],True)   # 设置该GPU内存为自增，就是用多少就占用多少内存</span><br><span class="line">tf.config.experimental.set_virtual_device_configuration(log_gpu_list[2], [tf.config.experimental.VirtualDeviceConfiguration(memory_limit&#x3D;1024)])  # 把一个物理设备分成多个 逻辑设备(这里分成了一个1024M的逻辑GPU)</span><br><span class="line">tf.config.set_soft_device_placement(True)    # 可以在保持正确性的前提下，自动把任务分到多个设备上</span><br><span class="line"></span><br><span class="line">os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] &#x3D; &quot;-1&quot;</span><br><span class="line">import os</span><br><span class="line">import tensorflow as tf</span><br><span class="line">gpu_list &#x3D; tf.config.experimental.list_physical_devices(&quot;GPU&quot;)</span><br><span class="line">for i in gpu_list:</span><br><span class="line">tf.config.experimental.set_memory_growth(i,True)</span><br></pre></td></tr></table></figure><h2 id="分布式策略"><a href="#分布式策略" class="headerlink" title="分布式策略"></a>分布式策略</h2><h3 id="MirroredStrategy"><a href="#MirroredStrategy" class="headerlink" title="MirroredStrategy"></a>MirroredStrategy</h3><ul><li>进行的是同步式分布式训练</li><li>适用于一机多卡的情况</li><li>数据并行：<ul><li>Batch数据切分成N份分发给每个GPU</li><li>然后聚合梯度后来更新每个GPU的参数</li></ul></li><li>缺点：更新一轮的速度取决于最慢的gpu</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strategy &#x3D; tf.distribute.MirroredStrategy()</span><br><span class="line"></span><br><span class="line">with strategy.scope():</span><br><span class="line">  # 定义模型</span><br><span class="line">  model &#x3D; keras.models.Sequential()</span><br><span class="line">  model.add(Conv2D(filters&#x3D;128,kernel_size&#x3D;3,padding&#x3D;&quot;same&quot;,activation&#x3D;&quot;relu&quot;,input_shape&#x3D;(100,)))</span><br><span class="line">  model.compile(loss&#x3D;&quot;sparse_categoriccal_crossentropy&quot;,optimizer&#x3D;&quot;sgd&quot;,metrics&#x3D;[&quot;accuracy&quot;])</span><br></pre></td></tr></table></figure><h3 id="CentralStorageStrategy"><a href="#CentralStorageStrategy" class="headerlink" title="CentralStorageStrategy"></a>CentralStorageStrategy</h3><ul><li>MirroredStrategy的一个变种</li><li>把模型参数只单独存储在一CPU上（如果只有一快GPU将存储在GPU上）</li><li>其他还是一样的</li></ul><h3 id="MultiworkerMirroredStrtrgy"><a href="#MultiworkerMirroredStrtrgy" class="headerlink" title="MultiworkerMirroredStrtrgy"></a>MultiworkerMirroredStrtrgy</h3><ul><li>类似于MirroredStrategy</li><li>适用于多机多卡的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TPUStrategy"><a href="#TPUStrategy" class="headerlink" title="TPUStrategy"></a>TPUStrategy</h3><ul><li>类似于MirroredStrategy</li><li>针对TPU的一种策略</li></ul><h3 id="ParameterServerStrategy"><a href="#ParameterServerStrategy" class="headerlink" title="ParameterServerStrategy"></a>ParameterServerStrategy</h3><ul><li>异步分布式</li><li>更加适用于大规模分布式系统</li><li>机器分为Parameter Server和worker两类<ul><li>Parameter Server：负责整合梯度更新参数，更新参数</li><li>worker：负责计算梯度，训练网络</li></ul></li></ul><p><img src="/blog/img/TensorFlow_3.png" alt="img"></p><h3 id="同步与异步的优劣"><a href="#同步与异步的优劣" class="headerlink" title="同步与异步的优劣"></a>同步与异步的优劣</h3><ul><li>多机多卡<ul><li>异步可以避免短板效应</li></ul></li><li>一机多卡<ul><li>同步可以避免过多的通信</li></ul></li><li>异步计算会增加模型的泛化能力<ul><li>异步不是严格正确的，所以模型更容忍错误</li></ul></li></ul><h2 id="ParameterServerStrategy-1"><a href="#ParameterServerStrategy-1" class="headerlink" title="ParameterServerStrategy"></a>ParameterServerStrategy</h2><h3 id="定义ps节点"><a href="#定义ps节点" class="headerlink" title="定义ps节点"></a>定义ps节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tf2.0需先配置cluster_resolver（即TF_CONFIG），否则报错</span><br><span class="line">import json</span><br><span class="line">os.environ[&quot;TF_CONFIG&quot;] &#x3D; json.dumps(&#123;</span><br><span class="line">    &quot;cluster&quot;: &#123;</span><br><span class="line">        &quot;chief&quot;:[&quot;127.0.0.1:5000&quot;],#调度节点</span><br><span class="line">        &quot;worker&quot;: [&quot;127.0.0.1:5001&quot;], #计算节点</span><br><span class="line">        &quot;ps&quot;: [&quot;127.0.0.1:5002&quot;]#参数服务器节点，可不必使用GPU</span><br><span class="line">    &#125;,</span><br><span class="line">   &quot;task&quot;: &#123;&quot;type&quot;: &quot;ps&quot;, &quot;index&quot;: 0&#125; #定义本进程为worker节点，即[&quot;127.0.0.1:5001&quot;]为计算节点</span><br><span class="line">&#125;)</span><br><span class="line">#定义ParameterServerStrategy策略即可</span><br><span class="line">strategy &#x3D; tf.distribute.experimental.ParameterServerStrategy()</span><br></pre></td></tr></table></figure><h3 id="定义调度节点"><a href="#定义调度节点" class="headerlink" title="定义调度节点"></a>定义调度节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tf2.0需先配置cluster_resolver（即TF_CONFIG），否则报错</span><br><span class="line">import json</span><br><span class="line">os.environ[&quot;TF_CONFIG&quot;] &#x3D; json.dumps(&#123;</span><br><span class="line">    &quot;cluster&quot;: &#123;</span><br><span class="line">        &quot;chief&quot;:[&quot;127.0.0.1:5000&quot;],#调度节点</span><br><span class="line">        &quot;worker&quot;: [&quot;127.0.0.1:5001&quot;], #计算节点</span><br><span class="line">        &quot;ps&quot;: [&quot;127.0.0.1:5002&quot;]#参数服务器节点，可不必使用GPU</span><br><span class="line">    &#125;,</span><br><span class="line">   &quot;task&quot;: &#123;&quot;type&quot;: &quot;chief&quot;, &quot;index&quot;: 0&#125; #定义本进程为worker节点，即[&quot;127.0.0.1:5001&quot;]为计算节点</span><br><span class="line">&#125;)</span><br><span class="line">#定义ParameterServerStrategy策略即可</span><br><span class="line">strategy &#x3D; tf.distribute.experimental.ParameterServerStrategy()</span><br></pre></td></tr></table></figure><h3 id="定义计算节点"><a href="#定义计算节点" class="headerlink" title="定义计算节点"></a>定义计算节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tf2.0需先配置cluster_resolver（即TF_CONFIG），否则报错</span><br><span class="line">import json</span><br><span class="line">os.environ[&quot;TF_CONFIG&quot;] &#x3D; json.dumps(&#123;</span><br><span class="line">    &quot;cluster&quot;: &#123;</span><br><span class="line">        &quot;chief&quot;:[&quot;127.0.0.1:5000&quot;],#调度节点</span><br><span class="line">        &quot;worker&quot;: [&quot;127.0.0.1:5001&quot;], #计算节点</span><br><span class="line">        &quot;ps&quot;: [&quot;127.0.0.1:5002&quot;]#参数服务器节点，可不必使用GPU</span><br><span class="line">    &#125;,</span><br><span class="line">   &quot;task&quot;: &#123;&quot;type&quot;: &quot;worker&quot;, &quot;index&quot;: 0&#125; #定义本进程为worker节点，即[&quot;127.0.0.1:5001&quot;]为计算节点</span><br><span class="line">&#125;)</span><br><span class="line">#定义ParameterServerStrategy策略即可</span><br><span class="line">strategy &#x3D; tf.distribute.experimental.ParameterServerStrategy()</span><br></pre></td></tr></table></figure><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LEARNING_RATE &#x3D; 1e-3</span><br><span class="line">BATCH_SIZE&#x3D;32</span><br><span class="line">def model_fn(features, labels, mode):</span><br><span class="line">  model &#x3D; tf.keras.Sequential([</span><br><span class="line">      tf.keras.layers.Conv2D(32, 3, activation&#x3D;&#39;relu&#39;, input_shape&#x3D;(28, 28, 1)),</span><br><span class="line">      tf.keras.layers.MaxPooling2D(),</span><br><span class="line">      tf.keras.layers.Flatten(),</span><br><span class="line">      tf.keras.layers.Dense(64, activation&#x3D;&#39;relu&#39;),</span><br><span class="line">      tf.keras.layers.Dense(10, activation&#x3D;&#39;softmax&#39;)</span><br><span class="line">  ])</span><br><span class="line">  logits &#x3D; model(features, training&#x3D;False)</span><br><span class="line"></span><br><span class="line">  if mode &#x3D;&#x3D; tf.estimator.ModeKeys.PREDICT:</span><br><span class="line">    predictions &#x3D; &#123;&#39;logits&#39;: logits&#125;</span><br><span class="line">    return tf.estimator.EstimatorSpec(labels&#x3D;labels, predictions&#x3D;predictions)</span><br><span class="line"></span><br><span class="line">  optimizer &#x3D; tf.compat.v1.train.GradientDescentOptimizer(</span><br><span class="line">      learning_rate&#x3D;LEARNING_RATE)</span><br><span class="line">  loss &#x3D; tf.keras.losses.SparseCategoricalCrossentropy(</span><br><span class="line">      from_logits&#x3D;True, reduction&#x3D;tf.keras.losses.Reduction.NONE)(labels, logits)</span><br><span class="line">  loss &#x3D; tf.reduce_sum(loss) * (1. &#x2F; BATCH_SIZE)</span><br><span class="line">  if mode &#x3D;&#x3D; tf.estimator.ModeKeys.EVAL:</span><br><span class="line">    return tf.estimator.EstimatorSpec(mode, loss&#x3D;loss)</span><br><span class="line"></span><br><span class="line">  return tf.estimator.EstimatorSpec(</span><br><span class="line">      mode&#x3D;mode,</span><br><span class="line">      loss&#x3D;loss,</span><br><span class="line">      train_op&#x3D;optimizer.minimize(</span><br><span class="line">          loss, tf.compat.v1.train.get_or_create_global_step()))</span><br></pre></td></tr></table></figure><h3 id="定义步数"><a href="#定义步数" class="headerlink" title="定义步数"></a>定义步数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#定义多少步保存模型，多少步打印日志信息等，注意，分布式训练关键在于-train_distribute&#x3D;strategy</span><br><span class="line">run_config &#x3D; tf.estimator.RunConfig(keep_checkpoint_max&#x3D;1,</span><br><span class="line">               log_step_count_steps&#x3D;10,train_distribute&#x3D;strategy)</span><br><span class="line">#输入model_fn，模型保存路径</span><br><span class="line">classifier &#x3D; tf.estimator.Estimator(model_fn&#x3D;model_fn,model_dir&#x3D;&quot;.&#x2F;model&quot;,config&#x3D;run_config)</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tf.estimator.train_and_evaluate(</span><br><span class="line">    classifier,</span><br><span class="line">    train_spec&#x3D;tf.estimator.TrainSpec(input_fn&#x3D;lambda :input_fn(train_images,train_labels,tf.estimator.ModeKeys.TRAIN, 256),max_steps&#x3D;30000),</span><br><span class="line">    eval_spec&#x3D;tf.estimator.EvalSpec(input_fn&#x3D;lambda :input_fn(test_images,test_labels,tf.estimator.ModeKeys.TRAIN, 256),steps&#x3D;300)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim</title>
      <link href="/blog/2019/08/12/Vim/"/>
      <url>/blog/2019/08/12/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p><img src="/blog/img/Vim_1.gif"></p><h3 id="vim有3种常用模式：一般模式、编辑模式、命令模式。"><a href="#vim有3种常用模式：一般模式、编辑模式、命令模式。" class="headerlink" title="vim有3种常用模式：一般模式、编辑模式、命令模式。"></a>vim有3种常用模式：一般模式、编辑模式、命令模式。</h3><ul><li>一般模式<ul><li>上下左右:kjhl  也可以使用方向键</li><li>n+上下左右:n为数字，向上下左右移动n个字符</li><li>[ctrl]+f:屏幕向下滚动一页，同page down</li><li>[ctrl]+b:屏幕向上滚动一页，同page up</li><li>0或home:光标移动到行首</li><li>$或end:光标移动到行尾</li><li>g:光标移动到最后一行</li><li>ng:光标移动到第n行</li><li>gg:同1g，光标移动到第一行行首</li><li>/word:向下查找关键词，使用n或N向上或向下查找关键词</li><li>?word:向上查找关键词word，使用n或N向上或向下查找关键词</li><li>:n1,n2s/word1/word2/g   :   s/1/2/g 表示将1替换成2，所以前面的意思是在n1到n2之间，将word1替换为word2.例如：51,100s/aaa/bbb/g</li><li>:1,$s/word1/word2/g  :  全文查找替换将word1替换为word2</li><li>x:向后删除</li><li>X:向前删除</li><li>nx:向后删除n个字符</li><li>dd:删除当前行　</li><li>ndd:向下删除n行</li><li>d1G:删除当前位置到第一行</li><li>d$:删除当前位置到最后一行</li><li>d0:删除当前位置到改行第一个字符的所有数据</li><li>yy:复制光标所在的这一行</li><li>nyy:向下复制n行</li><li>p:在光标所在行的下面粘贴复制的数据</li><li>P:在光标所在行的上面粘贴复制的数据</li><li>u:恢复前一个操作</li><li>[ctrl]+u:重做上一个操作</li></ul></li><li>一般模式切换到编辑模式<ul><li>i:进入插入模式，在光标前插入   I是在第一个非空格符处插入</li><li>a:进入插入模式，在光标下一个字符插入  A是在所在行最后一个字符插入</li><li>o:进入插入模式，在下面一行插入    O是在上面一行出入</li><li>r:进入替换模式，类似于insert键</li></ul></li><li>编辑模式到一般模式<ul><li>Esc：退出编辑模式进入命令模式</li></ul></li><li>命令模式<ul><li>:w  保存</li><li>:w! 强制保存</li><li>:q  退出</li><li>:q! 强制退出</li><li>:wq :x 保存并退出</li><li>ZZ 保存并退出</li><li>:set number 显示行号</li><li>:set nonu 取消显示行号</li></ul></li></ul><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word2Vec</title>
      <link href="/blog/2019/08/12/Word2Vec/"/>
      <url>/blog/2019/08/12/Word2Vec/</url>
      
        <content type="html"><![CDATA[<h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于图像和音频处理采用的使庞大的高纬度数据集，对于图像数据来说，此类数据集会编码为单个像素强度向量。不过，自然语言处理系统一直将字词视为离散的原子符号，将字词表示为唯一离散id还会导致数据稀疏性，并且通常意味着我们可能需要更多数据才能成功训练统计模型，使用向量法可以扫除其中一些障碍。</p><h3 id="统计语言模型"><a href="#统计语言模型" class="headerlink" title="统计语言模型"></a>统计语言模型</h3><ul><li>统计语言模型：统计语言模型把语言(词的序列)看作一个随机事件，并赋予相应的概率来描述其属于某种语言集合可能性</li><li>N-Gram：N元模型就是假设当前词的出现频率只与它前面的N-1个词有关<ul><li>语言使一种序列，词与词之间并不是相互独立</li><li>1元模型：当前词出现在这的概率=这个词在词语库在出现的概率使一样的</li><li>二元模型：当前词出现的概率=这个词前面一个词出现的情况下这个词出现的概率</li><li>三元模型：：当前这个词出现的概率=这个词前面两个出现的情况下当前词出现的概率</li><li>一般情况下使用三元模型，由于语料库的限制，使用过大的N，会导致计算量增加，对语料库的要求也会越大</li></ul></li></ul><p><img src="/blog/img/Word2Vec_1.jpg"></p><h1 id="神经网络语言模型NNLM"><a href="#神经网络语言模型NNLM" class="headerlink" title="神经网络语言模型NNLM"></a>神经网络语言模型NNLM</h1><ul><li><strong>神经网络语言模型NNLM</strong>依然属于概率语言模型，它通过神经网络来计算概率语言模型中每个参数。</li></ul><p><img src="/blog/img/Word2Vec_2.png"></p><ul><li>模型解释<ul><li>输入层：将context(w)每个词映射成一个长度为m的词向量，向量开始时随机的，也参与网络训练</li><li>投影层：将所有的上下文的向量拼接成一个长向量，作为目标w的特征向量，向量为[1，(词个数-1)*词向量长度]</li><li>隐藏层：拼接后的向量会经过一个规模为h的隐藏层，向量为[(词个数-1)*词向量长度，语料库词个数]</li><li>输出层：最后经过softmax输出所有词出现的概率</li></ul></li><li>训练过程：<ul><li>训练时，使用交叉熵作为损失，反向传播算法进行训练</li><li>当完成训练时，得到一个N-Gram神经网络语言模型，以及副产品<strong>词向量</strong></li></ul></li></ul><h1 id="Word2Vec-1"><a href="#Word2Vec-1" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><ul><li><strong>word2vec</strong>本质上也是一个神经语言模型，但是它的目标并不是语言模型本身，而是<strong>词向量</strong>；因此，其所作的一系列优化，都是为了更快更好的得到词向量</li><li><strong>Word2Vec</strong>提供了两套模型：<strong>CBOW</strong>和<strong>Skip-Gram</strong>，其基本思想：<ul><li><strong>CBOW</strong>:在已知countext(w)的情况下，预测w</li><li><strong>Skip-Gram</strong>:在已知w的情况下预测countext(w)</li></ul></li></ul><p><img src="/blog/img/Word2Vec_3.png"></p><ul><li><p>CBOW向前计算与向量更新推导</p><ul><li>CBOW与2003年Bengio的结构由些不同，不同点在于CBOW去掉了最耗时的非线性隐藏层、并且所有词共享隐层。下图不包含softmax与负采样优化过程</li></ul><p><img src="/blog/img/Word2Vec.png"></p><ul><li>向前计算：<ul><li>输入层到隐藏层：输入上下问词向量的平均值与W权重计算，[1,V]*[V,N]=[1,N]得到中间向量h</li><li>隐藏层到输出层：h向量乘上隐藏层的矩阵，[1,N]*[N,总词语数]</li><li>输出层接softmax：计算每个词出现的概率</li></ul></li></ul></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="Spark使用"><a href="#Spark使用" class="headerlink" title="Spark使用"></a>Spark使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.feature import Word2Vec, Word2VecModel</span><br><span class="line">word2vec &#x3D; Work2Vce(vectorSize&#x3D;词向量长度，minCount&#x3D;过滤掉出现小于次数的词默认5次，windowSize&#x3D;训练时窗口大小，inputCol&#x3D;输入列名，outputCol&#x3D;输出列名)</span><br><span class="line"># 训练模型</span><br><span class="line">model&#x3D;word2vec.fit(带有输入列名的df)</span><br><span class="line">model.save(&quot;路径&quot;)</span><br><span class="line">model&#x3D;Word2VecModel.load(&quot;路径&quot;)</span><br><span class="line"># 取出词向量</span><br><span class="line">vectors &#x3D; model.getVectors()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN</title>
      <link href="/blog/2019/08/12/YARN/"/>
      <url>/blog/2019/08/12/YARN/</url>
      
        <content type="html"><![CDATA[<h1 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h1><h2 id="什么是YARN"><a href="#什么是YARN" class="headerlink" title="什么是YARN"></a>什么是YARN</h2><ul><li>Yet Another Resource Negotiator,另一种资源调度器</li><li>通用资源管理系统</li><li>为上层应用提供统一的资源管理和调度，为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处</li></ul><h2 id="YARN产生背景"><a href="#YARN产生背景" class="headerlink" title="YARN产生背景"></a>YARN产生背景</h2><ul><li>通用资源管理系统<ul><li>Hadoop数据分布式存储（数据分块，冗余存储）</li><li>当多个MapReduce任务要用到相同的hdfs数据，需要进行资源调度管理</li><li>Hadoop1.x时并没有YARN，MapReduce既负责进行计算左右又要处理服务器集群资源调度管理</li></ul></li><li>服务器集群资源调度管理和MapReduce执行过程耦合在一起带来的问题<ul><li>Hadoop早期，技术只有Hadoop，这个问题不明显</li><li>随着大数据技术的发展，Spark、Storm····计算框架都要用到服务器集群资源</li><li>如果没有通用资源管理系统，只能为多个集群分别提供数据</li></ul></li><li>不同计算框架可以共享同一个HDFS集群上的数据，享受整体资源调度</li></ul><p><img src="/blog/img/YARN_1.png" alt="YARN_1"></p><h1 id="YARN的架构和执行流程"><a href="#YARN的架构和执行流程" class="headerlink" title="YARN的架构和执行流程"></a>YARN的架构和执行流程</h1><h3 id="ResourceManager（RM）"><a href="#ResourceManager（RM）" class="headerlink" title="ResourceManager（RM）"></a>ResourceManager（RM）</h3><ul><li>RM资源管理器；</li><li>整个集群同时提供服务的RM只有一个，负责集群资源的统一管理和调度；</li><li>处理客户端的请求；</li><li>监控NM，一旦某个NM挂了，那么改NM上运行的任务需要我们来告诉AM来如何进行处理</li></ul><h3 id="NodeManager-NM"><a href="#NodeManager-NM" class="headerlink" title="NodeManager(NM)"></a>NodeManager(NM)</h3><ul><li>NM节点管理器</li><li>整个集群中有多个，负责自己节点资源管理和使用</li><li>定时向RM汇报本节点的资源使用情况</li><li>接收并处理来自RM的命令：启动Container</li><li>处理来自AM的命令</li></ul><h3 id="ApplicationMaster-AM"><a href="#ApplicationMaster-AM" class="headerlink" title="ApplicationMaster(AM)"></a>ApplicationMaster(AM)</h3><ul><li>每一个应用程序对应一个：MR，Spark</li><li>负责应用程序的管理</li><li>为应用程序向RM申请资源(core、memory)，分配给内部的task</li><li>需要与NM通讯：启动/停止task</li><li>Task和AM都是运行在Container中的</li></ul><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul><li>容器：封装了CPU、Memory等资源的一个容器，是一个任务运行环境的抽象</li></ul><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul><li>提交作业</li><li>查询作业进度</li><li>杀死作业</li></ul><p><img src="/blog/img/YARN_2.png" alt="YARN_1"></p><ol><li>Client提交作业请求</li><li>RedourceManager进程和NodeManager进程通信，根据集群资源，为用户程序分配第一个Container(容器)，并将ApplicationManager分发到这个容器上面</li><li>启动Container中的ApplicationMaster</li><li>ApplicationMaster启动后向ResourceManager注册进程，申请资源</li><li>ApplicationMaster申请到资源后，向对应的NodeManager申请启动Container，将要执行的程序分发到NodeManager上</li><li>Container启动后执行对应的任务</li><li>Task执行完毕之后，向ApplicationMaster返回结果</li><li>ApplicationMaster向ResourceManager请求kill</li></ol><h1 id="YARN环境搭建"><a href="#YARN环境搭建" class="headerlink" title="YARN环境搭建"></a>YARN环境搭建</h1><ul><li>mapred-site.xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><ul><li>yarn-site.xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><ul><li>启动YARN相关进程sbin/start-yarn.sh</li><li><a href="http://ip:8088验证">http://ip:8088验证</a></li><li>停止YARN相关进程sbin/stop-yarn.sh</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdfs连接</title>
      <link href="/blog/2019/08/12/hdfs%E8%BF%9E%E6%8E%A5/"/>
      <url>/blog/2019/08/12/hdfs%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="连接HDFS之pyarrow"><a href="#连接HDFS之pyarrow" class="headerlink" title="连接HDFS之pyarrow"></a>连接HDFS之pyarrow</h1><ul><li>可以基于java连接：得安装java环境，和hadoop命令</li><li>基于c的：安装libhdfs包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import pyarrow</span><br><span class="line">from krbcontext import krbContext #做认证使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HdfsConnect(object):</span><br><span class="line">    def __init__(self, info, keytab_info, path):</span><br><span class="line">        print(keytab_info[&quot;ip&quot;], keytab_info[&quot;hdfs_port&quot;])</span><br><span class="line">        self.client &#x3D; pyarrow.hdfs.connect(host&#x3D;keytab_info[&quot;ip&quot;], port&#x3D;keytab_info[&quot;hdfs_port&quot;],</span><br><span class="line">                                           kerb_ticket&#x3D;&quot;.&#x2F;tmp&#x2F;cache&quot;)</span><br><span class="line">        self.data_info &#x3D; info</span><br><span class="line">        self.path &#x3D; path</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _parquet_to_csv(file_name):</span><br><span class="line">        try:</span><br><span class="line">            if file_name.endswith(&quot;.parquet&quot;):</span><br><span class="line">                result &#x3D; pd.read_parquet(file_name)</span><br><span class="line">                result.to_csv(file_name.replace(&quot;.parquet&quot;, &quot;.csv&quot;), index&#x3D;False)</span><br><span class="line">        except:</span><br><span class="line">            print(file_name)</span><br><span class="line"></span><br><span class="line">    def file_to_list(self, local_path&#x3D;None, hdfs_path&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;把目录或变成目录列表&quot;&quot;&quot;</span><br><span class="line">        path_list &#x3D; []</span><br><span class="line">        if local_path !&#x3D; None:</span><br><span class="line"></span><br><span class="line">            if os.path.isdir(local_path):</span><br><span class="line">                for i in os.listdir(local_path):</span><br><span class="line">                    _path &#x3D; local_path + &#39;&#x2F;&#39; + i</span><br><span class="line">                    path_list.extend(self.file_to_list(local_path&#x3D;_path))</span><br><span class="line">            else:</span><br><span class="line">                path_list.append(local_path)</span><br><span class="line"></span><br><span class="line">        if hdfs_path !&#x3D; None:</span><br><span class="line">            if self.client.isdir(hdfs_path):</span><br><span class="line">                for i in self.client.ls(hdfs_path):</span><br><span class="line">                    path_list.extend(self.file_to_list(hdfs_path&#x3D;i))</span><br><span class="line">            else:</span><br><span class="line">                path_list.append(hdfs_path)</span><br><span class="line">        return path_list</span><br><span class="line"></span><br><span class="line">    def _download_data(self):</span><br><span class="line">        &quot;&quot;&quot;下载文件或者文件夹&quot;&quot;&quot;</span><br><span class="line">        list_path &#x3D; self.file_to_list(hdfs_path&#x3D;self.data_info[&#39;path&#39;])</span><br><span class="line">        if list_path &#x3D;&#x3D; []:</span><br><span class="line">            return</span><br><span class="line">        _path &#x3D; &#39;&#39;</span><br><span class="line">        for _path in list_path:</span><br><span class="line">            local_path &#x3D; self.path + _path[len(&quot;&#x2F;&quot;.join(self.data_info[&#39;path&#39;].split(&#39;&#x2F;&#39;)[:-1])):]</span><br><span class="line">            local_path_dir &#x3D; &quot;&#x2F;&quot;.join(local_path.split(&#39;&#x2F;&#39;)[:-1])</span><br><span class="line">            if not os.path.exists(local_path_dir):</span><br><span class="line">                os.makedirs(local_path_dir)</span><br><span class="line">            logger.info(&#39;拉取HDFS%s文件到本地：%s&#39; % (_path, local_path))</span><br><span class="line">            with open(local_path, &#39;wb&#39;) as f:</span><br><span class="line">                self.client.download(_path, f)</span><br><span class="line"></span><br><span class="line">        reverse_path &#x3D; self.path + &quot;&#x2F;&quot; + _path.split(&#39;&#x2F;&#39;)[len(self.data_info[&#39;path&#39;].split(&#39;&#x2F;&#39;)) - 1]</span><br><span class="line">        return reverse_path</span><br><span class="line"></span><br><span class="line">    def _put_data(self):</span><br><span class="line">        &quot;&quot;&quot;上传文件或者文件夹&quot;&quot;&quot;</span><br><span class="line">        list_path &#x3D; self.file_to_list(local_path&#x3D;self.path)</span><br><span class="line">        for _path in list_path:</span><br><span class="line">            hdfs_path &#x3D; self.data_info[&#39;path&#39;] + _path[len(&quot;&#x2F;&quot;.join(self.path.split(&#39;&#x2F;&#39;)[:-1])):]</span><br><span class="line">            logger.info(&#39;上传%s文件，到HDFS：%s&#39; % (_path, hdfs_path))</span><br><span class="line">            with open(_path, &#39;rb&#39;) as f:</span><br><span class="line">                self.client.upload(hdfs_path, f)</span><br><span class="line"></span><br><span class="line">    def download(self, key_name, key_value):</span><br><span class="line">        result_file &#x3D; self._download_data()</span><br><span class="line">        try:</span><br><span class="line">            file_list &#x3D; [self.path + i for i in os.listdir(result_file)]</span><br><span class="line">            for file_name in file_list:</span><br><span class="line">                self._parquet_to_csv(file_name)</span><br><span class="line">        except:</span><br><span class="line">            print(result_file)</span><br><span class="line">        return result_file</span><br><span class="line"></span><br><span class="line">    def upload(self):</span><br><span class="line">        self._put_data()</span><br><span class="line">        </span><br><span class="line">with krbContext(using_keytab&#x3D;True, keytab_file&#x3D;self.keytab_info[&#39;keytab_file&#39;],principal&#x3D;self.keytab_info[&#39;principal&#39;], ccache_file&#x3D;&#39;.&#x2F;tmp&#x2F;cache&#39;):</span><br><span class="line">    HdfsConnect(info, keytab_info, path)</span><br></pre></td></tr></table></figure><h1 id="连接HDFS之HDFS3"><a href="#连接HDFS之HDFS3" class="headerlink" title="连接HDFS之HDFS3"></a>连接HDFS之HDFS3</h1><h3 id="安装libhdfs3"><a href="#安装libhdfs3" class="headerlink" title="安装libhdfs3"></a>安装libhdfs3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dl.bintray.com&#x2F;wangzw&#x2F;deb # 下载这里面的两个文件</span><br><span class="line">dpkg -i # 安装文件</span><br><span class="line">apt-get upgrade # 安装完成之后，输入这命令查看缺包详情，然后根据缺少的下载http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F;ls-lR.gz文件，搜索相关包下载</span><br><span class="line">apt --fix-broken install -y</span><br><span class="line"># 安装完成</span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from hdfs3 import HDFileSystem</span><br><span class="line"># 多节点链接</span><br><span class="line">host &#x3D; &quot;nameservice1&quot;</span><br><span class="line"># https:&#x2F;&#x2F;hadoop.apache.org&#x2F;docs&#x2F;r2.6.0&#x2F;hadoop-project-dist&#x2F;hadoop-hdfs&#x2F;hdfs-default.xml 可以根据这个配置</span><br><span class="line">conf &#x3D; &#123;&quot;dfs.nameservices&quot;: &quot;nameservice1&quot;,</span><br><span class="line">        &quot;dfs.ha.namenodes.nameservice1&quot;: &quot;namenode113,namenode188&quot;,</span><br><span class="line">        &quot;dfs.namenode.rpc-address.nameservice1.namenode113&quot;: &quot;hostname_of_server1:8020&quot;,</span><br><span class="line">        &quot;dfs.namenode.rpc-address.nameservice1.namenode188&quot;: &quot;hostname_of_server2:8020&quot;,</span><br><span class="line">        &quot;dfs.namenode.http-address.nameservice1.namenode188&quot;: &quot;hostname_of_server1:50070&quot;,</span><br><span class="line">        &quot;dfs.namenode.http-address.nameservice1.namenode188&quot;: &quot;hostname_of_server2:50070&quot;,</span><br><span class="line">        &quot;hadoop.security.authentication&quot;: &quot;kerberos&quot;</span><br><span class="line">&#125;</span><br><span class="line">hdfs &#x3D; HDFileSystem(host&#x3D;host, pars&#x3D;conf)</span><br><span class="line"></span><br><span class="line"># 常用API</span><br><span class="line">hdfs &#x3D; HDFileSystem(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;8020)</span><br><span class="line">hdfs.cancel_token(token&#x3D;None) </span><br><span class="line">hdfs.cat(path) #获取指定目录或文件的内容</span><br><span class="line">hdfs.chmod(path, mode) #修改制定目录的操作权限</span><br><span class="line">hdfs.chown(path, owner, group) #修改目录所有者，以及用户组</span><br><span class="line">hdfs.concat(destination, paths) #将指定多个路径paths的文件，合并成一个文件写入到destination的路径，并删除源文件（The source files are deleted on successful completion.成功完成后将删除源文件。）</span><br><span class="line">hdfs.connect() #连接到名称节点 这在启动时自动发生。   LZ:未知作用，按字面意思，应该是第一步HDFileSystem(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;8020)发生的</span><br><span class="line">hdfs.delegate_token(user&#x3D;None)</span><br><span class="line">hdfs.df() #HDFS系统上使用&#x2F;空闲的磁盘空间</span><br><span class="line">hdfs.disconnect() #跟connect()相反，断开连接</span><br><span class="line">hdfs.du(path, total&#x3D;False, deep&#x3D;False) #查看指定目录的文件大小，total是否把大小加起来一个总数，deep是否递归到子目录</span><br><span class="line">hdfs.exists(path) #路径是否存在</span><br><span class="line">hdfs.get(hdfs_path, local_path, blocksize&#x3D;65536)  #将HDFS文件复制到本地,blocksize设置一次读取的大小</span><br><span class="line">hdfs.get_block_locations(path, start&#x3D;0, length&#x3D;0) #获取块的物理位置</span><br><span class="line">hdfs.getmerge(path, filename, blocksize&#x3D;65536) #获取制定目录下的所有文件，复制合并到本地文件</span><br><span class="line">hdfs.glob(path) #&#x2F;user&#x2F;spark&#x2F;abc-*.txt 获取与这个路径相匹配的路径列表</span><br><span class="line">hdfs.head(path, size&#x3D;1024) #获取指定路径下的文件头部分的数据</span><br><span class="line">hdfs.info(path) #获取指定路径文件的信息</span><br><span class="line">hdfs.isdir(path) #判断指定路径是否是一个文件夹</span><br><span class="line">hdfs.isfile(path) #判断指定路径是否是一个文件</span><br><span class="line">hdfs.list_encryption_zones() #获取所有加密区域的列表</span><br><span class="line">hdfs.ls(path, detail&#x3D;False) #返回指定路径下的文件路径，detail文件详细信息</span><br><span class="line">hdfs.makedirs(path, mode&#x3D;457) #创建文件目录类似 mkdir -p</span><br><span class="line">hdfs.mkdir(path) #创建文件目录</span><br><span class="line">hdfs.mv(path1, path2) #将path1移动到path2</span><br><span class="line">open(path, mode&#x3D;&#39;rb&#39;, replication&#x3D;0, buff&#x3D;0, block_size&#x3D;0) #读取文件，类似于python的文件读取</span><br><span class="line">hdfs.put(filename, path, chunk&#x3D;65536, replication&#x3D;0, block_size&#x3D;0) #将本地的文件上传到，HDFS指定目录</span><br><span class="line">hdfs.read_block(fn, offset, length, delimiter&#x3D;None) #指定路径文件的offset指定读取字节的起始点，length读取长度，delimiter确保读取在分隔符bytestring上开始和停止</span><br><span class="line">&gt;&gt;&gt; hdfs.read_block(&#39;&#x2F;data&#x2F;file.csv&#39;, 0, 13)  </span><br><span class="line">b&#39;Alice, 100\nBo&#39;</span><br><span class="line">&gt;&gt;&gt; hdfs.read_block(&#39;&#x2F;data&#x2F;file.csv&#39;, 0, 13, delimiter&#x3D;b&#39;\n&#39;)  </span><br><span class="line">b&#39;Alice, 100\nBob, 200&#39;</span><br><span class="line">hdfs.rm(path, recursive&#x3D;True) #删除指定路径recursive是否递归删除</span><br><span class="line">hdfs.tail(path, size&#x3D;1024) #获取 文件最后一部分的数据</span><br><span class="line">hdfs.touch(path) #创建一个空文件</span><br><span class="line">hdfs.walk(path) #遍历文件树</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive连接</title>
      <link href="/blog/2019/08/12/hive%E8%BF%9E%E6%8E%A5/"/>
      <url>/blog/2019/08/12/hive%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="连接Hive之impala"><a href="#连接Hive之impala" class="headerlink" title="连接Hive之impala"></a>连接Hive之impala</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">from impala.dbapi import connect</span><br><span class="line">from impala.util import as_pandas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HiveConnect(object):</span><br><span class="line">    def __init__(self, data_info, keytab_info, local_tmp):</span><br><span class="line">        self.client &#x3D; connect(database&#x3D;data_info[&#39;databases&#39;], host&#x3D;keytab_info[&#39;host&#39;], port&#x3D;keytab_info[&#39;hive_port&#39;],</span><br><span class="line">                            auth_mechanism&#x3D;&#39;GSSAPI&#39;, kerberos_service_name&#x3D;&#39;hive&#39;)</span><br><span class="line">        self.database &#x3D; data_info.get(&#39;databases&#39;)</span><br><span class="line">        self.table &#x3D; data_info.get(&#39;table&#39;)</span><br><span class="line">        self.date_col &#x3D; data_info.get(&#39;date_col&#39;)</span><br><span class="line">        self.start_date &#x3D; data_info.get(&#39;start_date&#39;)</span><br><span class="line">        self.end_date &#x3D; data_info.get(&#39;end_date&#39;)</span><br><span class="line">        self.local_tmp &#x3D; local_tmp</span><br><span class="line"></span><br><span class="line">    def get_all_key(self, key_str):</span><br><span class="line">        &quot;&quot;&quot;获取增量更新的所有数据的所有key&quot;&quot;&quot;</span><br><span class="line">        if self.date_col is not None and self.start_date is not None and self.end_date is not None:</span><br><span class="line">            sql_str &#x3D; &quot;select &#123;key_str&#125; from &#123;table&#125; where &#123;col&#125;&gt;&#x3D;&#123;start_date&#125; and &#123;col&#125;&lt;&#x3D;&#123;end_date&#125; group by &#123;key_str&#125;&quot;.format(</span><br><span class="line">                table&#x3D;self.table, col&#x3D;self.date_col, start_date&#x3D;self.start_date, end_date&#x3D;self.end_date, key_str&#x3D;key_str)</span><br><span class="line">        else:</span><br><span class="line">            sql_str &#x3D; &quot;select &#123;key_str&#125; from &#123;table&#125; group by &#123;key_str&#125;&quot;.format(</span><br><span class="line">                table&#x3D;self.table, key_str&#x3D;key_str)</span><br><span class="line">        logger.info(&quot;get_all_keySQL:&quot;+sql_str)</span><br><span class="line">        cursor &#x3D; self.client.cursor()</span><br><span class="line">        cursor.execute(sql_str)</span><br><span class="line">        key_df &#x3D; as_pandas(cursor)</span><br><span class="line">        return key_df</span><br><span class="line"></span><br><span class="line">    def download(self, key_name, key_values):</span><br><span class="line">        where &#x3D; &quot;&quot;</span><br><span class="line">        logger.info(&quot;date_column: &quot; + str(self.date_col))</span><br><span class="line">        logger.info(&quot;start_date: &quot; + str(self.start_date))</span><br><span class="line">        logger.info(&quot;end_date: &quot; + str(self.end_date))</span><br><span class="line">        if self.date_col is not None and self.start_date is not None and self.end_date is not None:</span><br><span class="line">            logger.info(&quot;###where 条件触发###&quot;)</span><br><span class="line">            where +&#x3D; &quot; where %s &gt;&#x3D; &#39;%s&#39; and %s &lt;&#x3D; &#39;%s&#39;&quot; % (self.date_col, self.start_date, self.date_col, self.end_date)</span><br><span class="line">        result_file &#x3D; self.local_tmp + &quot;&#x2F;%s.%s.csv&quot; % (self.database, self.table)</span><br><span class="line">        if key_name !&#x3D; None and key_values !&#x3D; None:</span><br><span class="line">            where_id &#x3D; &quot;&quot;</span><br><span class="line">            # for key_value_list in key_value:</span><br><span class="line">            #     index &#x3D; &quot;(&quot; + &quot; and &quot;.join([&quot;&#123;&#125;&#x3D;&#39;&#123;&#125;&#39;&quot;.format(key_name[i], key_value_list[i]) for i in range(len(key_name))]) + &quot;)&quot;</span><br><span class="line">            #     where_id +&#x3D; index +&quot; or &quot;</span><br><span class="line">            # where_id &#x3D; where_id[:-3]</span><br><span class="line">            list(map(list, zip(*key_values)))</span><br><span class="line">            for key, value in zip(key_name, list(map(list, zip(*key_values)))):</span><br><span class="line">                index &#x3D; &quot;&#123;&#125; in (&#39;&#123;&#125;&#39;)&quot;.format(key, &quot;&#39;, &#39;&quot;.join(list(set(value))))</span><br><span class="line">                where_id +&#x3D; index + &quot; and &quot;</span><br><span class="line">            where_id &#x3D; where_id[:-5]</span><br><span class="line">            if where!&#x3D;&quot;&quot;:</span><br><span class="line">                where +&#x3D; &quot; and &quot; + where_id</span><br><span class="line">            else:</span><br><span class="line">                where &#x3D; &quot;where &quot; + where_id</span><br><span class="line">        sql_str &#x3D; &quot;select * from &quot; + self.table + &quot; &quot; + where</span><br><span class="line">        logger.info(sql_str)</span><br><span class="line">        cursor &#x3D; self.client.cursor()</span><br><span class="line">        cursor.execute(sql_str)</span><br><span class="line">        data &#x3D; as_pandas(cursor)</span><br><span class="line">        data.columns &#x3D; [i.split(&#39;.&#39;)[-1] for i in data.columns]</span><br><span class="line">        data.to_csv(result_file, index&#x3D;False)</span><br><span class="line">        return result_file</span><br><span class="line">      </span><br><span class="line">with krbContext(using_keytab&#x3D;True, keytab_file&#x3D;self.keytab_info[&#39;keytab_file&#39;],principal&#x3D;self.keytab_info[&#39;principal&#39;], ccache_file&#x3D;&#39;.&#x2F;tmp&#x2F;cache&#39;):</span><br><span class="line">    HiveConnect(info, keytab_info, path)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas</title>
      <link href="/blog/2019/08/12/pandas/"/>
      <url>/blog/2019/08/12/pandas/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><h3 id="Pandas简介"><a href="#Pandas简介" class="headerlink" title="Pandas简介"></a>Pandas简介</h3><ul><li>专门用于数据挖掘的开源python库</li><li>以Numpy为基础，借力Numpy模块在计算方面性能高的优势</li><li>基于matplotlib，能够简便的画图</li><li>独特的数据结构</li><li>相比于Numpy优势：<ul><li>pandas的数据展示结果可读性更好</li><li>处理数据更加方便</li><li>读取文件更加方便</li></ul></li></ul><h3 id="Pandas数据结构"><a href="#Pandas数据结构" class="headerlink" title="Pandas数据结构"></a>Pandas数据结构</h3><ul><li><p>Series结构(一维数组的数据结构)：</p><ul><li>Series是一个类似于一维数组的数据结构，它能够保存任何类型的数据，如整数、字符床、浮点数等，主要由一组数据和与之相关的索引两部分构成</li><li>Series创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">pd.Series(data&#x3D;data, index&#x3D;index, dtype&#x3D;dtype)</span><br><span class="line"># 参数：data：可以是array，list；index：索引，和data长度一致，不传默认生成0-n的整数索引；dtype：数据的类型</span><br><span class="line">pd1 &#x3D; pd.Series(np.arange(10))</span><br><span class="line"># 也可通过字典创建</span><br><span class="line">pd1 &#x3D; pd.Series(&#123;&quot;a&quot;:&quot;b&quot;&#125;)</span><br></pre></td></tr></table></figure><ul><li>Series属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 获取索引</span><br><span class="line">pd1.index</span><br><span class="line"># 获取值</span><br><span class="line">pd1.values</span><br><span class="line"># 也可通过下标获取值</span><br><span class="line">pd1[0]</span><br></pre></td></tr></table></figure></li><li><p>Dataframe结构(二维数组的数据结构)：</p><ul><li>DataFrame是一个类似于二维数组或表格的对象，既有行索引又有列索引</li><li>DataFrame创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(data&#x3D;data, index&#x3D;index, columns&#x3D;columns)</span><br><span class="line"># 参数：data：可以是array，list；index：行索引，和data长度一致，不传默认生成0-n的整数索引；columns：列索引，和data长度一致，不传默认生成0-n的整数索引；</span><br><span class="line">index &#x3D; [&quot;行1&quot;,&quot;行2&quot;]</span><br><span class="line">columns &#x3D; [&quot;列1&quot;,&quot;列2&quot;,&quot;列3&quot;]</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.random.randn(2,3)，index&#x3D;index,columns&#x3D;columns)</span><br></pre></td></tr></table></figure><ul><li>DataFrame属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df1.shape # 获取DataFrame形状</span><br><span class="line">df1.index # 获取DataFrame行索引</span><br><span class="line">df1.columns # 获取DataFrame列索引</span><br><span class="line">df1.values  # 获取DataFrame值，返回array数组</span><br><span class="line">df1.T  # 对DataFrame进行行列装换</span><br><span class="line">df1.head(num) # 显示前num行</span><br><span class="line">df1.tail(num) # 显示后num行</span><br><span class="line">df1.index &#x3D; [&quot;行_1&quot;,&quot;行_2&quot;] # 修改索引，必须整体修改</span><br><span class="line">df1.reset_index(drop&#x3D;False) # 重置索引，False为不删除索引，True为删除索引</span><br><span class="line">df1.set_index([&quot;列1&quot;]) # 设置列1为索引列</span><br></pre></td></tr></table></figure></li><li><p>Multilndex结构(三维数组的数据结构)：</p><ul><li>Multilndex是三维数据结构：也称多级索引，可以在Series、DataFrame对象上拥有2个以及2个以上的索引</li><li>Multilndex创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df2 &#x3D; df1.set_index([&quot;列1&quot;, &quot;列2&quot;])</span><br><span class="line"># 获取索引</span><br><span class="line">df2.index</span><br><span class="line">MultiIndex(levels&#x3D;[[列1去重后的所有元素],[列2去重后的所有元素]],</span><br><span class="line">          labels&#x3D;[[列1该位置元素对应levels的下标],[列1该位置元素对应levels的下标]],</span><br><span class="line">          name&#x3D;[&quot;列1&quot;,&quot;列2&quot;])</span><br></pre></td></tr></table></figure><h3 id="数据操作常用API"><a href="#数据操作常用API" class="headerlink" title="数据操作常用API"></a>数据操作常用API</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 索引切片</span><br><span class="line">df1 &#x3D; pd.read_csv(&quot;csv.csv&quot;) # 读取csv文件</span><br><span class="line">df2 &#x3D; df1.drop([&quot;列1&quot;,&quot;列2&quot;],axis&#x3D;1) # 删除列1列2,设置为0则是行</span><br><span class="line">df2[&quot;列&quot;][&quot;行&quot;]  # 索引数据,只能先列后行，且不支持切片</span><br><span class="line">df2.loc[&quot;行1&quot;:&quot;行5&quot;,&quot;列&quot;]  # 索引数据，只能先行后列</span><br><span class="line">df2.iloc[:num,:num]  # 通过下标索引，先行后列</span><br><span class="line">df2.ix[0:4,[&quot;列1&quot;,&quot;列2&quot;,&quot;列3&quot;]] # 可以通过名字或者下标来获取，推荐使用loc或iloc获取值</span><br><span class="line"># 赋值</span><br><span class="line">df2[&quot;列1&quot;]&#x3D;1 # 把列1值变成1，或者新增</span><br><span class="line">df2.列1 &#x3D; 0 # 把列1值变成1，或者新增</span><br><span class="line"># 排序</span><br><span class="line">df2.sort_index()  # 按索引升序排序</span><br><span class="line">df2.sort_values(by&#x3D;[&quot;列1&quot;,&quot;列2&quot;], ascending&#x3D;True) # 先按列1排序，在列1相同的前提下按列2排序，升序</span><br><span class="line"># 缺失值处理</span><br><span class="line">df2.drop_duplicates([&quot;列1&quot;,&quot;列2&quot;]) # 按列1、列2去重</span><br><span class="line">pd.isnull(df2) # 有缺失值返回True，没有返回False</span><br><span class="line">pd.notnull(df2) # 有缺失值返回False，没有返回True</span><br><span class="line">df3 &#x3D; df2.dropna(axid&#x3D;&quot;rows&quot;) # 返回按行删除缺失值的dataframe</span><br><span class="line">df2.fillna(value, inplace&#x3D;True)  # 在df2中的NaN替换成value</span><br><span class="line">df3 &#x3D; df2.replace(to_replace&#x3D;&quot;a&quot;, value&#x3D;&quot;b&quot;) # 返回一个把a替换成b的dataframe</span><br><span class="line"># 数据离散化</span><br><span class="line">df4 &#x3D; pd.qcut(df2[&quot;列1&quot;], 10)  # 返回把列1分别对应的区间</span><br><span class="line">df4.value_counts() # 返回对应区间的数据个数</span><br><span class="line">pd.cut(df2[&quot;列1&quot;],[-1,0,1]) # 把列1自定义分为4个区间</span><br><span class="line">df5 &#x3D; pd.get_dummies(df2[&quot;列1&quot;], prefix&#x3D;&quot;列1&quot;) # 把列1进行one_hot编码，生成的列名前加上列1_</span><br><span class="line"># 数据合并</span><br><span class="line">pd.concat([df1,df2],axis&#x3D;1)  # 把df1和df2行合并，当axis&#x3D;0时按列拼接</span><br><span class="line">pd.merge(df1,df2,how&#x3D;&quot;inner&quot;,on&#x3D;None) # 以how方式on为连接的键连接df1，df2</span><br><span class="line"># how:inner(默认):内连接(取交集);outer:外连接(并集);left:左连接;right:右连接</span><br><span class="line"># on:list,如果为None表示自动寻找df1和df2中列名一致的进行匹配</span><br><span class="line"></span><br><span class="line"># 交叉表：交叉表用于计算一列数据对于另外一列数据的分组个数（用于统计分组频率的特殊透视表）</span><br><span class="line">pd.crosstab(df1,df2)</span><br><span class="line"># 透视表：透视表是将原有的dataframe的列分别作为行索引和列索引，然后对指定的列应用聚集函数</span><br><span class="line">df5.pivot_table([&#39;a&#39;],index&#x3D;&#39;c&#39;)</span><br><span class="line"># 分组聚合</span><br><span class="line">df5.groupby([&#39;a&#39;]) # 把df5按a列进行分组</span><br><span class="line">count &#x3D; df5.groupby([&#39;a&#39;]).count() # 把df5按a列进行分组,计算没一列有多少个数据</span><br></pre></td></tr></table></figure><h3 id="DataFrame运算"><a href="#DataFrame运算" class="headerlink" title="DataFrame运算"></a>DataFrame运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 加减</span><br><span class="line">df2[&quot;列1&quot;].add(1)  # 把列1所有值加1</span><br><span class="line">df2[&quot;列1&quot;].sub(1)  # 把列1所有值减1</span><br><span class="line"># 按条件取值</span><br><span class="line">df2[df2[&quot;列1&quot;]&gt;10]  # 取出df2列1中大于10的数据</span><br><span class="line">df2[(df2[&quot;列1&quot;]&gt;10) &amp; (df2[&quot;列1&quot;]&lt;20)]  # 取出df2列1中大于10且小于20的数据</span><br><span class="line">df2.query(&quot;列1&lt;20 &amp; 列1&gt;10&quot;) # 取出df2列1中大于10且小于20的数据</span><br><span class="line">df2[df2[&quot;列1&quot;].isin([10,20])] # 取出df2列1中值是10和20的</span><br><span class="line"># 统计</span><br><span class="line">df2.describe()  # 返回对应列的和、平均值、标准差、最小值、四分位的值、最大值</span><br><span class="line">df2.sum()  # 每列的和</span><br><span class="line">df2.max()  # 每列的最大值</span><br><span class="line">df2.min()  # 每列的最小值</span><br><span class="line">df2.mean() # 每列的平均值</span><br><span class="line">df2.median() # 每列的中位数</span><br><span class="line">df2.mode()  # 每列中的出现次数最多的数</span><br><span class="line">df2.abs()  # 所有数的绝对值</span><br><span class="line">df2.prod() # 每列的乘积</span><br><span class="line">df2.std()  # 每列的标准差</span><br><span class="line">df2.var()  # 每列的方差</span><br><span class="line">df2.idxmax() # 每列中最大值的索引</span><br><span class="line">df2.idxmin() # 每列中最小值的索引</span><br><span class="line">df2.cumsum() # 每列累计前面数据的和</span><br><span class="line">df2.cummax() # 每列累计前面数据的最大值</span><br><span class="line">df2.cummin() # 每列累计前面数据的最小值</span><br><span class="line">df2.cumprod() # 每列累计前面数据的乘积</span><br><span class="line"># 自定义运算</span><br><span class="line">df2.apply(lambda x: x.max()-x.min(), axis&#x3D;0)  # 返回每列的最大值与最小值之差，当axis为1时按行传入</span><br></pre></td></tr></table></figure><h3 id="DataFrame画图"><a href="#DataFrame画图" class="headerlink" title="DataFrame画图"></a>DataFrame画图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 折线图</span><br><span class="line">df2[&quot;列1&quot;].plot()</span><br><span class="line">plt.show()</span><br><span class="line"># 垂直条形图</span><br><span class="line">df2[&quot;列1&quot;].plot(kind&#x3D;&quot;bar&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"># 水平条形图</span><br><span class="line">df2[&quot;列1&quot;].plot(kind&#x3D;&quot;barh&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"># 直方图</span><br><span class="line">df2[&quot;列1&quot;].plot(kind&#x3D;&quot;hist&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"># 饼图</span><br><span class="line">df2[&quot;列1&quot;].plot(kind&#x3D;&quot;pei&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"># 散点图</span><br><span class="line">df2[&quot;列1&quot;].plot(kind&#x3D;&quot;scatter&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="文件读取与存储"><a href="#文件读取与存储" class="headerlink" title="文件读取与存储"></a>文件读取与存储</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv读取与存储</span></span><br><span class="line">pd.read_csv(路径)</span><br><span class="line">pd.to_csv(路径)</span><br><span class="line"><span class="comment"># json读取与存储</span></span><br><span class="line">pd.read_json(路径)</span><br><span class="line">pd.to_json(路径)</span><br><span class="line"><span class="comment"># html读取与存储</span></span><br><span class="line">pd.read_html(路径)</span><br><span class="line">pd.to_html(路径)</span><br><span class="line"><span class="comment"># clipboard读取与存储</span></span><br><span class="line">pd.read_clipboard(路径)</span><br><span class="line">pd.to_clipboard(路径)</span><br><span class="line"><span class="comment"># exel读取与存储</span></span><br><span class="line">pd.read_exel(路径)</span><br><span class="line">pd.to_exel(路径)</span><br><span class="line"><span class="comment"># hdf5读取与存储</span></span><br><span class="line">pd.read_hdf(路径,key)</span><br><span class="line">pd.to_hdf(路径,key)</span><br><span class="line"><span class="comment"># feather读取与存储</span></span><br><span class="line">pd.read_feather(路径)</span><br><span class="line">pd.to_feather(路径)</span><br><span class="line"><span class="comment"># parquet读取与存储</span></span><br><span class="line">pd.read_parquet(路径)</span><br><span class="line">pd.to_parquet(路径)</span><br><span class="line"><span class="comment"># msgpack读取与存储</span></span><br><span class="line">pd.read_msgpack(路径)</span><br><span class="line">pd.to_msgpack(路径)</span><br><span class="line"><span class="comment"># stata读取与存储</span></span><br><span class="line">pd.read_stata(路径)</span><br><span class="line">pd.to_stata(路径)</span><br><span class="line"><span class="comment"># sas读取</span></span><br><span class="line">pd.read_sas(路径)</span><br><span class="line"><span class="comment"># pickle读取与存储</span></span><br><span class="line">pd.read_pickle(路径)</span><br><span class="line">pd.to_pickle(路径)</span><br><span class="line"><span class="comment"># sql读取与存储</span></span><br><span class="line">pd.read_sql(路径)</span><br><span class="line">pd.to_sql(路径)</span><br><span class="line"><span class="comment"># gbq读取与存储</span></span><br><span class="line">pd.read_gbq(路径)</span><br><span class="line">pd.to_gbq(路径)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch</title>
      <link href="/blog/2019/08/12/pytorch/"/>
      <url>/blog/2019/08/12/pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><h2 id="1-Pytorch安装"><a href="#1-Pytorch安装" class="headerlink" title="1.Pytorch安装"></a>1.Pytorch安装</h2><p>安装地址介绍：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><p><img src="/blog/img/pytorch_1.png"></p><p>带GPU安装步骤：</p><p><code>conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</code></p><p>不带GPU安装步骤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch<span class="operator">-</span>cpu <span class="operator">-</span>c pytorch </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure><p>安装之后打开ipython</p><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]:<span class="keyword">import</span> torch  <span class="comment"># 不报错就没事</span></span><br></pre></td></tr></table></figure><p>注意：安装模块的时候安装的是<code>pytorch</code> ，但是在代码中都是使用<code>torch</code></p><h2 id="2-Pytorch基本数据结构张量（Tensor）"><a href="#2-Pytorch基本数据结构张量（Tensor）" class="headerlink" title="2.Pytorch基本数据结构张量（Tensor）"></a>2.Pytorch基本数据结构张量（Tensor）</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor([])   # 根据提供的数据结构创建张量</span><br><span class="line">torch.empty(3,4)   # 创建3行4列的空tensor，会用无用数据进行填充</span><br><span class="line">torch.ones([3,4])  # 创建3行4列全为一的tensor</span><br><span class="line">torch.zeros([3,4]) # 创建3行4列全为0的tensor</span><br><span class="line">torch.rand([3,4])  # 创建3行4列的随机tensor，随机区间是[0,1)</span><br><span class="line">torch.randint(low&#x3D;3,high&#x3D;10,size&#x3D;[3,4]) # 创建一个[low,high)之间3行4列的tensor</span><br><span class="line">torch.randn([3,4]) # 创建一个均值为0，方差为1的3行4列的tensor</span><br></pre></td></tr></table></figure><h3 id="3-Tensor常用的属性和方法"><a href="#3-Tensor常用的属性和方法" class="headerlink" title="3.Tensor常用的属性和方法"></a>3.Tensor常用的属性和方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tensor.dtype    # 获取tensor的数据类型</span><br><span class="line">tensor.item()   # 如果tensor中数据只有一个值时可以使用该方法获取</span><br><span class="line">tensor.numpy()  # 把tensor转换成numpy数组</span><br><span class="line">tensor.size()   # 获取tensor的形状，值由外到里排序</span><br><span class="line">tensor.size(num) # 获取tensor第num阶的大小</span><br><span class="line">tensor.view([num1,num2]) # 把tensor转变成num1行，num2列的tensor</span><br><span class="line">tensor.transpose(num1,num2) # 把第num1阶和num2阶进行转置或tensor.t(num1,num2)</span><br><span class="line">tensor.t(num1,num2)    # 同上</span><br><span class="line"># 从tensor取出来的值还是类型还是tensor</span><br><span class="line">tensor[num1,num2:num3]  # 切片和索引，第一个逗号签的表示对第一阶进行切片或索引，下面以此类推</span><br><span class="line">tensor.dim()   # 获取tensor的阶数</span><br><span class="line">tensor.max(dim&#x3D;-1)  # 获取行方向最大值，并给出行方向的坐标；不输入dim值获取全局最大值</span><br><span class="line">tensor1.add(tensor2)  # 对tensor1和tensor2进行相加生成一个新的tensor</span><br><span class="line">#也可以写成tensor1+tensor2</span><br><span class="line">tensor1.add_(tensor2) # 对tensor1和tensor2进行相加生成新的tensor，并付给tensor1；注意上面有许多方法都可以在方法名后面加_使其是对数据原地修改</span><br></pre></td></tr></table></figure><h3 id="4-Tensor的数据类型"><a href="#4-Tensor的数据类型" class="headerlink" title="4.Tensor的数据类型"></a>4.Tensor的数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Data Type          |     dtype                      |      Tensor types</span><br><span class="line">64-bit floating    |  torch.float64 or torch.double |    torch.DoubleTensor</span><br><span class="line">32-bit floating    |  torch.float32 or torch.float  |    torch.FloatTensor</span><br><span class="line">16-bit floating    |  torch.float16 or torch.half   |    torch.HalfTensor</span><br><span class="line">8-bit integer(unsighed)|        torch.uint8         |    torch.ByteTensor</span><br><span class="line">8-bit integer(signed)|        torch.int8            |    torch.CharTensor</span><br><span class="line">16-bit integer(signed)|torch.int16 or touch.short   |    torch.ShortTensor</span><br><span class="line">32-bit integer(signed)|torch.int32 or touch.int     |    torch.IntTensor</span><br><span class="line">64-bit integer(signed)|torch.int64 or touch.long    |    torch.LongTensor</span><br></pre></td></tr></table></figure><h3 id="5-指定GPU计算"><a href="#5-指定GPU计算" class="headerlink" title="5.指定GPU计算"></a>5.指定GPU计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()   # 判断是否支持GPU运算</span><br><span class="line">device &#x3D; torch.device(&quot;cuda:0&quot;)  # 指定第一块gpu运算</span><br><span class="line">gpu_tensor &#x3D; torch.tensor([],device&#x3D;device)  # 创建适合在gpu上运行的tensor</span><br><span class="line">tensor &#x3D; torch.tensor([])   # 指定device，默认创建cpu的tensor</span><br><span class="line">gpu_tensor &#x3D; tensor.to(device)   # 把cpu tensor转换成gpu的</span><br><span class="line">tensor &#x3D; gpu_tensor.cpu()    # 把gpu tensor转换成cpu的</span><br><span class="line">tensor.device    # 查看该数据是适合在cpu上运行还是gpu上</span><br><span class="line"># 全兼容代码</span><br><span class="line">device &#x3D; torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span><br></pre></td></tr></table></figure><h3 id="6-反向计算"><a href="#6-反向计算" class="headerlink" title="6.反向计算"></a>6.反向计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># requires_grad和grad_fn   用于反向计算 </span><br><span class="line">tensor.requires_grad  # 是否记录计算过程的一个属性,默认为False</span><br><span class="line">tensor.requires_grad_(True)  # 就地修改tensor的requires_grad的属性</span><br><span class="line">tensor.grad_fn  # 查看该tensor是怎么计算来的</span><br><span class="line">torch.no_gard()   # 该函数以下的tensor不记录计算过程，一般搭配with上下文管理器使用，一般在评估的时候使用</span><br><span class="line"># x特征矩阵和w权重矩阵经过一系列计算出输出out（损失）（都是requires_grad为True的tensor）</span><br><span class="line">out.backward()   # 进行反向计算；out必须为一个数</span><br><span class="line">w.gard   # 获取权重的倒数</span><br><span class="line">tensor.data  # 获取tensor中的值</span><br><span class="line">tensor.detach()   # 获取tensor中的值，与data的区别在于detach（）可被微分</span><br></pre></td></tr></table></figure><h3 id="7-损失函数"><a href="#7-损失函数" class="headerlink" title="7.损失函数"></a>7.损失函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.MSELoss()   # 均方误差损失</span><br><span class="line">torch.nn.CrossEntorpyLoss()   # 交叉熵损失（对数自然损失）</span><br></pre></td></tr></table></figure><h3 id="8-优化器类"><a href="#8-优化器类" class="headerlink" title="8.优化器类"></a>8.优化器类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.optim.BGD(需要优化的参数，学习率)  # 梯度下降</span><br><span class="line">torch.optim.SGD(参数，学习率)  # 随机梯度下降</span><br><span class="line">torch.optim.Adam(参数，学习率)</span><br></pre></td></tr></table></figure><h3 id="9-nn-Module"><a href="#9-nn-Module" class="headerlink" title="9.nn.Module"></a>9.nn.Module</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">device &#x3D; torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span><br><span class="line"># 继承Module</span><br><span class="line">class Lr(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Lr, self).__init__()</span><br><span class="line">        # 下面就是自定义参数（Linear实际上也是实例化参数，并定义了forward方法）</span><br><span class="line">        self.lr1 &#x3D; torch.nn.Linear(10, 2)</span><br><span class="line">        self.lr2 &#x3D; torch.nn.Linear(2, 1)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">    # 进行一次向前计算(如果是实现神经网络可以再out1和out2后面套一个函数即可)</span><br><span class="line">        out1 &#x3D; self.lr1(x)</span><br><span class="line">        out2 &#x3D; self.lr2(out1)</span><br><span class="line">        return out2</span><br><span class="line"></span><br><span class="line">def main(x,y,num):</span><br><span class="line">    # 实例化模型</span><br><span class="line">    module &#x3D; Lr().to(device)</span><br><span class="line">    # 定义优化器并指定优化器要优化哪些参数</span><br><span class="line">    optimizer &#x3D; torch.optim.SGD(module.parameters(), lr&#x3D;0.01)</span><br><span class="line">    # 定义损失函数</span><br><span class="line">    criterion &#x3D; torch.nn.MSELoss()</span><br><span class="line">    # 开始循环训练</span><br><span class="line">    for i in range(num):</span><br><span class="line">        # 计算预测值</span><br><span class="line">        y_predict &#x3D; module(x)</span><br><span class="line">        # 计算损失</span><br><span class="line">        loss &#x3D; criterion(y, y_predict)</span><br><span class="line">        # 梯度置为零</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        # 计算梯度</span><br><span class="line">        loss.backward()</span><br><span class="line">        # 更新参数</span><br><span class="line">        optimizer.step()</span><br><span class="line">    print([i for i in module.parameters()])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    x &#x3D; torch.randn([50, 10]).to(device)</span><br><span class="line">    y &#x3D; x * 3 + 8</span><br><span class="line">    main(x,y,10000)</span><br></pre></td></tr></table></figure><h3 id="10-Dataset数据基类"><a href="#10-Dataset数据基类" class="headerlink" title="10.Dataset数据基类"></a>10.Dataset数据基类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-torch常用方法"><a href="#11-torch常用方法" class="headerlink" title="11.torch常用方法"></a>11.torch常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.Embedding(num_embedding, embedding_dim)</span><br><span class="line"># num_embedding:词典长度；embedding_dim：每个词向量化之后的维度</span><br></pre></td></tr></table></figure><p>未完待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能优化算法</title>
      <link href="/blog/2019/08/12/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/08/12/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度下降法（BGD）"><a href="#梯度下降法（BGD）" class="headerlink" title="梯度下降法（BGD）"></a>梯度下降法（BGD）</h1><p>每次迭代都需要把所有的样本都送入进行梯度计算，是做全局的最优化，但是有可能达到局部最优</p><p>缺点：计算量大</p><p><img src="/blog/img/BGD.jpg" alt="BGD"></p><h1 id="随机梯度下降法（SGD）"><a href="#随机梯度下降法（SGD）" class="headerlink" title="随机梯度下降法（SGD）"></a>随机梯度下降法（SGD）</h1><p>针对梯度下降算法训练过慢的缺点，每一次进行梯度计算的时候只选出一组数据进行计算并更新一次，再循环；史得计算量大大减小。</p><p>缺点：受噪声影响大</p><h1 id="小批量梯度下降（MBGD）"><a href="#小批量梯度下降（MBGD）" class="headerlink" title="小批量梯度下降（MBGD）"></a>小批量梯度下降（MBGD）</h1><p>结合BGD和SGD取的一个新的优化方法，每一次随机抽出一小批进行梯度计算，参数更新，从而减少噪声带来的影响，也可使计算速度得到了保证。</p><h1 id="Momentum（从梯度角度优化）"><a href="#Momentum（从梯度角度优化）" class="headerlink" title="Momentum（从梯度角度优化）"></a>Momentum（从梯度角度优化）</h1><p>MBGD算法虽然能带来很好的训练速度，但是在快达到最优解的时候不能真正达到最优解，只能在最优解附近徘徊，为解决这一问题，创造了动量法</p><p>主要思想是之前梯度大，那接下来也梯度大，使得梯度更加稳定平缓</p><p><img src="/blog/img/Momentum.jpg" alt="Momentum"></p><h1 id="AdaGrad（从学习率角度优化）"><a href="#AdaGrad（从学习率角度优化）" class="headerlink" title="AdaGrad（从学习率角度优化）"></a>AdaGrad（从学习率角度优化）</h1><p>主要思想就是可以设定一个较大的学习率前期收敛快，而后期是这个学习率慢慢减少</p><p><img src="/blog/img/AdaGrad.jpg" alt="AdaGrad"></p><h1 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h1><p>基于AdaGrad进行对学习率方面进行了指数加权</p><p><img src="/blog/img/RMSProp.jpg" alt="RMSProp"></p><h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>Adam算法是结合RMSProp和Momentum算法的结合，一方面能够防止梯度摆幅过大，同时还能加快收敛速度</p><p><img src="/blog/img/Adam.jpg" alt="Adam"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/blog/2019/08/12/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul><li>定义：<ul><li>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。(On^2)</li></ul></li><li>代码实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line"></span><br><span class="line">li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/blog/2019/08/12/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><ul><li>定义：<ul><li>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。(On*k)</li></ul></li><li>代码实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于桶排序的基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    d = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(<span class="built_in">list</span>)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(d):<span class="comment">#d轮排序</span></span><br><span class="line">        s=[[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]<span class="comment">#因为每一位数字都是0~9，故建立10个桶</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">            s[<span class="built_in">int</span>(i/(<span class="number">10</span>**k)%<span class="number">10</span>)].append(i)</span><br><span class="line">        <span class="built_in">list</span>=[j <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">for</span> j <span class="keyword">in</span> i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">65</span>]</span><br><span class="line">print(radixSort(nums))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/blog/2019/08/12/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ul><li>定义：<ul><li>堆排序是指利用堆这种数据结构所设计的一种排序算法，堆积是一个近似完全二叉数的结构，并同时满足堆积的性质：即子节点的键值或索引值总是小于(或大于)它的父节点，堆排序可以说是一种利用堆的概念来排序的选择排序（Onlogn）</li></ul></li><li>代码实现：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, n, i</span>):</span></span><br><span class="line">    largest = i</span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># left = 2*i + 1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># right = 2*i + 2</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># Build a maxheap.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    <span class="comment"># 一个个交换元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">heapSort(arr)</span><br><span class="line">print(<span class="string">&quot;排序后&quot;</span>, arr)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/blog/2019/08/12/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><ul><li><p>定义：</p><ul><li><p>希尔排序(Shell Sort)是插入排序的一种。也称<strong>缩小增量排序</strong>，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。（On^2）</p></li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(alist):</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    # 初始步长</span><br><span class="line">    gap &#x3D; n&#x2F;&#x2F;2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        # 按步长进行插入排序</span><br><span class="line">        for i in range(gap, n):</span><br><span class="line">            j &#x3D; i</span><br><span class="line">            # 插入排序</span><br><span class="line">            while j&gt;&#x3D;gap and alist[j-gap] &gt; alist[j]:</span><br><span class="line">                alist[j-gap], alist[j] &#x3D; alist[j], alist[j-gap]</span><br><span class="line">                j -&#x3D; gap</span><br><span class="line">        # 得到新的步长</span><br><span class="line">        gap &#x3D; gap &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">shell_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/blog/2019/08/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul><li><p>定义：</p><ul><li>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可（Onlogn）</li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    num = <span class="built_in">len</span>(alist)/<span class="number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> r&lt;<span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/blog/2019/08/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul><li>定义：<ul><li><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 使用分治法来把一个串（list）分为两个子串（sub-lists） 。(On^2)</li></ul></li><li>代码实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">alist, start, end</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归的退出条件</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line">    <span class="comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line">    <span class="comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    <span class="comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="number">0</span>,<span class="built_in">len</span>(alist)-<span class="number">1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/blog/2019/08/12/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul><li><p>定义：</p><ul><li>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对未排序数据，在已排中从前向后扫描，找到相应位置并插入。（On^2）</li></ul></li><li><p>代码实现：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(alist)):</span><br><span class="line">        <span class="comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[j-<span class="number">1</span>]:</span><br><span class="line">                alist[j], alist[j-<span class="number">1</span>] = alist[j-<span class="number">1</span>], alist[j]</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">insert_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/blog/2019/08/12/%E6%95%B0%E5%AD%A6/"/>
      <url>/blog/2019/08/12/%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="均值-Mean"><a href="#均值-Mean" class="headerlink" title="均值(Mean)"></a>均值(Mean)</h1><p>反应该集合中的数大多数处在哪个水平</p><p>即平均值：<br>$$<br>mean=\frac{\sum_{i=0}^{i=N}n_i}{N}\quad\quad\quad\quad N：为总数量；n：为每个数量的值<br>$$</p><h1 id="标准差-Standard-Deviation"><a href="#标准差-Standard-Deviation" class="headerlink" title="标准差(Standard Deviation)"></a>标准差(Standard Deviation)</h1><p>可以反映出数据的离散程度<br>$$<br>std^2 = \frac{\sum_{i=0}^{i=N}(n_i-Mean)^2}{N}\quad\quad\quad\quad N：为总数量；n：为每个数量的值<br>$$</p><h1 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h1><p>方差=标准查^2</p><h1 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h1><p>就是把所有的数据归到[0, 1]的区间里面<br>$$<br>n=\frac{n-min}{max-min}<br>$$</p><h1 id="标准化处理"><a href="#标准化处理" class="headerlink" title="标准化处理"></a>标准化处理</h1><p>把数据转换成均值为0，标准差为1的数据<br>$$<br>n=\frac{n-mean}{std}<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/blog/2019/08/12/%E6%A0%88/"/>
      <url>/blog/2019/08/12/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><ul><li>定义<ul><li>栈是一种容器，可存入元素、访问元素、删除元素，它的特点在于只能允许在容器的一端进行加入和输出数据的运算。没有了位置的概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素。由于栈数据结构只允许在一端进行操作，因此按照后进先出的原理运作</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    &quot;&quot;&quot;节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item&#x3D;None, next&#x3D;None):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line"></span><br><span class="line">class Stack():</span><br><span class="line">    &quot;&quot;&quot;栈&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self.head &#x3D; node</span><br><span class="line">        </span><br><span class="line">    def push(self, item):</span><br><span class="line">        &quot;&quot;&quot;栈顶插入元素&quot;&quot;&quot;</span><br><span class="line">        self.head &#x3D; None(item, self.head)</span><br><span class="line">        </span><br><span class="line">    def pop(self):</span><br><span class="line">        &quot;&quot;&quot;弹出栈顶元素&quot;&quot;&quot;</span><br><span class="line">        if self.head:</span><br><span class="line">            self.head&#x3D;self.head.next</span><br><span class="line">            return</span><br><span class="line">        return &quot;栈为空栈&quot;</span><br><span class="line">    </span><br><span class="line">    def peek(self):</span><br><span class="line">        &quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;</span><br><span class="line">        if self.head:</span><br><span class="line">            return self.head.item</span><br><span class="line">        return &quot;栈为空栈&quot;</span><br><span class="line">    </span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断是否为空栈&quot;&quot;&quot;</span><br><span class="line">        return self.head&#x3D;&#x3D;None</span><br><span class="line">    </span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回元素个数&quot;&quot;&quot;</span><br><span class="line">        num &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node&#x3D;&#x3D;None:</span><br><span class="line">            return num</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        while node.next!&#x3D;None:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/blog/2019/08/12/%E6%A0%91/"/>
      <url>/blog/2019/08/12/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ul><li>定义<ul><li>树：是一种抽象数据类型或是视作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。</li></ul></li><li>特点<ul><li>每个节点有零个或多个子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除根节点外，每一个子节点可以分为多个不相交的树</li></ul></li><li>树的术语<ul><li>节点的度：该节点上直接子节点的个数</li><li>树的度：一颗树中，最大节点的度称为树的度</li><li>叶节点或终端节点：度为零的节点</li><li>父节点：若该节点含有子节点，那么这个节点就是子节点的父节点</li><li>子节点：意义同上</li><li>兄弟节点：具有相同父节点的子节点的节点称为兄弟节点</li><li>节点的层次：从根节点开始定义，根节点的子节点为第一层，根节点的子节点的子节点为第二层</li><li>树的高度：树中节点的最大层次</li><li>堂兄弟节点：在同一层次上的节点</li><li>节点的祖先：从根节点开始到该节点所经过的所以节点</li><li>子孙：该节点下的所有的节点</li><li>森林：由m(m&gt;=0)棵互不相交的树的集合称为森林</li></ul></li><li>树的种类<ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树</li><li>有序树：树中任意节点的子节点之间由顺序关系，这种树称为有序树<ul><li>二叉树：每个节点最多含有两个子节点的树称为二叉树<ul><li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其他各层的节点数目均已达到最大值。且第d层所有的节点从左到右连续紧密排列，这样的二叉树被称为完全二叉树</li><li>平衡二叉树(AVL树)：当且仅当任何节点的两颗子树的高度不大于1的二叉树，称为平衡二叉树。</li><li>排序二叉树：二叉查找树；二叉搜索树</li></ul></li><li>霍夫曼树(用于信息编码)：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉树，能够保持数据有序，拥有多余两个子树</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/blog/2019/08/12/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><ul><li><p>定义：</p><ul><li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。（On^2）</li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">nums, n</span>):</span></span><br><span class="line">    <span class="comment"># 选择一个最大的数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">max</span>(nums) &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">        n = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    mid = <span class="built_in">max</span>(nums) // n</span><br><span class="line">    <span class="keyword">if</span> mid == <span class="number">0</span>:</span><br><span class="line">        mid = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 创建一个元素全是0的列表, 当做桶</span></span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 把所有元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        bucket[<span class="built_in">int</span>(i / mid)].append(i)</span><br><span class="line">    print(bucket)</span><br><span class="line">    sort_nums = []</span><br><span class="line">    <span class="comment"># 取出桶中的元素</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bucket[j]) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 使用递归继续桶排序</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(bucket[j]) &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="number">1</span>:</span><br><span class="line">                bucket[j] = bucketSort(bucket[j], n)</span><br><span class="line">            <span class="comment"># 取出排序好的元素</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> bucket[j]:</span><br><span class="line">                sort_nums.append(y)</span><br><span class="line">    <span class="keyword">return</span> sort_nums</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">65</span>]</span><br><span class="line">print(bucketSort(nums, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激活函数</title>
      <link href="/blog/2019/08/12/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2019/08/12/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="使用激活函数的原因是因为：如果不使用损失函数再深层次的神经网络都可以直接用一个函数进行替代"><a href="#使用激活函数的原因是因为：如果不使用损失函数再深层次的神经网络都可以直接用一个函数进行替代" class="headerlink" title="使用激活函数的原因是因为：如果不使用损失函数再深层次的神经网络都可以直接用一个函数进行替代"></a>使用激活函数的原因是因为：如果不使用损失函数再深层次的神经网络都可以直接用一个函数进行替代</h1><h1 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h1><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_1.jpg"></p><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_2.jpg"></p><p>由于函数特性如果神经网络层数增多回导致梯度趋近于0，即梯度消失。当网络权值初始化为（1，+∞）区间值时回出现梯度爆炸，而且函数相对复杂，不易于训练。</p><h1 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h1><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_3.jpg"></p><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_4.jpg"></p><p>解决了Sigmoid不是0中心的问题，但是梯度问题和运算问题仍然存在</p><h1 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h1><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_5.jpg"></p><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_6.jpg"></p><p>优点：</p><ul><li>计算速度非常快（只需要一个判断）</li><li>解决了梯度问题</li><li>收敛速度远大于Sigmoid和Tanh</li></ul><p>缺点：</p><ul><li>ReLU不是0中心函数</li><li>由于小于0的地方梯度都为0，有可能导致某些神经元永远不会被激活</li></ul><h1 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h1><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_7.jpg"></p><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_8.jpg"></p><p>虽然解决了ReLU小于0的地方梯度都为0的问题，但是实际使用情况时ReLU的效果会优于Leaky ReLU</p><h1 id="Swish"><a href="#Swish" class="headerlink" title="Swish"></a>Swish</h1><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_9.jpg"></p><p><img src="/blog/img/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0_10.jpg"></p><p>Swish使用效果优于ReLU</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/blog/2019/08/12/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><ul><li>定义：<ul><li>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。(On+k)</li></ul></li><li>代码实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################数字排序#############</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="comment"># 输出序列</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">max</span>(arr) &gt; <span class="built_in">len</span>(arr):</span><br><span class="line">        n = <span class="built_in">max</span>(arr) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr) + <span class="number">1</span></span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 计数序列</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        count[i + <span class="number">1</span>] += count[i]</span><br><span class="line">    print(count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 下标从0开始</span></span><br><span class="line">        output[count[arr[i]] - <span class="number">1</span>] = arr[i]</span><br><span class="line">        count[arr[i]] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (output[:<span class="built_in">len</span>(arr)])</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>]</span><br><span class="line">ans = countSort(arr)</span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment">#################字母排序##################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 输出序列</span></span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    <span class="comment"># 计数序列</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    ans = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count[<span class="built_in">ord</span>(i)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 下标从0开始</span></span><br><span class="line">        output[count[<span class="built_in">ord</span>(arr[i])] - <span class="number">1</span>] = arr[i]</span><br><span class="line">        count[<span class="built_in">ord</span>(arr[i])] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        ans[i] = output[i]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = <span class="string">&quot;wwwrunoobcom&quot;</span></span><br><span class="line">ans = countSort(arr)</span><br><span class="line">print(<span class="string">&quot;字符数组排序 %s&quot;</span> % (<span class="string">&quot;&quot;</span>.join(ans)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/blog/2019/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li><p>定义：</p><ul><li><p><strong>选择排序（Selection sort）</strong>是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。(On^2)</p></li></ul></li><li><p>代码实现：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">226</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">selection_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/blog/2019/08/12/%E9%93%BE%E8%A1%A8/"/>
      <url>/blog/2019/08/12/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>定义<ul><li>链表是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储，而是在每一个节点里面存放下一个节点的位置信息</li></ul></li><li>单链表(当前节点只存储下一个节点的信息)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    &quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, item, next&#x3D;None):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkList():</span><br><span class="line">    &quot;&quot;&quot;链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self.head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return True if self.head else False</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表长度&quot;&quot;&quot;</span><br><span class="line">        num &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return num</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加&quot;&quot;&quot;</span><br><span class="line">        self.head &#x3D; Node(item, self.head)</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return</span><br><span class="line">        print(node.item)</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            print(node.item)</span><br><span class="line"></span><br><span class="line">    def addend(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            self.head &#x3D; Node(item)</span><br><span class="line">            return</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        node.next &#x3D; Node(item)</span><br><span class="line"></span><br><span class="line">    def insert(self, index, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; None(item, node.next)</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def remove(self, index):</span><br><span class="line">        &quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.head &#x3D; self.head.next</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index-1):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; node.next.next</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        while node.next:</span><br><span class="line">            if node.item&#x3D;&#x3D;item:</span><br><span class="line">                return index</span><br><span class="line">            index +&#x3D; 1</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return &quot;该元素不存在&quot;</span><br></pre></td></tr></table></figure><ul><li>双向链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    &quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item, per&#x3D;None, next&#x3D;None):</span><br><span class="line">        self.per &#x3D; per</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkList():</span><br><span class="line">    &quot;&quot;&quot;双向链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self.head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return True if self.head else False</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表长度&quot;&quot;&quot;</span><br><span class="line">        num &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return num</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加&quot;&quot;&quot;</span><br><span class="line">        self.head &#x3D; Node(item, next&#x3D;self.head)</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return</span><br><span class="line">        print(node.item)</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            print(node.item)</span><br><span class="line"></span><br><span class="line">    def addend(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            self.head &#x3D; Node(item)</span><br><span class="line">            return</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        node.next &#x3D; Node(item, node)</span><br><span class="line"></span><br><span class="line">    def insert(self, index, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; None(item, node, node.next)</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def remove(self, index):</span><br><span class="line">        &quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.head &#x3D; self.head.next</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index-1):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; node.next.next</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        while node.next:</span><br><span class="line">            if node.item&#x3D;&#x3D;item:</span><br><span class="line">                return index</span><br><span class="line">            index +&#x3D; 1</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return &quot;该元素不存在&quot;</span><br></pre></td></tr></table></figure><ul><li>循环链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">    &quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item, per&#x3D;None, next&#x3D;None):</span><br><span class="line">        self.per &#x3D; per</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkList():</span><br><span class="line">    &quot;&quot;&quot;循环链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self.head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return True if self.head else False</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表长度&quot;&quot;&quot;</span><br><span class="line">        num &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return num</span><br><span class="line">        num +&#x3D; 1</span><br><span class="line">        while node.next!&#x3D;self.head:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表头部添加&quot;&quot;&quot;</span><br><span class="line">        self.head &#x3D; Node(item, per&#x3D;self.head.per, next&#x3D;self.head)</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            return</span><br><span class="line">        print(node.item)</span><br><span class="line">        while node.next!&#x3D;self.head:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            print(node.item)</span><br><span class="line"></span><br><span class="line">    def addend(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        if node &#x3D;&#x3D; None:</span><br><span class="line">            node &#x3D; Node(item)</span><br><span class="line">            node.per&#x3D;node</span><br><span class="line">            node.next&#x3D;node</span><br><span class="line">            self.head &#x3D; node</span><br><span class="line">            return</span><br><span class="line">        while node.next:</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        node.next &#x3D; Node(item, node, node.next)</span><br><span class="line"></span><br><span class="line">    def insert(self, index, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; None(item, node, node.next)</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def remove(self, index):</span><br><span class="line">        &quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            self.head &#x3D; self.head.next</span><br><span class="line">            return</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        try:</span><br><span class="line">            for i in range(index-1):</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            node.next &#x3D; node.next.next</span><br><span class="line">            node.next.per&#x3D;node</span><br><span class="line">        except:</span><br><span class="line">            assert &quot;索引超出范围&quot;</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        node &#x3D; self.head</span><br><span class="line">        while node.next:</span><br><span class="line">            if node.item&#x3D;&#x3D;item:</span><br><span class="line">                return index</span><br><span class="line">            index +&#x3D; 1</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return &quot;该元素不存在&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/blog/2019/08/12/%E9%98%9F%E5%88%97/"/>
      <url>/blog/2019/08/12/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul><li>定义<ul><li>和栈一样，顺序发生改变，有先进后出，变成先进先出，</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Queue():</span><br><span class="line">    &quot;&quot;&quot;队列&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        &quot;&quot;&quot;往队列中添加一个元素&quot;&quot;&quot;</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        &quot;&quot;&quot;删除第一个元素并返回&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span><br><span class="line">        return self.items&#x3D;&#x3D;[]</span><br><span class="line">    </span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回队列个数&quot;&quot;&quot;</span><br><span class="line">        return len(self.items)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES部署</title>
      <link href="/blog/2019/08/12/ES%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
      <url>/blog/2019/08/12/ES%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ES部署"><a href="#ES部署" class="headerlink" title="ES部署"></a>ES部署</h1><h4 id="一、配置网卡（无网环境忽略此条）"><a href="#一、配置网卡（无网环境忽略此条）" class="headerlink" title="一、配置网卡（无网环境忽略此条）"></a>一、配置网卡（无网环境忽略此条）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-*</span><br><span class="line"></span><br><span class="line">BOOTPROTO=static# 修改为静态网路，可以不修改</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h4 id="二、配置本地yum源（有网环境忽略此条）"><a href="#二、配置本地yum源（有网环境忽略此条）" class="headerlink" title="二、配置本地yum源（有网环境忽略此条）"></a>二、配置本地yum源（有网环境忽略此条）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /centos7#存放本地yum源</span><br><span class="line"></span><br><span class="line">mount /iso  ./tmp#将iso镜像挂载到本地文件中</span><br><span class="line"></span><br><span class="line">cp -vrf ./tmp/* /centos7#将挂载后到本地文件copy到本地yum源文件中</span><br><span class="line"></span><br><span class="line">cd /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">mv ./CentOS-*/root/tmp#移除yum到网络源信息</span><br><span class="line"></span><br><span class="line">vi yum.repo#编写本地yum</span><br><span class="line">[centos7-yum]</span><br><span class="line">name=&quot;yum.local&quot;</span><br><span class="line">baseurl=file:///centos7</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">yum clean all#刷新缓存</span><br><span class="line"></span><br><span class="line">rm -rf /var/cache/yum</span><br><span class="line"></span><br><span class="line">yum list#显示数据则表示本地yum配置成功</span><br><span class="line"></span><br><span class="line">yum install net-tools#安装net-tools，查看ifconfig</span><br></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    本地挂载完镜像之后，如果还要使用该文件的话，必须先umount该文件，否则会报错，提示权限不够</p><h4 id="三、关闭防火墙及selinux"><a href="#三、关闭防火墙及selinux" class="headerlink" title="三、关闭防火墙及selinux"></a>三、关闭防火墙及selinux</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line">SELINUX=disabled</span><br><span class="line">setenforce 0</span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>​    安装docker时可以不用关闭，当es进行集群部署时，必须关闭，否则集群无法生效</p><h4 id="四、安装docker"><a href="#四、安装docker" class="headerlink" title="四、安装docker"></a>四、安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp docker.zip root@ip:~#没网手动copy</span><br><span class="line">unzip docker.zip</span><br><span class="line">cd docker</span><br><span class="line">sh setup_without_container-selinux-2.9#虚拟机/实体机</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器，直接联网安装，不赘述</span></span><br></pre></td></tr></table></figure><p>setup_without_container-selinux-2.9.sh 脚本内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">auto-mount</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum remove -y docker-engine</span><br><span class="line">mkdir -p /data/tmp</span><br><span class="line">chmod -R 777 /data/tmp</span><br><span class="line">mkdir -p /data/sys/var/docker</span><br><span class="line">chmod -R 777 /data/sys/var/docker</span><br><span class="line">ln -s /data/sys/var/docker /var/lib/docker</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">echo &quot;vm.max_map_count=655360&quot; &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</span><br><span class="line">yum install -y net-tools</span><br><span class="line">useradd -d /data/duser -m duser</span><br><span class="line">echo &quot;duser:5VSDHai4&quot; |chpasswd</span><br><span class="line">echo &quot;duser    ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br><span class="line">rpm -ivh container-selinux-2.9-4.el7.noarch.rpm</span><br><span class="line">yum install -y ./docker-ce-17.09.0.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">usermod -aG docker duser</span><br><span class="line">rm -fr ./*</span><br><span class="line">cd ../</span><br><span class="line">rm -fr docker_install docker_install.tar.gz</span><br></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><p>​    sh脚本可以根据具体情况进行修改</p><p>​    当出现无法安装成功，且提示rpm安装问题时，在rpm安装命令之后，加 —nodeps —force  ，意思为不考虑分析包之间的依赖关系，即可安装成功</p><h4 id="五、开启docker服务"><a href="#五、开启docker服务" class="headerlink" title="五、开启docker服务"></a>五、开启docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl status docker</span><br><span class="line">docker version#查询是否开启docker</span><br></pre></td></tr></table></figure><h4 id="六、安装java-部署es-的依赖"><a href="#六、安装java-部署es-的依赖" class="headerlink" title="六、安装java(部署es 的依赖)"></a>六、安装java(部署es 的依赖)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version#查看是否有java，如果有，忽略以后步骤</span><br></pre></td></tr></table></figure><h5 id="本地安装java"><a href="#本地安装java" class="headerlink" title="本地安装java"></a>本地安装java</h5><p>​    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">cp jdk-8u171-linux-x64.rpm /usr/java</span><br><span class="line">cd /usr/java</span><br><span class="line">chmod +x jdk-8u171-linux-x64.rpm</span><br><span class="line">rpm -ivh jdk-8u171-linux-x64.rpm</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h4 id="七、读取镜像（根据实际情况）"><a href="#七、读取镜像（根据实际情况）" class="headerlink" title="七、读取镜像（根据实际情况）"></a>七、读取镜像（根据实际情况）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker load -i image.tar#如果是zip的镜像，则先unziip成tar文件</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器，并且将本地的文件目录挂载至容器data目录下</span></span><br><span class="line">docker run -itd -p 8888:8888 -v /data/origin_file:/data/duser/patent_similaruty/data/origin_file --name patent_preprocess patent_preprocess:1.1 bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">docker exec -it patent_preprocess bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">docker stop patent_preprocess</span><br></pre></td></tr></table></figure><h4 id="八、如果需要docker-compose启动"><a href="#八、如果需要docker-compose启动" class="headerlink" title="八、如果需要docker-compose启动"></a>八、如果需要docker-compose启动</h4><p>安装并使用docker-compose</p><p>方法一：</p><p>使用curl命令下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>方法二：</p><p>使用pip命令下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line">yum -y install python-pip</span><br><span class="line"></span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h2 id="搜索的部署"><a href="#搜索的部署" class="headerlink" title="搜索的部署"></a>搜索的部署</h2><h3 id="一、部署集群"><a href="#一、部署集群" class="headerlink" title="一、部署集群"></a>一、部署集群</h3><p>user用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch_bak.zip#解压引擎文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认的配置文件</span></span><br><span class="line">cd elasticsearch_bak/config</span><br><span class="line">vi elasctsearch.yml</span><br><span class="line">cluster.name: es-zl#修改集群名，所有节点配置的该名称必须一样</span><br><span class="line">node.name: es-46#修改每个节点的名称，必须不同，以区分每个节点</span><br><span class="line">node.master:true#是否可作为主节点</span><br><span class="line">path.data: /data/es_data#es数据存放的位置</span><br><span class="line">network.host:127.17.30.46#每个节点的ip地址</span><br><span class="line">http.port: 9200#节点的端口，必须相同，默认9200</span><br><span class="line"></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line">bootstrap.system_call_filter: false#内存锁定，防止swap使es产生内存交互</span><br><span class="line">discovery.zen.ping.unicast.hosts:[&quot;127.17.30.44&quot;,&quot;127.17.30.45&quot;,,]#集群master节点的ip，不需要所有节点的ip，其他节点只要能与任意一个master节点通讯，即可加入到该集群当中</span><br><span class="line">discovery.zen.minimum_master_nodes:2#当2个有资格成为主节点的从节点认为主节点挂了，则进行重新选主，一般设置为(n/2)+1，防止es出现脑裂情况</span><br><span class="line">gateway.recover_after_nodes: 3#节点数量达到多少之后，进行数据恢复处理</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">vi yvm.options</span><br><span class="line">-Xms16g#默认为2g，可根据服务器内存，自行修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过一下命令查看内存</span></span><br><span class="line">cat /proc/cpuinfo | grep &#x27;cpu cores&#x27; | wc -l#查看cpu核数</span><br><span class="line">cat /proc/meminfo | grep MemTotal#只查看内存</span><br><span class="line">free -h#查看内存的使用</span><br><span class="line">df -h#查看硬盘存储</span><br></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><p>​    该操作必须在每台服务器上都要部署，并不能在root用户下操作，要在user下操作，如果没有usr用户，则创建</p><h5 id="如果没有操作权限，则执行："><a href="#如果没有操作权限，则执行：" class="headerlink" title="如果没有操作权限，则执行："></a>如果没有操作权限，则执行：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root下，将文件权限设置为duser用户可操作</span></span><br><span class="line">chown duser *</span><br><span class="line">chgrp duser *</span><br></pre></td></tr></table></figure><h4 id="当不使用es远程词典时："><a href="#当不使用es远程词典时：" class="headerlink" title="当不使用es远程词典时："></a>当不使用es远程词典时：</h4><p>修改elasticsearch-5.3.0/plugins/ik/config/IKAnalyzer.cfg.xml </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>custom/mydict.dic;custom/single_word_low_freq.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>custom/ext_stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;http://10.172.80.229:9301/mydict.dic&lt;/entry&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;http://10.172.80.229:9301/stopword.dic&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>​    注释后两项即可</p><h5 id="添加自定义同义词"><a href="#添加自定义同义词" class="headerlink" title="添加自定义同义词"></a>添加自定义同义词</h5><p>替换config/synonyms.txt文件</p><p>synonyms.txt文件内格式，所有同义词为一行，且用 “, ” 隔开</p><h3 id="二、修改集群配置"><a href="#二、修改集群配置" class="headerlink" title="二、修改集群配置"></a>二、修改集群配置</h3><p>root用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一下语句</span></span><br><span class="line">*      soft    nofile    65536</span><br><span class="line">*      hard    nofile    65536</span><br><span class="line">*      soft   nproc     65536</span><br><span class="line">*   hard   nproc 65536</span><br><span class="line">duser  soft    memlock   unlimited </span><br><span class="line">    duser  hard    memlock   unlimited </span><br><span class="line"></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改以下语句</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h3 id="三、启动集群"><a href="#三、启动集群" class="headerlink" title="三、启动集群"></a>三、启动集群</h3><p>user用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch_bak/bin</span><br><span class="line">./elasticsearch  -d#后台启动集群</span><br><span class="line">curl 172.17.30.45:9200/_cat/nodes#查看所有节点，*为主节点</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动不了时候，查看es-log</span></span><br></pre></td></tr></table></figure><h3 id="四、搜索部署"><a href="#四、搜索部署" class="headerlink" title="四、搜索部署"></a>四、搜索部署</h3><p>user用户下的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi index_search_mapping.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">修改的ip和端口与集群一样</span></span><br><span class="line">curl -XPUT &quot;http://10.25.114.90:9200/index&quot; </span><br><span class="line">&#123;</span><br><span class="line">        settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 6,#主分片数量，一般为 服务器总核数</span><br><span class="line">        &quot;number_of_replicas&quot;: 2,#副本分片的数量，防止数据丢失</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><p>​    分词器anslyzer可以根据实际情况进行修改、删除和添加</p><h4 id="添加删除字段"><a href="#添加删除字段" class="headerlink" title="添加删除字段"></a>添加删除字段</h4><p>​    当需要添加字段时，只要在以下位置添加即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">  &quot;id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">       &quot;&quot;: &#123;#需要添加的字段名</span><br><span class="line">           &quot;type&quot;:&quot;&quot;#添加的字段的约束条件</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h5 id="注意：-5"><a href="#注意：-5" class="headerlink" title="注意："></a>注意：</h5><p>​    修改某个文件的字段之前，需要先删除该文件的core</p><p>​    重新启动搜索时，也需要进行以下步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE &quot;http://172.19.30.45:9200/index&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">修改完之后，重新运行该文件</span></span><br><span class="line">sh index_search_mapping.sh</span><br></pre></td></tr></table></figure><h3 id="五、查询启动结果"><a href="#五、查询启动结果" class="headerlink" title="五、查询启动结果"></a>五、查询启动结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip:9200/index?pretty#查询字段</span><br><span class="line">curl http://ip:9200/_cat/nodes#查询节点</span><br><span class="line">curl http://ip:9200/_cat/health#查询加群健康，green</span><br><span class="line">curl http://ip:9200/_cat/shards#查询集群分片状态</span><br></pre></td></tr></table></figure><h3 id="六、数据量查询"><a href="#六、数据量查询" class="headerlink" title="六、数据量查询"></a>六、数据量查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip:9200/one_index/_stats#查询某一个index下的数据量</span><br><span class="line">curl http://ip:9200/one_index,two_index/_stats#查询多个index的数据量，使用,隔开</span><br><span class="line">curl http://ip:9200/_all/_stats#查询所有index下的数据量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回search、fetch、get、index、bulk、segment、counts</span></span><br><span class="line"></span><br><span class="line">curl http://ip:9200/_cat/count/index#只查询某个index下的文档数，如果不加index，则查询所有的index的文档总数</span><br></pre></td></tr></table></figure><h3 id="七、search-guard为es集群配置auth"><a href="#七、search-guard为es集群配置auth" class="headerlink" title="七、search-guard为es集群配置auth"></a>七、search-guard为es集群配置auth</h3><h4 id="1、安装search-guard插件和ssl插件"><a href="#1、安装search-guard插件和ssl插件" class="headerlink" title="1、安装search-guard插件和ssl插件"></a>1、安装search-guard插件和ssl插件</h4><h5 id="查询es的版本"><a href="#查询es的版本" class="headerlink" title="查询es的版本"></a>查询es的版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl ip:9200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果中的number数据即代表版本号</span></span><br></pre></td></tr></table></figure><h5 id="安装search-guard"><a href="#安装search-guard" class="headerlink" title="安装search-guard"></a>安装search-guard</h5><p><a href="https://repo1.maven.org/maven2/com/floragunn/search-guard-5">https://repo1.maven.org/maven2/com/floragunn/search-guard-5</a></p><p>找到对应的版本，下载即可</p><p>或者使用命令行下载，es目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-plugin install -b com.floragunn:search-guard-5:5.3.0-12</span><br></pre></td></tr></table></figure><h5 id="安装search-guard-ssl"><a href="#安装search-guard-ssl" class="headerlink" title="安装search-guard-ssl"></a>安装search-guard-ssl</h5><p><a href="https://repo1.maven.org/maven2/com/floragunn/search-guard-ssl">https://repo1.maven.org/maven2/com/floragunn/search-guard-ssl</a></p><p>命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-plugin install -b com.floragunn:search-guard-ssl:5.3.0-22</span><br></pre></td></tr></table></figure><h5 id="注意：-6"><a href="#注意：-6" class="headerlink" title="注意："></a>注意：</h5><p>当es版本较高时，可能并不需要这两个都存在，取search-guard即可</p><h4 id="2、生成es证书文件"><a href="#2、生成es证书文件" class="headerlink" title="2、生成es证书文件"></a>2、生成es证书文件</h4><h5 id="下载search-guard源码工具，生成证书的工具"><a href="#下载search-guard源码工具，生成证书的工具" class="headerlink" title="下载search-guard源码工具，生成证书的工具"></a>下载search-guard源码工具，生成证书的工具</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/floragunncom/search-guard-ssl.git</span><br></pre></td></tr></table></figure><h5 id="修改ca配置"><a href="#修改ca配置" class="headerlink" title="修改ca配置"></a>修改ca配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd search-guard-ssl/example-pki-scripts/etc/</span><br><span class="line"></span><br><span class="line">vi root-ca.conf# 根证书配置</span><br><span class="line">0.domainComponent       = &quot;www.test.com”    # 域名</span><br><span class="line">1.domainComponent       = &quot;www.test.com&quot;    # 域名</span><br><span class="line">organizationName        = &quot;Test&quot;            # 组织名称</span><br><span class="line">organizationalUnitName  = &quot;Test Root CA&quot;    # 组织单位名称</span><br><span class="line">commonName              = &quot;Test Root CA&quot;    # 通用名称</span><br><span class="line"></span><br><span class="line">vi signing-ca.conf# 签名证书配置</span><br><span class="line">0.domainComponent       = &quot;www.test.com”    # 域名</span><br><span class="line">1.domainComponent       = &quot;www.test.com&quot;    # 域名</span><br><span class="line">organizationName        = &quot;Test&quot;            # 组织名称</span><br><span class="line">organizationalUnitName  = &quot;Test Signing CA&quot; # 组织单位名称</span><br><span class="line">commonName              = &quot;Test Signing CA&quot; # 通用名称</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    以上信息填写，必须保证和生成证书时信息一致</p><h5 id="修改sh文件"><a href="#修改sh文件" class="headerlink" title="修改sh文件"></a>修改sh文件</h5><p>返回example-pki-scripts目录下，修改example.sh文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">./clean.sh</span><br><span class="line"></span><br><span class="line">./gen_root_ca.sh 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_node_cert.sh 0 12345678 12345678&amp;&amp; ./gen_node_cert.sh 1 12345678 12345678 &amp;&amp;  ./gen_node_cert.sh 2 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_client_node_cert.sh <span class="built_in">test</span> 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_client_node_cert.sh <span class="built_in">test</span> 12345678 12345678</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>./gen_root_ca.sh 12345678 12345678</p><p>第一个参数为CA_PASS，即CA密码（根证书密码）</p><p>第二个参数为TS_PASS，即TS密码（truststore，信任证书密码）</p><p>./gen_node_cert.sh 0 12345678 12345678</p><p>第一个参数为node编号，生成证书后的文件名为node-0*</p><p>第二个参数为KS_PASS（keystore文件密码）</p><p>第三个参数为CA_PASS</p><p>./gen_client_node_cert.sh test 12345678</p><p>第一个参数为客户端节点名称，生成证书后的文件名为test*</p><p>第二个参数为KS_PASS</p><p>第三个参数为CA_PASS</p><h5 id="生成证书，运行example-sh"><a href="#生成证书，运行example-sh" class="headerlink" title="生成证书，运行example.sh"></a>生成证书，运行example.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh example.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下会生成证书文件</span></span><br></pre></td></tr></table></figure><h4 id="3、配置es，启动search-guard"><a href="#3、配置es，启动search-guard" class="headerlink" title="3、配置es，启动search-guard"></a>3、配置es，启动search-guard</h4><h5 id="将生成的各个节点的证书，分别copy到各个节点上"><a href="#将生成的各个节点的证书，分别copy到各个节点上" class="headerlink" title="将生成的各个节点的证书，分别copy到各个节点上"></a>将生成的各个节点的证书，分别copy到各个节点上</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将node-0-keystore.jks和truststore.jks复制到es的config目录下</span></span><br><span class="line"></span><br><span class="line">cp node-0-keystore.jks ~/elasticsearch/config/</span><br><span class="line">cp truststore.jks ~/elasticsearch/config/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将test-keystore.jks和truststore.jks复制到es的plugins/search-guard-2/sgconfig目录下</span></span><br><span class="line"></span><br><span class="line">cp test-keystore.jks ~/elasticsearch/plugins/search-guard-2/sgconfig/</span><br><span class="line">cp truststore.jks ~/elasticsearch/plugins/search-guard-2/sgconfig/</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    保持证书的一致性，因此只需要在一台机器上生成CA证书即可</p><h5 id="修改es的配置文件config-elaticsearch-yml"><a href="#修改es的配置文件config-elaticsearch-yml" class="headerlink" title="修改es的配置文件config/elaticsearch.yml"></a>修改es的配置文件config/elaticsearch.yml</h5><p>在之前修改的基础上，增加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置ssl</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_filepath:</span> <span class="string">node-0-keystore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_filepath:</span> <span class="string">truststore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.enforce_hostname_verification:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.resolve_hostname:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置https</span></span><br><span class="line"><span class="comment"># http配置，这里我只是为了测试方便，配置完，应该设置为true</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.keystore_filepath:</span> <span class="string">node-0-keystore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.keystore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.truststore_filepath:</span> <span class="string">truststore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.truststore_password:</span> <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CN为生成CA证书时填写的信息，即./gen_client_node_cert.sh test 12345678 命令的第一个参数</span></span><br><span class="line"><span class="attr">searchguard.authcz.admin_dn:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">CN=test,</span> <span class="string">OU=client,</span> <span class="string">O=client,</span> <span class="string">L=Test,</span> <span class="string">C=DE</span></span><br></pre></td></tr></table></figure><h5 id="启动es"><a href="#启动es" class="headerlink" title="启动es"></a>启动es</h5><h4 id="4、将search-guard的配置写入es中"><a href="#4、将search-guard的配置写入es中" class="headerlink" title="4、将search-guard的配置写入es中"></a>4、将search-guard的配置写入es中</h4><p>添加权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 plugins/search-guard-5/tools/sgadmin.sh</span><br></pre></td></tr></table></figure><p>配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn clustername -h hostname -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/admin-keystore.jks -kspass password -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass password -nhnv</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    clustername为集群的名称</p><p>​    hostname为elasticsearch.yml 文件中 network.host 的值</p><p>​    password生成证书设置的密码</p><h5 id="以上配置生成的命令为"><a href="#以上配置生成的命令为" class="headerlink" title="以上配置生成的命令为"></a>以上配置生成的命令为</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn es-nlp -h 192.168.124.18 -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/test-keystore.jks -kspass 12345678 -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass 12345678 -nhnv</span><br></pre></td></tr></table></figure><h4 id="5、添加es用户及密码"><a href="#5、添加es用户及密码" class="headerlink" title="5、添加es用户及密码"></a>5、添加es用户及密码</h4><h5 id="生成md5加密密码"><a href="#生成md5加密密码" class="headerlink" title="生成md5加密密码"></a>生成md5加密密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 plugins/search-guard-2/tools/hash.sh</span><br><span class="line"></span><br><span class="line">cd plugins/search-guard-2/tools/</span><br><span class="line"></span><br><span class="line">plugins/search-guard-2/tools/hash.sh -p 123456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存生成的<span class="built_in">hash</span>密码</span></span><br></pre></td></tr></table></figure><h5 id="添加用户及密码"><a href="#添加用户及密码" class="headerlink" title="添加用户及密码"></a>添加用户及密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim plugins/search-guard-5/sgconfig/sg_internal_users.yml</span><br><span class="line"></span><br><span class="line">sunww:</span><br><span class="line">  hash: 加密后的字符串</span><br><span class="line"><span class="meta">  #</span><span class="bash"> password: 123456</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后一行时password提示，防止忘记</span></span><br></pre></td></tr></table></figure><h5 id="添加用户的权限"><a href="#添加用户的权限" class="headerlink" title="添加用户的权限"></a>添加用户的权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim plugins/search-guard-5/sgconfig/sg_roles_mapping.yml</span><br><span class="line"></span><br><span class="line">ag_all_access:</span><br><span class="line">  users:</span><br><span class="line">    - admin</span><br><span class="line">    - sunww</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有权限给sunww用户</span></span><br></pre></td></tr></table></figure><h5 id="重新将配置写入es中生效"><a href="#重新将配置写入es中生效" class="headerlink" title="重新将配置写入es中生效"></a>重新将配置写入es中生效</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn es-nlp -h 192.168.124.18 -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/test-keystore.jks -kspass 12345678 -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass 12345678 -nhnv</span><br></pre></td></tr></table></figure><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl http://sunww:123456@127.0.0.1:9200</span><br><span class="line"></span><br><span class="line">curl -u sunww:123456 http://127.0.0.1:9200</span><br><span class="line"></span><br><span class="line">curl --user sunww:123456 http://127.0.0.1:9200</span><br></pre></td></tr></table></figure><h3 id="八、x-pack为es集群配置auth"><a href="#八、x-pack为es集群配置auth" class="headerlink" title="八、x-pack为es集群配置auth"></a>八、x-pack为es集群配置auth</h3><h5 id="1、要求"><a href="#1、要求" class="headerlink" title="1、要求"></a>1、要求</h5><p>es的版本必须为6.X及以上，5.X的es配置x-pack只能通过api修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.3.tar.gz</span><br></pre></td></tr></table></figure><h5 id="2、安装x-pack"><a href="#2、安装x-pack" class="headerlink" title="2、安装x-pack"></a>2、安装x-pack</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install x-pack</span><br></pre></td></tr></table></figure><h5 id="3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash-system，kibana用户名为kibana）"><a href="#3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash-system，kibana用户名为kibana）" class="headerlink" title="3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash_system，kibana用户名为kibana）"></a>3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash_system，kibana用户名为kibana）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/x-pack/setup-passwords interactive</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    此时的es必须时启动状态</p><h5 id="4、配置-config-elasticsearch-yml"><a href="#4、配置-config-elasticsearch-yml" class="headerlink" title="4、配置./config/elasticsearch.yml"></a>4、配置./config/elasticsearch.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># es6.X配置：</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">Authorization,X-Requested-With,Content-Length,Content-Type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es5.X配置</span></span><br><span class="line"><span class="string">xpack.graph.enabled</span><span class="comment">#设置为false以禁用X-Pack图形功能。</span></span><br><span class="line"><span class="string">xpack.ml.enabled</span><span class="comment">#设置为false以禁用X-Pack机器学习功能。</span></span><br><span class="line"><span class="string">xpack.monitoring.enabled</span><span class="comment">#设置为false以禁用X-Pack监视功能。</span></span><br><span class="line"><span class="string">xpack.reporting.enabled</span>     <span class="comment">#设置为false以禁用X-Pack报告功能。</span></span><br><span class="line"><span class="string">xpack.security.enabled</span>      <span class="comment">#设置为false以禁用X-Pack安全功能。</span></span><br><span class="line"><span class="string">xpack.watcher.enabled</span>       <span class="comment">#设置为false以禁用Watcher。</span></span><br></pre></td></tr></table></figure><h5 id="5、测试访问"><a href="#5、测试访问" class="headerlink" title="5、测试访问"></a>5、测试访问</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u elastic:password ip:port</span><br></pre></td></tr></table></figure><h5 id="6、x-pack默认账号密码"><a href="#6、x-pack默认账号密码" class="headerlink" title="6、x-pack默认账号密码"></a>6、x-pack默认账号密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：elastic</span><br><span class="line">密码：changeme</span><br></pre></td></tr></table></figure><h5 id="注意：-7"><a href="#注意：-7" class="headerlink" title="注意："></a>注意：</h5><p>​    x-pack只有一个月的使用时间，适合poc使用</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume</title>
      <link href="/blog/2019/08/12/Flume/"/>
      <url>/blog/2019/08/12/Flume/</url>
      
        <content type="html"><![CDATA[<h1 id="Flume简介"><a href="#Flume简介" class="headerlink" title="Flume简介"></a>Flume简介</h1><p>Flume是由cloudera软件公司产出的可分布式日志收集系统，后与2009年被捐赠了Apache软件基金会，为Hadoop相关组件之一。尤其近几年随着Flume的不断完善以及升级版本的逐一推出，特别是Flume-ng;同时Flume内部的各种组件不断丰富，用户再开发的过程中使用的便利性得到很大的改善，现已成为Apache top项目之一。</p><h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><ul><li>定义：Apache Flume是一个从可以收集例如日志，事件等数据资源，并将这些数量庞大的数据从各项数据资源中集中起来存储的工具/服务，或者数集中机制;Flume是分布式的日志收集系统，它将各个服务器中的数据收集起来并送到目的地。</li></ul><p><img src="/blog/img/Flume_1.png"></p><h3 id="Flume结构"><a href="#Flume结构" class="headerlink" title="Flume结构"></a>Flume结构</h3><p>Flume内部有一个或者多个Agent，然而对于每一个Agent来说，它就是一共独立的守护进程(JVM),它从客户端哪儿接收收集，或者从其他的Agent哪儿接收，然后迅速的将获取的数据传给下一个目的节点sink，或者Agent</p><ul><li>Flume的外部结构：</li></ul><p><img src="/blog/img/Flume_2.png"></p><ul><li>Flume的Agent(主要由：source、channel、sink三个组件组成)</li></ul><p><img src="/blog/img/Flume_3.png"></p><ul><li><strong>Source</strong>:采集源，用于跟数据源对接，以获取数据<ul><li>从数据发生器接收数据，并将接收的数据以Flume的<strong>event格式</strong>传递给一个或者多个通道channal，Flume提供多种数据接收的方式，比如Avro、Thrift等</li></ul></li><li><strong>Channel</strong>：存储容器，它将从source处接收到的event格式的数据缓存起来，直到它们被sinks消费掉<ul><li>channel是一个完整的事务，这一点保证了数据在收发的时候的一致性，并且它可以和任意数量的source和sink链接，支持的类型有：JDBC channel，File System channel、Memort channel等</li></ul></li><li><strong>Sink</strong>：下沉地，采集数据的传送目的地，用于往下一级Agent传递数据或者最终存储系统传递数据<ul><li>sink将数据存储到集中存储器比如HBase和HDFS，它从channels消费数据(events)并将其传递给目标地</li></ul></li><li>Flume就是将数据从数据源(source)收集过来，Flume会先缓存数据到channel，再将收集到的数据送到指定的目的地(sink)，最后Flume在删除自己缓存的数据</li></ul><h3 id="Flume事件"><a href="#Flume事件" class="headerlink" title="Flume事件"></a>Flume事件</h3><p>事件作为Flume内部数据传输的最基本单元，它是由一个转载数据的字节数组(该数据组是从数据源接入点传入，并传输给传输器，也就是HDFS/HBase和一个可选头部构成</p><p><img src="/blog/img/Flume_4.png"></p><p>一个完整的event包括：event header、event body信息，其中event信息就是Flume收集到的日志记录</p><ul><li>event将传输的数据进行封装。如果是文本文件，通常是一行记录，event也是十五的基本单位。event从source，流向chanel，再到sink，本身为一个字节数组，并可携带headers(头信息)信息，event代表着一个数据的最小完整单元，从外部数据源来，向外部的目的地去。</li></ul><h3 id="Flume采集结构图"><a href="#Flume采集结构图" class="headerlink" title="Flume采集结构图"></a>Flume采集结构图</h3><ul><li>单Agent采集数据</li></ul><p><img src="/blog/img/Flume_5.png"></p><ul><li>单Agent多Sink</li></ul><p><img src="/blog/img/Flume_6png.png"></p><ul><li>多Agent</li></ul><p><img src="/blog/img/Flume_7.png"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>前置条件<ul><li>Java 1.7 or later</li><li>为sources，channels和sinks提供充足的内存</li><li>为channles提供充足的磁盘空间</li><li>为agent提供读和写权限</li></ul></li><li>Flume 的安装非常简单，上传安装包到数据源所在节点上然后解压 <code>tar -zxvf apache-flume-1.9.0-bin.tar.gz</code>，然后进入 flume 的目录，修改 conf 下的 flume-env.sh，在里面配置 JAVA_HOME。配置flume环境变量：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi ~&#x2F;.bash_profile</span><br><span class="line">export FLUME_HOME&#x3D;&#x2F;root&#x2F;bigdata&#x2F;flume&#x2F;bin</span><br><span class="line">export PATH&#x3D;$FLUME_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">source &#x2F;root&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>检查是否配置成功：flume-ng version查看flume版本。根据数据采集需求<strong>配置采集方案</strong>，描述在配置文件中(文件名可任意自定义)</p><h1 id="Flume使用"><a href="#Flume使用" class="headerlink" title="Flume使用"></a>Flume使用</h1><p>在Flume配置文件中，需要</p><ul><li>需要命名当前使用的Agent的名称</li><li>命名Agent下的source的名字</li><li>命名Agent下的channel的名字</li><li>命名Agent下的sink的名字</li><li>将source和sink通过channel绑定起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 为source、channel、sink命名</span><br><span class="line">a1.sources &#x3D; r1</span><br><span class="line">a1.sinks &#x3D; k1</span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line"># 定义采集源</span><br><span class="line">a1.sources.r1.type &#x3D; netcat</span><br><span class="line">a1.sources.r1.bind &#x3D; 127.0.0.1</span><br><span class="line">a1.sources.r1.port &#x3D; 44444</span><br><span class="line"></span><br><span class="line"># 定义下沉地</span><br><span class="line">a1.sinks.k1.type &#x3D; logger</span><br><span class="line"></span><br><span class="line"># 定义channel</span><br><span class="line">a1.channels.c1.type &#x3D; memory</span><br><span class="line">a1.channels.c1.capacity &#x3D; 1000</span><br><span class="line">a1.channels.c1.transactionCapacity &#x3D; 100</span><br><span class="line"></span><br><span class="line"># 把source、sink通过channel连接起来</span><br><span class="line">a1.sources.r1.channels &#x3D; c1</span><br><span class="line">a1.sinks.k1.channel &#x3D; c1</span><br></pre></td></tr></table></figure><p><strong>启动agent命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flume-ng路径 -c conf -f 上方配置文件路径 -n a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><ul><li>-c conf:指定Flume自身的配置文件</li><li>-f conf/netcat-logger.conf:指定我们所描述的采集方案</li><li>-n a1:指定Agent的名字</li></ul><p><strong>测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 44444</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">19/06/26 17:27:25 INFO sink.LoggerSink: Event: &#123; headers:&#123;&#125; body: 31 32 33 34 0D                                  1234. &#125;</span><br></pre></td></tr></table></figure><h3 id="Flume可选配置参数"><a href="#Flume可选配置参数" class="headerlink" title="Flume可选配置参数"></a>Flume可选配置参数</h3><ul><li>Flume支持各种各样的source，sinks，channels，它们支持的类型如下：</li></ul><p><img src="/blog/img/Flume_8.png"></p><ul><li><strong>Source</strong><ul><li>Avro Source序列化数据源</li><li>ThriftSource序列化数据源</li><li>Exec Source 执行Linux命令行的数据源</li><li>NETCAT Source通过指定端口，ip监控的数据源</li><li>Kafka Source直接对接Kafka的数据源</li><li>自定义Source</li></ul></li><li><strong>Channel</strong><ul><li>Memory Channel 内存</li><li>File Channel 磁盘</li><li>Kafka Channel 存在kafka</li><li>JDBC Channel</li></ul></li><li><strong>Sink</strong><ul><li>HDFS Sink写入到HDFS</li><li>Hive Sink 写入到Hive</li><li>Avro Sink 写入到序列化</li><li>HBase Sinks写入到HBase<ul><li>HBase Sink 同步写入到HBase</li><li>Async HBase Sink 异步写入到HBase</li></ul></li></ul></li></ul><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><ul><li>Source</li><li>Channel</li><li>Sink</li></ul><p>一般Flume中会存在多个Agent，所以需要分别取名字来区分他们，名字不能重复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Agent取名为 agent_name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span> 取名为 source_name ,一次类推</span></span><br><span class="line">agent_name.source = source_name ,source_name1</span><br><span class="line">agent_name.channels = channel_name,channel_name1</span><br><span class="line">agent_name.sinks = sink_name,sink_name1</span><br></pre></td></tr></table></figure><ul><li><strong>Source的配置</strong>(都需要单独做配置)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">agent_name.sources. source_name.type &#x3D; value </span><br><span class="line">agent_name.sources. source_name.property2 &#x3D; value </span><br><span class="line">agent_name.sources. source_name.property3 &#x3D; value</span><br></pre></td></tr></table></figure><ul><li><strong>Channels的配置</strong>(都需要单独做配置)</li></ul><p>Flume在source和sink配间提供各种管道来传递数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">agent_name.channels.channel_name.type = value </span><br><span class="line">agent_name.channels.channel_name. property2 = value </span><br><span class="line">agent_name.channels.channel_name. property3 = value</span><br></pre></td></tr></table></figure><ul><li><strong>Sink的配置</strong>（都需要单独配置）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">agent_name.sinks. sink_name.type = value </span><br><span class="line">agent_name.sinks. sink_name.property2 = value </span><br><span class="line">agent_name.sinks. sink_name.property3 = value</span><br></pre></td></tr></table></figure><ul><li><strong>连接配置</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">agent_name.sources.source_name.channels = channel_name</span><br><span class="line">agent_name.sinks.sink_name.channels =  channel_name</span><br></pre></td></tr></table></figure><h3 id="Flume配置参数"><a href="#Flume配置参数" class="headerlink" title="Flume配置参数"></a>Flume配置参数</h3><ul><li><strong>source</strong><ul><li>Avro：监听Avro端口，从Avro client streams接收events。Avro Source被设计为高扩展的RPC服务器，能从其他的Flume Agent的Avro Sink或者使用Flume的SDK发生数据的客户端应用，接受数据到一个Flume Agent中</li><li>利用Avro Source可以实现多级流动，扇出流，扇入流等效果。另外也可以接受通过Flume提供Avro客户端发送日志信息</li></ul></li></ul><p><img src="/blog/img/Flume_9.png"></p><p><strong>Thrift Source</strong></p><p>ThriftSource 与Avro Source 基本一致。只要把source的类型改成thrift即可，例如a1.sources.r1.type = thrift，比较简单。</p><p><strong>Spooling Directory Source</strong> Spooling Directory Source监测配置的目录下新增的文件，并将文件中的数据读取出来。其中，Spool Source有2个注意地方，第一个是拷贝到spool目录下的文件不可以再打开编辑，第二个是spool目录下不可包含相应的子目录。这个主要用途作为对日志的准实时监控。可选参数过多，不展示。</p><ul><li>spooldir监控目录配置示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#监控指定的目录，如果有新文件产生，那么将文件的内容显示到控制台  </span><br><span class="line">#配置一个agent agent的名称可以自定义  </span><br><span class="line">#指定agent的 sources，sinks，channels  </span><br><span class="line">#分别指定 agent的 sources，sinks，channels 的名称 名称可以自定义  </span><br><span class="line">a1.sources&#x3D;s1  </span><br><span class="line">a1.channels&#x3D;c1  </span><br><span class="line">a1.sinks&#x3D;k1  </span><br><span class="line"></span><br><span class="line">#配置 source 根据 agent的 sources 的名称来对 source 进行配置  </span><br><span class="line">#source 的参数是根据 不同的数据源 配置不同---在文档查找即可  </span><br><span class="line">#配置目录 source  flume这个文件夹用于存储需要读取的文件  </span><br><span class="line">a1.sources.s1.type&#x3D;spooldir  </span><br><span class="line">a1.sources.s1.spoolDir&#x3D;&#x2F;home&#x2F;hadoop&#x2F;apps&#x2F;apache-flume-1.8.0-bin&#x2F;flume  </span><br><span class="line"></span><br><span class="line">#配置 channel 根据 agent的 channels的名称来对 channels 进行配置  </span><br><span class="line">#配置内存 channel  </span><br><span class="line">a1.channels.c1.type&#x3D;memory  </span><br><span class="line"></span><br><span class="line">#配置 sink 根据 agent的sinks 的名称来对 sinks 进行配置  </span><br><span class="line">#配置一个 logger sink  </span><br><span class="line">a1.sinks.k1.type&#x3D;logger  </span><br><span class="line"></span><br><span class="line">#绑定 特别注意 source的channel 的绑定有 s,sink的 channel的绑定没有 s  </span><br><span class="line">a1.sources.s1.channels&#x3D;c1  </span><br><span class="line">a1.sinks.k1.channel&#x3D;c1</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h3 id="从A服务器到B服务器"><a href="#从A服务器到B服务器" class="headerlink" title="从A服务器到B服务器"></a>从A服务器到B服务器</h3><ul><li>需求：将A服务器中日志实时采集到B服务器<ul><li>A服务器：监控一个文件实时采集新增的数据输出B服务器</li><li>B服务器：从指定网络端口采集数据输出到控制台</li></ul></li></ul><p><strong>A服务器conf</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名</span></span><br><span class="line">a.sources = a_source</span><br><span class="line">a.sinks = a_sink</span><br><span class="line">a.channels = memory-channel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义source</span></span><br><span class="line">a.sources.a_source.<span class="built_in">type</span> = <span class="built_in">exec</span></span><br><span class="line">a.sources.a_source.command = tail -F /root/logs/collect.log</span><br><span class="line">a.sources.a_source.shell = /<span class="built_in">bin</span>/sh -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义sink</span></span><br><span class="line">a.sinks.a_sink.<span class="built_in">type</span> = avro</span><br><span class="line">a.sinks.a_sink.hostname = A_IP</span><br><span class="line">a.sinks.a_sink.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义channel类型</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.channels.memory-channel.<span class="built_in">type</span> = memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接source和sink</span></span><br><span class="line">a.sources.a_source.channels = memory-channel</span><br><span class="line">a.sinks.a_sink.channel = memory-channel</span><br></pre></td></tr></table></figure><p><strong>B服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名</span></span><br><span class="line">b.sources = b_source</span><br><span class="line">b.sinks = b_sink</span><br><span class="line">b.channels = memory-channel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义source</span></span><br><span class="line">b.sources.b_source.<span class="built_in">type</span> = avro</span><br><span class="line">b.sources.b_source.bind = B_IP</span><br><span class="line">b.sources.b_source.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义sink</span></span><br><span class="line">avro-memory-logger.sinks.logger-sink.<span class="built_in">type</span> = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义channel类型</span></span><br><span class="line">avro-memory-logger.channels.memory-channel.<span class="built_in">type</span> = memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接source和sink</span></span><br><span class="line">b.sources.b_source.channels = memory-channel</span><br><span class="line">b.sinks.b_sink.channel = memory-channel</span><br></pre></td></tr></table></figure><p><strong>先启动B，再启动A</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> B</span></span><br><span class="line">/root/bigdata/flume/bin/flume-ng agent --conf conf --conf-file /root/bigdata/flume/conf/b.conf --name b -Dflume.root.logger=INFO,console</span><br><span class="line"><span class="meta">#</span><span class="bash"> A</span></span><br><span class="line">/root/bigdata/flume/bin/flume-ng agent --conf conf --conf-file /root/bigdata/flume/conf/a.conf --name a -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><h3 id="采集目录到HDFS中"><a href="#采集目录到HDFS中" class="headerlink" title="采集目录到HDFS中"></a>采集目录到HDFS中</h3><p>采集需求：服务器特定目录下，会不断产生新文件，每当有新文件出现，就需要把文件采集到HDFS中去</p><ul><li>采集源：<strong>spooldir</strong></li><li>下沉目标：<strong>hdfs sink</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#命名</span><br><span class="line">exec-memory-hdfs.sources &#x3D; exec-source</span><br><span class="line">exec-memory-hdfs.sinks &#x3D; hdfs-sink</span><br><span class="line">exec-memory-hdfs.channels &#x3D; memory-channel</span><br><span class="line"></span><br><span class="line"># 定义source</span><br><span class="line">exec-memory-hdfs.sources.exec-source.type &#x3D; exec</span><br><span class="line">exec-memory-hdfs.sources.exec-source.command &#x3D; tail -F &#x2F;root&#x2F;logs&#x2F;collect.log</span><br><span class="line">exec-memory-avro.sources.exec-source.shell&#x3D;&#x2F;bin&#x2F;sh -c</span><br><span class="line"></span><br><span class="line"># 定义sink </span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.type &#x3D; hdfs</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.path &#x3D; hdfs:&#x2F;&#x2F;IP:9000&#x2F;headlines&#x2F;events&#x2F;%Y-%m-%d&#x2F;</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.filePrefix &#x3D; events-</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.round &#x3D; true</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.roundValue &#x3D; 10</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.roundUnit &#x3D; minute</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.rollInterval &#x3D; 3</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.rollSize &#x3D; 20</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.rollCount &#x3D; 5</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.batchSize &#x3D; 1</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.useLocalTimeStamp &#x3D; true</span><br><span class="line">#生成的文件类型，默认是 Sequencefile，可用 DataStream，则为普通文本 </span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.hdfs.fileType &#x3D; DataStream</span><br><span class="line"></span><br><span class="line"># 定义channel</span><br><span class="line">exec-memory-hdfs.channels.memory-channel.type &#x3D; memory</span><br><span class="line">exec-memory-hdfs.channels.memory-channel.capacity &#x3D; 1000</span><br><span class="line">exec-memory-hdfs.channels.memory-channel.transactionCapacity &#x3D; 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 连接source和sink</span><br><span class="line">exec-memory-hdfs.sources.exec-source.channels &#x3D; memory-channel</span><br><span class="line">exec-memory-hdfs.sinks.hdfs-sink.channel &#x3D; memory-channel</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">&#x2F;root&#x2F;bigdata&#x2F;flume&#x2F;bin&#x2F;flume-ng agent --conf conf --conf-file &#x2F;root&#x2F;bigdata&#x2F;flume&#x2F;conf&#x2F;spool-memory-hdfs.conf --name exec-memory-hdfs -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure><ul><li>channel参数解释：<ul><li>capacity：默认该通道中最大的可以存储的 event 数量</li><li>trasactionCapacity：每次最大可以从 source 中拿到或者送到 sink 中的 event数量</li></ul></li><li>sinks参数解析：<ul><li>rollInterval：默认值：30<ul><li>hdfs sink 间隔多长将临时文件滚动成最终目标文件，单位：秒；如果设置成 0，则表示不根据时间来滚动文件；注：滚动（roll）指的是，hdfs sink 将临时文件重命名成最终目标文件，并新打开一个临时文件来写入数据；</li></ul></li><li>rollSize:默认值：1024<ul><li>当临时文件达到该大小（单位：bytes）时，滚动成目标文件；如果设置成 0，则表示不根据临时文件大小来滚动文件；</li></ul></li><li>rollCount：默认值：10，当 events 数据达到该数量时候，将临时文件滚动成目标文件；如果设置成 0，则表示不根据 events 数据来滚动文件；</li><li>round：默认值：false，是否启用时间上的“舍弃”，这里的“舍弃”，类似于“四舍五入”。</li><li>roundValue：默认值：1时间上进行“舍弃”的值；</li><li>roundUnit：默认值：seconds，时间上进行“舍弃”的单位，包含：second,minute,hour</li><li>exec-memory-hdfs.sinks.hdfs-sink.hdfs.useLocalTimeStamp = true：添加时间戳，创建文件可以使用时间(也可以通过FLume的拦截器插件实现)</li></ul></li></ul><h1 id="Flume插件"><a href="#Flume插件" class="headerlink" title="Flume插件"></a>Flume插件</h1><ul><li>interceptors拦截器：<ul><li>用于source和channel之间，用来更改或者检查Flume的events数据</li></ul></li><li>管道选择器channel Selectors：<ul><li>再多管道是被用来选择使用哪一条管道来传递数据(events).管道选择器有分为两种：<ul><li>默认管道选择器：每个管道传递的都是相同的events</li><li>多路复用通道选择器：依据每一个event的头部header的地址选择管道</li></ul></li></ul></li></ul><p>Flume中的拦截器，用户Source读取events读取Sink的时候，再events header中加入一些有用的信息，或者对events的内容进行过滤，完成初步的数据清洗。</p><h3 id="Interceptors拦截器"><a href="#Interceptors拦截器" class="headerlink" title="Interceptors拦截器"></a>Interceptors拦截器</h3><ul><li><p>Timestamp Interceptor</p><ul><li>时间戳拦截器，将当前时间戳加入到events header中，key名字为：timestamp，值为时间戳。用的不是很多。比如再HDFS Sink时候，根据events的时间戳生成结果文件。</li><li>hdfs.filePrefix = log*%Y%m%d*%H：会根据时间戳将数据写入相应的文件中。但可以用其他方式代替（设置useLocalTimeStamp = true）</li></ul></li><li><p>Static Interceptor：静态拦截器</p><ul><li>用于在events header中加入一组静态的key和 value。</li><li>根据上面的Source，拦截器的配置如下：<ul><li>sources..interceptors = i1</li><li>.source.interceptors.i1.key = static_key</li><li>source.interceptors.i1.value = static_value</li><li>Regex FilteringInterceptor</li></ul></li></ul></li><li><p>Regex Filtering Interceptor:拦截器用于过滤事件</p><ul><li><p>筛选出与配置的正则表达式相匹配的事件。可以用于包含事件和排除事件。常用于数据清洗，通过正则表达式把数据过滤出来。</p></li><li><p>官网配置：</p><p>| <strong>Property Name</strong> | <strong>Default</strong> | <strong>Description</strong> | | —————– | ———– | ———————————————————— | | <strong>type</strong> | – | The component type name has to be regex_filter | | regex | ”.*” | Regular expression for matching against events | | excludeEvents | false | If true, regex determines events to exclude, otherwise regex determines events to include(excludeEvents 为true的时候为排除所有匹配正则表达式的数据) |</p></li><li><p><code>1:2:3.4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1.sources.r1.interceptors.i1.regex &#x3D; (\\d):(\\d):(\\d)</span><br></pre></td></tr></table></figure><p>其它拦截器：</p></li></ul></li></ul><p>UUID Interceptor：UUID拦截器，用于在每个events header中生成一个UUID字符串，例如：b5755073-77a9-43c1-8fad-b7a586fc1b97。生成的UUID可以在sink中读取并使用。</p><p>Host Interceptor：主机名拦截器。将运行Flume agent的主机名或者IP地址加入到events header中，key名字为：host（也可自定义）。</p><h3 id="日志收集案例"><a href="#日志收集案例" class="headerlink" title="日志收集案例"></a>日志收集案例</h3><ul><li>案例场景：A、B 两台日志服务机器实时生产日志主要类型为 access.log、nginx.log、web.log<ul><li>现在要求：把 A、B 机器中的 access.log、nginx.log、web.log 采集汇总到 C 机器上</li></ul></li></ul><p>然后统一收集到hdfs中。但是在hdfs中要求目录为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;source&#x2F;logs&#x2F;access&#x2F;20160101&#x2F;**</span><br><span class="line"></span><br><span class="line">&#x2F;source&#x2F;logs&#x2F;nginx&#x2F;20160101&#x2F;**</span><br><span class="line"></span><br><span class="line">&#x2F;source&#x2F;logs&#x2F;web&#x2F;20160101&#x2F;**</span><br></pre></td></tr></table></figure><p><img src="/blog/img/Flume_10.png"></p><p>**A、B服务器上的配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources = access-source nginx-source web-source</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sinks = avro-sink</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.channels = memory-channel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义source</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.<span class="built_in">type</span> = <span class="built_in">exec</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.command = tail -F /root/logs/access.log</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.interceptors = i1</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.interceptors.i1.<span class="built_in">type</span> = static</span><br><span class="line"><span class="comment"># static 拦截器的功能就是往采集到的数据的 header 中插入自己定义的 key-value 对</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.interceptors.i1.key = <span class="built_in">type</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.interceptors.i1.value = access</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.<span class="built_in">type</span> = <span class="built_in">exec</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.command = tail -F /root/logs/nginx.log</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.interceptors = i2</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.interceptors.i2.<span class="built_in">type</span> = static</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.interceptors.i2.key = <span class="built_in">type</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.interceptors.i2.value = nginx</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.<span class="built_in">type</span> = <span class="built_in">exec</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.command = tail -F /root/logs/web.log</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.interceptors = i3</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.interceptors.i3.<span class="built_in">type</span> = static</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.interceptors.i3.key = <span class="built_in">type</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.interceptors.i3.value = web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义sink </span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sinks.avro-sink.<span class="built_in">type</span> = avro</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sinks.avro-sink.hostname = <span class="number">192.168</span><span class="number">.19</span><span class="number">.137</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sinks.avro-sink.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义memory </span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.channels.memory-channel.<span class="built_in">type</span> = memory</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.channels.memory-channel.capacity = <span class="number">20000</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.channels.memory-channel.transactionCapacity = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接source和sink</span></span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.access-source.channels = memory-channel</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.nginx-source.channels = memory-channel</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sources.web-source.channels = memory-channel</span><br><span class="line"><span class="built_in">exec</span>-memory-avro.sinks.avro-sink.channel = memory-channel</span><br></pre></td></tr></table></figure><p><strong>C服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 agent 名， source、channel、sink 的名称</span></span><br><span class="line">avro-memory-hdfs.sources = avro-source</span><br><span class="line">avro-memory-hdfs.sinks = hdfs-sink</span><br><span class="line">avro-memory-hdfs.channels = memory-channel</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 source</span></span><br><span class="line">avro-memory-hdfs.sources.avro-source.<span class="built_in">type</span> = avro</span><br><span class="line">avro-memory-hdfs.sources.avro-source.bind = <span class="number">192.168</span><span class="number">.19</span><span class="number">.137</span></span><br><span class="line">avro-memory-hdfs.sources.avro-source.port =<span class="number">44444</span></span><br><span class="line"><span class="comment">#添加时间拦截器</span></span><br><span class="line">avro-memory-hdfs.sources.avro-source.interceptors = i1</span><br><span class="line">avro-memory-hdfs.sources.avro-source.interceptors.i1.<span class="built_in">type</span> = org.apache.flume.interceptor.TimestampInterceptor$Builder</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 sink</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.<span class="built_in">type</span> = hdfs</span><br><span class="line"><span class="comment">#%&#123;type&#125; 可以将前面的数据中的key对应的value取出</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.path=hdfs://<span class="number">192.168</span><span class="number">.19</span><span class="number">.137</span>:<span class="number">9000</span>/headlines/logs/%&#123;<span class="built_in">type</span>&#125;/%Y-%m-%d</span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.filePrefix =events</span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.fileType = DataStream</span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.writeFormat = Text</span><br><span class="line"><span class="comment">#时间类型</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.useLocalTimeStamp = true</span><br><span class="line"><span class="comment">#生成的文件不按条数生成</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.rollCount = <span class="number">0</span></span><br><span class="line"><span class="comment">#生成的文件按时间生成</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.rollInterval = <span class="number">30</span></span><br><span class="line"><span class="comment">#生成的文件按大小生成</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.rollSize  = <span class="number">10485760</span></span><br><span class="line"><span class="comment">#批量写入 hdfs 的个数</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.batchSize = <span class="number">10000</span></span><br><span class="line"><span class="comment">#flume 操作 hdfs 的线程数（包括新建，写入等）</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.threadsPoolSize=<span class="number">10</span></span><br><span class="line"><span class="comment">#操作 hdfs 超时时间</span></span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.hdfs.callTimeout=<span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 channels</span></span><br><span class="line">avro-memory-hdfs.channels.memory-channel.<span class="built_in">type</span> = memory</span><br><span class="line">avro-memory-hdfs.channels.memory-channel.capacity = <span class="number">20000</span></span><br><span class="line">avro-memory-hdfs.channels.memory-channel.transactionCapacity = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#组装 source、channel、sink</span></span><br><span class="line">avro-memory-hdfs.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-hdfs.sinks.hdfs-sink.channel = memory-channel</span><br></pre></td></tr></table></figure><p><strong>先启动C再分别启动A和B</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">C</span></span><br><span class="line">/root/bigdata/flume/bin/flume-ng agent -c conf -f /root/bigdata/flume/conf/avro-memory-hdfs.conf -name avro-memory-hdfs -Dflume.root.logger=DEBUG,console</span><br><span class="line"><span class="meta">#</span><span class="bash"> A、B</span></span><br><span class="line">/root/bigdata/flume/bin/flume-ng agent -c conf -f /root/bigdata/flume/conf/exec-memory-avro.conf -name exec-memory-avro - Dflume.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure><h1 id="Flume优化"><a href="#Flume优化" class="headerlink" title="Flume优化"></a>Flume优化</h1><ul><li>负载均衡（load balance）</li><li>容错（failover）</li></ul><h3 id="load-balance"><a href="#load-balance" class="headerlink" title="load balance"></a>load balance</h3><p>负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。Load balancing Sink Processor能够实现load balance功能，如下图Agent1是一个路由节点，负责将Channel暂存的event均衡到对应的多个Sink组件上，而每个Sink组件分别连接到一个独立的Agent上</p><p><img src="/blog/img/Flume_11.png"></p><p>常见配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a1.sinkgroups = g1</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.sinks = k1 k2 k3</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.type = load_balance</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.backoff = true    # 如果开启，则将失败的 sink 放入黑名单</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.selector = round_robin    # 另外还支持 random</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.selector.maxTimeOut=10000 #在黑名单放置的超时时间，超时结束时，若仍然无法接收，则超时时间呈指数增长</span><br></pre></td></tr></table></figure><h3 id="failover"><a href="#failover" class="headerlink" title="failover"></a>failover</h3><p><strong>Failover Sink Processor</strong> 能够实现 failover 功能，具体流程类似 load balance，但是内部处理机制与 load balance 完全不同。</p><p><strong>Failover Sink Processor 维护一个优先级 Sink 组件列表，只要有一个 Sink组件可用，Event 就被传递到下一个组件。</strong>故障转移机制的作用是将失败的 Sink降级到一个池，在这些池中它们被分配一个冷却时间，随着故障的连续，在重试之前冷却时间增加。一旦 Sink 成功发送一个事件，它将恢复到活动池。 Sink 具有与之相关的优先级，数量越大，优先级越高。 例如，具有优先级为 100 的 sink 在优先级为 80 的 Sink 之前被激活。如果在发送事件时汇聚失败，则接下来将尝试下一个具有最高优先级的 Sink 发送事件。如果没有指定优先级，则根据在配置中指定 Sink 的顺序来确定优先级。</p><p>常见配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a1.sinkgroups = g1</span><br><span class="line">a1.sinkgroups.g1.sinks = k1 k2 k3</span><br><span class="line">a1.sinkgroups.g1.processor.<span class="built_in">type</span> = failover</span><br><span class="line">a1.sinkgroups.g1.processor.priority.k1 = <span class="number">5</span> <span class="comment">#优先级值, 绝对值越大表示优先级越高</span></span><br><span class="line">a1.sinkgroups.g1.processor.priority.k2 = <span class="number">7</span></span><br><span class="line">a1.sinkgroups.g1.processor.priority.k3 = <span class="number">6</span></span><br><span class="line">a1.sinkgroups.g1.processor.maxpenalty = <span class="number">20000</span> <span class="comment">#失败的 Sink 的最大回退期（millis）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/blog/2019/08/12/Kafka/"/>
      <url>/blog/2019/08/12/Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>Kafka是一种分布式的，基于发布/订阅的消息系统，原本开发自Linkedln，用作Linkedln的活动流(Activity Stream)和运营数据处理管道(Pipeline)的基础。</p><ul><li>Kafka被用于构建实时数据管道和流处理，支持横向扩展、容错、极快，能够在上千台服务器上运行。</li><li>Apache Kafka是开源<strong>消息</strong>系统，由Scala写成，是由Apache软件基金会开发的一个开源消息系统项目。Kafka最初是由Linkedln开发，并于2011年开源。2012年10月从Apache lncudator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。</li><li><strong>Kafka</strong>是一个<strong>分布式消息队列</strong>：生产者、消费者的功能。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS规范实现</li></ul><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p><strong>生产者消费者问题</strong>，也称为有限缓冲问题，是一个<strong>多线程同步</strong>问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程—所谓的“生产者”和“消费者”—-在实际运行时会发生的问题。生产者的主要作用时生产一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓存区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满的时候加入数据，消费者也不会在缓冲区空时消耗数据。</p><p><img src="/blog/img/Kafka.png"></p><h3 id="Kafka安装"><a href="#Kafka安装" class="headerlink" title="Kafka安装"></a>Kafka安装</h3><ul><li><p>安装kafka配置</p><ul><li>下载kafka_**.tgz,解压</li><li>配置KAFKA_HOME</li></ul></li><li><p>开启：</p><ul><li>开启zookeeper，需要一直在服务器端实时运行，以守护进程运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;root&#x2F;bigdata&#x2F;kafka&#x2F;bin&#x2F;zookeeper-server-start.sh -daemon &#x2F;root&#x2F;bigdata&#x2F;kafka&#x2F;config&#x2F;zookeeper.properties</span><br></pre></td></tr></table></figure><ul><li>开启kafka服务：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/bigdata/kafka/<span class="built_in">bin</span>/kafka-server-start.sh /root/bigdata/kafka/config/server.properties</span><br></pre></td></tr></table></figure><ul><li>开启生产这与消费者</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启消息生产者</span><br><span class="line">/root/bigdata/kafka/bin/kafka-console-producer.sh --broker-list 192.168.19.137:9092 --sync --topic click-trace</span><br><span class="line"> 开启消费者</span><br><span class="line">/root/bigdata/kafka/bin/kafka-console-consumer.sh --bootstrap-server 192.168.19.137:9092 --topic  click-trace</span><br></pre></td></tr></table></figure><h1 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h1></li></ul><p><img src="/blog/img/Kafka_1.png"></p><p>一个典型的Kafka集群中包含若干Producer(可以时web前端生产的Page View，或者是服务器日志、系统CPU、Menory等)，若干个Broker(Kafka支持水平扩展，一般Broker数量越多，集群吞吐率越高)，若干Consumer Group，以及一个Zookeeper集群。</p><ul><li><strong>Broker</strong>：Kafka集群包含一个或多个服务器，这种服务器被称为broker<ul><li>作用：接收Producer和Consumer的请求，并把Message持久化到本地磁盘</li></ul></li><li><strong>Topic</strong>：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需要指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li><strong>Partition</strong>：Partition是物理上的概念，每个Topic包含一个或多个Partition。</li><li><strong>Producer</strong>：负责发布消息到Kafka Broker</li><li><strong>Consumer</strong>：消息消费者，向Kafka Broker读取消息的客户端</li><li><strong>Consumer Group</strong>：每个Consumer属于一个特定的Consumer Group(可为每个Consumer指定group name，若不指定group name则属于默认的group)。</li><li><strong>Zookeeper</strong>：保存着集群broker、topic、partition等meta数据；负责broker故障发现，partition leader选举，负载均衡等功能</li><li>运行过程Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</li></ul><h1 id="Kafka设计原理"><a href="#Kafka设计原理" class="headerlink" title="Kafka设计原理"></a>Kafka设计原理</h1><h3 id="Topic-amp-Partition（存储设计原理）"><a href="#Topic-amp-Partition（存储设计原理）" class="headerlink" title="Topic &amp; Partition（存储设计原理）"></a>Topic &amp; Partition（存储设计原理）</h3><ul><li>Topic在逻辑上可以被认为一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。可以使得Kafka的吞吐率可以线性提高</li><li>物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这和Partition的所有消息和索引文件<ul><li>若创建topic1和topic2两个topic，且分别有13个和19个分区，则整个集群上会相应生成共32个文件夹,</li><li>一般建议选择broker num * consumer num，这样平均每个consumer会同时读取broker数个partition，这些partition压力可以摊到每台broker上。</li></ul></li></ul><h3 id="Partition的数据文件"><a href="#Partition的数据文件" class="headerlink" title="Partition的数据文件"></a>Partition的数据文件</h3><ul><li>offset：offset表示Message在这个partition中的偏移量，offset不是该Message在partition数据文件中实际存储位置，而是逻辑上一个值，可以认为offset是partition中Message的id。</li><li>MessageSize：MessageSize表示消息内容data的大小</li><li>data：data为Message的具体内容</li></ul><p>partition中每条Message包含三个属性：partition的数据文件由以上格式的Message组成，按offset由小到大排列在一起，如果一个partition多个数据文件，Kafka通过片段和索引来提高查询效率</p><ul><li><strong>数据文件分段segment</strong>：partition物理上由多个segment文件组成，每个segment大小相等，顺序读写。每个segment数据文件以该段中最小的offset命名，文件扩展名为.log。这样在查找指定offset的Message的时候，用而分查找就可以定位到该Message在哪个segment数据文件中。</li><li><strong>数据文件索引</strong>：数据文件分段使得可以在一个较小的数据文件中查找对应offset的Messagel，但是这一让需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立索引文件，文件名于数据文件的名字是一样的，只是文件扩展名为.index</li></ul><p><img src="/blog/img/Kafka_2.png"></p><p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分，分别为相对offset和position(位置)</p><p><strong>segment中index&lt;—-&gt;data file对应关系物理结构如下：</strong></p><p><img src="/blog/img/Kafka_3.png"></p><ul><li>查找过程：查找某个offset的消息，先二分法找出消息所在的segment文件；然后加载对应的index索引文件到内存，同样二分法找出小于等于给定offset的最大的那个offset记录；最后根据position到log文件中，顺序查找出offset等于给定offset值得消息<ul><li>由于消息在partition的segment数据文件中是顺序读写的，且消息消费后不会删除(删除策略只针对过期的segment文件)，这种顺序磁盘IO存储设计是Kafka高性能很重要的原因。</li><li>Kafka运行时很少由大量读磁盘的操作，主要时定期批量写磁盘操作，因此操作磁盘很高效，这跟Kafka文件存储中读写message的设计是息息相关的。Kafka中读写message由如下特点：<ul><li>写message(生产者)<ul><li>消息从java堆转入page cache(即物理内存)。</li><li>由异步线程刷盘,消息从page cache刷入磁盘。</li></ul></li><li>读message(消费者)<ul><li>消息直接从page cache转入socket发送出去。</li><li>当从page cache没有找到相应数据时，此时会产生磁盘IO,从磁 盘Load消息到page cache,然后直接从socket发出去</li></ul></li></ul></li></ul></li><li>Kafka高效文件存储设计特点：<ul><li>Kafka把Topic中一个partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完的文件，减少磁盘占用。</li><li>通过索引信息可以快速定位Message和确定response的最大大小</li><li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作</li><li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小</li></ul></li></ul><h3 id="Producer-生产者"><a href="#Producer-生产者" class="headerlink" title="Producer(生产者)"></a>Producer(生产者)</h3><p><img src="/blog/img/Kafka_4.png"></p><p>producer采用推(push)模式将消息发布到broker，每条消息都被追加(append)到分区(partition)中，属于顺序写磁盘(顺序写磁盘效率比随机写内存要高，保证kafka吞吐率)</p><p><img src="/blog/img/Kafka_5.png"></p><ul><li>创建一个ProducerRecord，这个对象需要包含消息的主题(Topic)和值(value)，可以选择性指定一个键值(key)或分区(partition)。key和value序列化为ByteArrays，以便它们可以通过网络发送</li><li><strong>发送到分配器（partitioner）：如果我们指定了分区，那么分配器返回该分区即可；</strong>否则，分配器将会基于键值来选择一个分区并返回。选择完分区后，生产者知道了消息所属的主题和分区，它将这条记录添加到相同主题和分区的批量消息中，<strong>另一个线程负责发送这些批量消息到对应的Kafka broker。</strong></li><li>broker接收到数据的时候，如果数据已被成功写入到Kafka，会返回一个包含topic、分区和偏移量offset的RecordMetadata对象；<ul><li>如果broker写入数据失败，会返回一个异常信息给生产者。当生产者接收到异常信息时会尝试重新发送数据，如果尝试失败则抛出异常。</li></ul></li></ul><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p><img src="/blog/img/Kafka_6.png"></p><ul><li>任何Consumer必须属于有一个Consumer Group<ul><li>使用 Consumer high level API 时，同一 Topic 的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。</li></ul></li><li>特点：Kafka 用来实现一个 Topic 消息的广播（发给所有的 Consumer）和单播（发给某一个 Consumer）的手段。一个 Topic 可以对应多个 Consumer Group。<ul><li>如果需要实现广播，只要每个 Consumer 有一个独立的 Group 就可以了。</li><li>要实现单播只要所有的 Consumer 在同一个 Group 里。用 Consumer Group 还可以将 Consumer 进行自由的分组而不需要多次发送消息到不同的 Topic。</li></ul></li></ul><p>消费之后一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略删除旧数据。一是基于时间，二是基于Partition文件大小。例如可以通过配置<code>$KAFKA_HOME/config/server.properties</code>，让Kafka删除一周前的数据，也可在Partition文件超过1GB时删除旧数据，配置如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></span><br><span class="line">log.retention.hours=<span class="number">168</span></span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line">log.segment.<span class="built_in">bytes</span>=<span class="number">1073741824</span></span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according to the retention policies</span></span><br><span class="line">log.retention.check.interval.ms=<span class="number">300000</span></span><br><span class="line"><span class="comment"># If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction.</span></span><br><span class="line">log.cleaner.enable=false</span><br></pre></td></tr></table></figure><h4 id="Message-Queue常见对比"><a href="#Message-Queue常见对比" class="headerlink" title="Message Queue常见对比"></a>Message Queue常见对比</h4><ul><li><strong>RabbitMQ</strong>：RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了 Broker 构架，消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</li><li>Kafka/Jafka<ul><li>快速持久化，可以在 O(1) 的系统开销下进行消息持久化；</li><li>高吞吐；，完全的分布式系统，Broker、Producer、Consumer 都原生自动支持分布式，自动实现负载均衡；Kafka 相对于 ActiveMQ 是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</li></ul></li></ul><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table><thead><tr><th align="left">特性</th><th align="left">ActiveMQ</th><th align="left">RabbitMQ</th><th align="left">RocketMQ</th><th align="left">Kafka</th></tr></thead><tbody><tr><td align="left">单机吞吐量</td><td align="left">万级，比 RocketMQ、Kafka 低一个数量级</td><td align="left">同 ActiveMQ</td><td align="left">10 万级，支撑高吞吐</td><td align="left">10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td align="left">topic 数量对吞吐量的影响</td><td align="left"></td><td align="left"></td><td align="left">topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td align="left">topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td align="left">时效性</td><td align="left">ms 级</td><td align="left">微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td align="left">ms 级</td><td align="left">延迟在 ms 级以内</td></tr><tr><td align="left">可用性</td><td align="left">高，基于主从架构实现高可用</td><td align="left">同 ActiveMQ</td><td align="left">非常高，分布式架构</td><td align="left">非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td align="left">消息可靠性</td><td align="left">有较低的概率丢失数据</td><td align="left"></td><td align="left">经过参数优化配置，可以做到 0 丢失</td><td align="left">同 RocketMQ</td></tr><tr><td align="left">功能支持</td><td align="left">MQ 领域的功能极其完备</td><td align="left">基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td align="left">MQ 功能较为完善，还是分布式的，扩展性好</td><td align="left">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p><strong>如何选择MQ</strong></p><ul><li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；</li><li>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><h1 id="Kafka-Python-API"><a href="#Kafka-Python-API" class="headerlink" title="Kafka Python API"></a>Kafka Python API</h1><h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><ul><li>下载安装kafka-python:<code>pip install kafka-python</code></li><li>验证是否安装成功:<code>import kafka</code></li></ul><h4 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h4><ul><li>创建topic命令<ul><li>bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 <strong>–topic test</strong></li><li>replication-factor：副本数量</li><li>partitions：分区数量</li></ul></li><li>通过生产者发送消息<ul><li>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</li></ul></li><li>通过消费者消费消息<ul><li>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</li><li>-from-beginning：从最开始生产队的数据开始消费</li></ul></li><li>其它Kafka命令<ul><li>查看所有topic<ul><li>bin/kafka-topics.sh –list –zookeeper localhost:2181</li></ul></li></ul></li></ul><h4 id="Python-代码使用创建生产者"><a href="#Python-代码使用创建生产者" class="headerlink" title="Python 代码使用创建生产者"></a>Python 代码使用创建生产者</h4><p>创建Kafka生产者有三个基本属性：</p><ul><li><p>bootstrap.servers：属性值是一个host:port的broker列表。</p></li><li><p>key.serializer：因此需要将这些对象序列化成字节数组。key.serializer指定的类需要实现org.apache.kafka.common.serialization.Serializer接口，Kafka客户端包中包含了几个默认实现，例如ByteArraySerializer、StringSerializer和IntegerSerialier。</p></li><li><p>value.serializer：属性值是类的名称。这个属性指定了用来序列化消息记录的类，与key.serializer差不多。</p></li><li><p>命令行方式：普通的发送方式：</p><ul><li>导入KafkaProducer，创建连接到192.168.19.137:9092</li><li>向这个Broker的Producer,循环向test_topic这个Topic发送100个消息，消息内容都是’some_message_bytes’，这种发送方式不指定Partition，kafka会均匀的把这些消息分别写入n个Partiton里面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>producer = KafkaProducer(bootstrap_servers=<span class="string">&#x27;192.168.19.137:9092&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"><span class="meta">... </span>    producer.send(<span class="string">&#x27;test_topic&#x27;</span>,<span class="string">b&#x27;some_message_bytes&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注：kafka发送的数据是字节，需要将字符串转换为字节</strong></p></li><li><p>2、命令行方式：发送json字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>producer = KafkaProducer(bootstrap_servers=<span class="string">&#x27;node-teach:9092&#x27;</span>,value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>producer.send(<span class="string">&#x27;test_topic&#x27;</span>, &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>&#125;)</span><br><span class="line">&lt;kafka.producer.future.FutureRecordMetadata <span class="built_in">object</span> at <span class="number">0x2a9ebd0</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>3、命令行方式：发送普通字符串</p><p>compression_type：压缩类型，’gzip’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>producer = KafkaProducer(bootstrap_servers=<span class="string">&#x27;node-teach:9092&#x27;</span>,compression_type=<span class="string">&#x27;gzip&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>producer.send(<span class="string">&#x27;test_topic&#x27;</span>, <span class="string">b&#x27;msg&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1></li><li><p>目的：实现一个消息发送与消息接受功能程序</p></li><li><p>步骤：</p><ul><li>1、创建producer，利用producer将某个目录下的所有文件名发送到指定topic，并由consumer来接收</li><li>2、 创建consumer进行消费</li></ul></li></ul><p>1、创建producer，利用producer将某个目录下的所有文件名发送到指定topic，并由consumer来接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=<span class="string">&#x27;ip:9092&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    t = time.strftime(<span class="string">r&quot;%Y-%m-%d %H-%M-%S&quot;</span>,time.localtime())</span><br><span class="line">    print(<span class="string">&quot;[%s]%s&quot;</span>%(t,<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_file</span>(<span class="params">path</span>):</span></span><br><span class="line">    dir_list = os.listdir(path);</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> dir_list:</span><br><span class="line">         producer.send(<span class="string">&#x27;test_topic&#x27;</span>,f.encode())</span><br><span class="line">         producer.flush()</span><br><span class="line">         log(<span class="string">&#x27;send: %s&#x27;</span> % (f))    </span><br><span class="line"></span><br><span class="line">list_file(<span class="string">&quot;/root/logs/&quot;</span>)</span><br><span class="line">producer.close()</span><br></pre></td></tr></table></figure><p>2、创建consumer进行消费</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">        t = time.strftime(<span class="string">r&quot;%Y-%m-%d %H-%M-%S&quot;</span>,time.localtime())</span><br><span class="line">        print(<span class="string">&quot;[%s]%s&quot;</span>%(t,<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;start consumer&#x27;</span>)</span><br><span class="line">consumer=KafkaConsumer(<span class="string">&#x27;test_topic&#x27;</span>,bootstrap_servers=[<span class="string">&#x27;ip:9092&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">        recv = <span class="string">&quot;%s:%d:%d: key=%s value=%s&quot;</span> %(msg.topic,msg.partition,msg.offset,msg.key,msg.value)</span><br><span class="line">        log(recv)</span><br></pre></td></tr></table></figure><h1 id="High-Available-高可用"><a href="#High-Available-高可用" class="headerlink" title="High Available(高可用)"></a>High Available(高可用)</h1><p><strong>为什么需要高可用</strong></p><ul><li>Kafka在0.8以前的版本中，并不提供High Availablity机制，一旦一个或多个Broker宕机，则宕机期间其上所有Partition都无法继续提供服务。若该Broker永远不能再恢复，亦或磁盘故障，则其上数据将丢失<ul><li>Kafka从0.8开始提供High Availability机制。本文从Data Replication和Leader Election两方面介绍了Kafka的HA机制。</li></ul></li></ul><h3 id="Replication-副本-设计"><a href="#Replication-副本-设计" class="headerlink" title="Replication(副本)设计"></a>Replication(副本)设计</h3><p>作为消息中间件，数据的可靠性以及系统的可用性，必然依赖数据副本的设计。</p><p>Kafka的replica副本单元是topic的partition，一个partition的replica数量不能超过broker的数量，因为一个broker最多只会存储这个partition的一个副本。所有消息生产、消费请求都是由partition的leader replica来处理，其他follower replica负责从leader复制数据进行备份。</p><p>Replica均匀分布到整个集群，Replica的算法如下：</p><ul><li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li><li>将第i个Partition分配到第（i mod n）个Broker上</li><li>将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上</li></ul><p><img src="/blog/img/Kafka_7.png" alt="img"></p><p>如图，TopicA有三个partition：part0、part1、part2，每个partition的replica数等于2（一个是leader，另一个是follower），按照以上算法会均匀落到三个broker上。</p><h3 id="Leader-Election-选举机制"><a href="#Leader-Election-选举机制" class="headerlink" title="Leader Election(选举机制)"></a>Leader Election(选举机制)</h3><ul><li>为什么需要Leader？<ul><li>引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replica中选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。</li></ul></li></ul><p>如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p><p>kafka消息投递（delivery guarantee）</p><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费</p><ul><li>At most once——最多一次，消息可能会丢失，但不会重复</li><li>At least once——最少一次，消息不会丢失，可能会重复</li><li>Exactly once——只且一次，消息不丢失不重复，只且消费一次。</li></ul><p>但是整体的消息投递语义需要Producer端和Consumer端两者来保证。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark</title>
      <link href="/blog/2019/08/12/Spark/"/>
      <url>/blog/2019/08/12/Spark/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a>Spark简介</h1><h3 id="Spark概述"><a href="#Spark概述" class="headerlink" title="Spark概述"></a>Spark概述</h3><ul><li>什么是Spark<ul><li>基于内存的计算引擎，它的计算速度非常快。但是仅仅只涉及到数据的计算，并没有涉及到数据的存储</li><li>Spark的优势<ul><li><strong>MapReduce框架局限性</strong><ul><li>Map结果写磁盘，Reduce写HDFS，多个MR之间通过HDFS交换数据</li><li>任务调度和启动开销大</li><li>无法充分利用内存</li><li>不适合迭代计算（如机器学习、图计算等等），交互式处理（数据挖掘）</li><li>不适合流式处理（点击日志分析）</li><li>MapReduce编程不够灵活，仅支持Map和Reduce两种操作</li></ul></li><li><strong>Hadoop生态圈</strong><ul><li>批处理：MapReduce、Hive、Pig</li><li>流式计算：Storm</li><li>交互式计算：impala、presto</li></ul></li><li><strong>需要一种灵活的框架可同时进行批处理、流式计算、交互式计算</strong><ul><li>内存计算引擎，提供cache机制来支持需要反复迭代计算或者多次数据共享，减少数据读取的IO开销</li><li>DAG引擎，较少多次计算之间中间结果写到HDFS的开销</li><li>使用多线程模型来减少task启动开销，shuffle过程中避免不必要的sort操作以及减少磁盘IO</li></ul></li><li>spark的缺点：吃内存，不太稳定</li><li><strong>Spark特点</strong><ul><li>速度快（比MapReduce在内存中快100倍，在磁盘中快10倍）<ul><li>spaek中的job中间结果可以不落地，可以存放在内存中</li><li>MapReduce中Map和Reduce任务都是以进程的方式运行着，而spark中的job是以线程方式运行在进程中</li></ul></li><li>易用性（可以通过java/scala/python/R开发spark应用）</li><li>通用性（可以使用spark sql/spark streaming/mlib/Graphx）</li><li>兼容性（spark程序可以运行在standalone/yarn/mesos）</li></ul></li></ul></li></ul></li></ul><h3 id="RDD概述"><a href="#RDD概述" class="headerlink" title="RDD概述"></a>RDD概述</h3><ul><li>什么是RDD<ul><li>RDD(Resilient Distributed Dataset)叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算集合<ul><li>Dataset：一个数据集，简单的理解为集合，用于存放数据的</li><li>Distributed：它的数据是分布式存储，并且可以做分布式计算</li><li>Resilient：弹性的<ul><li>它表示的是数据可以保存在磁盘，也可以保存在内存中</li><li>数据分布式也是弹性的</li><li>弹性：并不是指它可以动态扩展，而是容错机制<ul><li>RDD会在多个节点上存储，就和HDFS得分布式道理一样的。HDFS文件被切分为多个block存储在各个节点上，而RDD是被切分为多个partition。不同的partition可能在不同节点上</li><li>spark读取HDFS的场景下，spark把HDFS的block读到内存就会抽象为spark的partition。</li><li>spark计算结束，一般会把数据做持久化到Hive，HBase，HDFS等等</li></ul></li></ul></li><li>不可变：Rdd数据不可变，只能是生成一个新的Rdd</li><li>可分区partition</li><li>并行计算</li></ul></li></ul></li></ul><h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><ul><li><p>第一步创建sparkContext</p><ul><li>SparkContext，Spark程序入口。SparkContext代表了和Spark集群的链接，在Spark集群中通过SparkContext来创建RDD</li><li>SparkConf创建SparkContext的时候需要一个SparkConf，用来传递Spark应用的基本信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf &#x3D; SparkConf().setAppName(appName).setMaster(master)</span><br><span class="line">sc &#x3D; SparkContext(conf&#x3D;conf)</span><br></pre></td></tr></table></figure></li><li><p>创建RDD</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"># 创建RDD</span><br><span class="line">data_rdd &#x3D; sc.parallelize(data)</span><br><span class="line"># 创建RDD，并且分成5个分区</span><br><span class="line">data_rdd &#x3D; sc.parallelize(data, 5)</span><br><span class="line"># 直接读取文件生成RDD</span><br><span class="line">data_rdd &#x3D; sc.textFile(&#39;路径&#39;)</span><br></pre></td></tr></table></figure><h1 id="RDD常用算子"><a href="#RDD常用算子" class="headerlink" title="RDD常用算子"></a>RDD常用算子</h1><h3 id="三类RDD算子"><a href="#三类RDD算子" class="headerlink" title="三类RDD算子"></a>三类RDD算子</h3><ul><li>transformation算子（该算子操作都是惰性的，不会立即计算出结果，会记录计算过程，只有在进行action操作才会计算结果）<ul><li>从一个已经存在的数据集创建一个新的数据集<ul><li>rdd_a —–&gt;transformation—–&gt; rdd_b</li></ul></li></ul></li><li>action算子<ul><li>获取对数据进行运算操作之后的结果</li></ul></li><li>persist操作算子<ul><li>persist操作用于将数据缓存，可以缓存在内存中，也可以在磁盘上，也可以复制到磁盘的其它节点上</li></ul></li></ul><h3 id="Transformation算子"><a href="#Transformation算子" class="headerlink" title="Transformation算子"></a>Transformation算子</h3><ul><li><p>map</p><ul><li>将func函数作用到数据集的每一个元素上，生成一个新的RDD返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line">rdd2 = rdd1.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+<span class="number">1</span>)</span><br><span class="line">rdd2.collect()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li><li><p>filter</p><ul><li>选出所有func返回值为true的元素，生成一个新的RDD返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line">rdd2 = rdd1.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*<span class="number">2</span>)</span><br><span class="line">rdd3 = rdd2.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;<span class="number">4</span>)</span><br><span class="line">rdd3.collect()</span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li><li><p>flatMap</p><ul><li>flatMap会先执行map操作，再将所有对象合并为一个对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize([<span class="string">&quot;a b c&quot;</span>, <span class="string">&quot;d e f&quot;</span>, <span class="string">&quot;h i j&quot;</span>])</span><br><span class="line">rdd2 = rdd1.flatMap(<span class="keyword">lambda</span> x: x.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">rdd2.collect()</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>union</p><ul><li>对两个RDD求并集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)])</span><br><span class="line">rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">4</span>)])</span><br><span class="line">rdd3 = rdd1.union(rdd2)</span><br><span class="line">rdd3.collect()</span><br><span class="line">[(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure></li><li><p>intersection</p><ul><li>对两个RDD求交集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)])</span><br><span class="line">rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">3</span>)])</span><br><span class="line">rdd3 = rdd1.union(rdd2)</span><br><span class="line">rdd4 = rdd3.intersection(rdd2)</span><br><span class="line">rdd4.collect()</span><br><span class="line">[(<span class="string">&quot;c&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></li><li><p>groupByKey</p><ul><li>以元组中的第0个元素作为key，进行分组，返回一个新的RDD</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>)])</span><br><span class="line">rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">3</span>)])</span><br><span class="line">rdd3 = rdd1.union(rdd2)</span><br><span class="line">rdd4 = rdd3.groupByKey()</span><br><span class="line">result = rdd4.collect()</span><br><span class="line">result</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, &lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6a5e5898</span>&gt;), (<span class="string">&#x27;c&#x27;</span>, &lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6a5e5518</span>&gt;), (<span class="string">&#x27;b&#x27;</span>, &lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6a5e5f28</span>&gt;)]</span><br><span class="line">result[<span class="number">2</span>]</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, &lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6c18e518</span>&gt;)</span><br><span class="line">result[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">&lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6c18e518</span>&gt;</span><br><span class="line"><span class="built_in">list</span>(result[<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>reduceByKey</p><ul><li>将key相同的键值，按照func进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdd = sc.parallelize([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line">rdd.reduceByKey(<span class="keyword">lambda</span> a,y: x+y).collect()</span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h3 id="Action算子"><a href="#Action算子" class="headerlink" title="Action算子"></a>Action算子</h3></li><li><p>collect</p><ul><li>返回一个list，list中包含RDD中的所有元素</li><li>只有当数据量较小的时候使用Collect因为所有的结果都会加载到内存中</li></ul></li><li><p>reduce</p><ul><li>reduce将RDD中元素两两传递给输入函数，同时产生一个新的值，新产生的值与RDD中下一个元素再被传递给输入函数直到最后一个值为止。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdd1 &#x3D; sc.parallelize([1, 2, 3, 4])</span><br><span class="line">rdd1.reduce(lambda x,y: x+y)</span><br><span class="line">15</span><br></pre></td></tr></table></figure></li><li><p>first</p><ul><li>返回RDD的第一个元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize([3,4,5]).first()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p>take</p><ul><li>返回RDD的前n个元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize([2,3,4,5]).take(2)</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure></li><li><p>count</p><ul><li>返回RDD中元素的个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize([1,3,5]).count()</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="Spark集群"><a href="#Spark集群" class="headerlink" title="Spark集群"></a>Spark集群</h1></li></ul><h3 id="spark集群架构（Standalone模式）"><a href="#spark集群架构（Standalone模式）" class="headerlink" title="spark集群架构（Standalone模式）"></a>spark集群架构（Standalone模式）</h3><p><img src="/blog/img/Spark_1.png"></p><ul><li><p>Application</p><ul><li>用户自己写的Spark应用程序，批处理作业的集合。Application的main方法为应用程序的入口，用户通过Spark的API，定义了RDD和对RDD的操作</li></ul></li><li><p>Master和Worker</p><p>整个集群分为Master节点和Worker节点，相当于Hadoop的Master和Slave节点</p><ul><li>Master：Standalone模式中主控节点，负责接收Client提交的作业，管理Worker，并命令Worker启动Driver和Executor。</li><li>Worker：Standalone模式中slave节点上的守护进程，负责管理本节点的资源，定期向Master汇报心跳，接收Master的命令，启动Driver和Executor</li></ul></li><li><p>Client：客户端进程，负责提交作业到Master。</p></li><li><p>Driver：一个Spark作业运行时包括一个Driver进程，也是作业的主进程，负责作业的解析、生成Stage并调度Task到Executor上。包括DAGScheduler，TaskScheduler</p></li><li><p>Executor：即真正执行作业的地方，一个集群一般包含多个Executor，每个Executor接收Deiver的命令Launch Task，一个Executor可以执行一个到多个Task</p></li><li><p>Spark作业相关概念</p><ul><li>Stage：一个Spark作业一般包含一到多个Stage</li><li>Task：一个Stage包含一到多个Task，通过多个Task实现并行运行的功能</li><li>DAGScheduler：实现将Spark作业分解成一到多个Stage，每个Stage根据RDD的Partition个数决定Task的个数，然后生成相应的Task放到TaskScheduler中。</li><li>TaskScheduler：实现Task分配到Executor上执行。</li></ul></li></ul><h1 id="Spark-SQL-概述"><a href="#Spark-SQL-概述" class="headerlink" title="Spark SQL 概述"></a>Spark SQL 概述</h1><h3 id="Spark-SQL概念"><a href="#Spark-SQL概念" class="headerlink" title="Spark SQL概念"></a>Spark SQL概念</h3><ul><li>Spark SQL是Apache Spark用于处理结构化数据的模块<ul><li>它是spark中用于处理结构化数据的一个模块</li></ul></li></ul><h3 id="Spark-SQL历史"><a href="#Spark-SQL历史" class="headerlink" title="Spark SQL历史"></a>Spark SQL历史</h3><ul><li>Hive是目前大数据领域，事实上的数据仓库标准</li><li>Shark：shark底层使用spark的基于内存的计算模型，从而让计算性能比Hive提升了数倍到上百倍。</li><li>底层很多东西还是依赖于Hive，修改了内存管理、物理计划、执行三个模块</li><li>2014年6月1日，spark宣布了不再开发Shark，全面转向Spark SQL的开发</li></ul><h3 id="Spark-SQL优势"><a href="#Spark-SQL优势" class="headerlink" title="Spark SQL优势"></a>Spark SQL优势</h3><p><img src="/blog/img/Spark_2.png"></p><ul><li>速度</li></ul><p><img src="/blog/img/Spark_3.png"></p><p>python操作RDD，转换为可执行代码，运行再java虚拟机，涉及两个不同语言引擎之间的切换，进行进程间通信很耗费性能。</p><p>DataFrame</p><ul><li>是RDD为基础的分布式数据集，类似于传统关系型数据库的二维表，dataframe记录了对应列的名称和类型</li><li>dataFrame引入schema和off-heap(使用操作系统层面上的内存)<ul><li>1.解决了RDD的缺点</li><li>序列化和反序列化开销大</li><li>频繁的创建和销毁对象造成大量的GC</li><li>2.丢失了RDD的优点</li><li>RDD编译时进行类型检查</li><li>RDD具有面向对象编程的特性</li></ul></li></ul><p>用scala/python编写的RDD比Spark SQL编写转换的RDD慢，涉及到执行计划</p><ul><li>CatalystOptimizer：Catalyst优化器</li><li>ProjectTungsten：钨丝计划，为了提高RDD的效率而制定的计划</li><li>Code gen：代码生成器</li></ul><p><img src="/blog/img/Spark_4.png"></p><p>直接编写RDD也可以自实现优化代码，但是远不及SparkSQL面前的优化操作后转换的RDD效率高，快1倍左右</p><p>优化引擎：类似mysql等关系型数据库基于成本的优化器</p><p>首先执行逻辑执行计划，然后转换为物理执行计划（选择成本最小的），通过Code Generation最终生成RDD</p><ul><li>Language-independent API</li></ul><p>用任何语言编写生成的RDD都一样，而使用spark-core编写的RDD，不同的语言生成不同的RDD</p><ul><li>Schema</li></ul><p>结构化数据，可以直接看出数据的详情</p><p>在RDD中无法看出，解释性不强，无法告诉引擎信息，没法详细优化</p><h3 id="SparkSQL优点"><a href="#SparkSQL优点" class="headerlink" title="SparkSQL优点"></a>SparkSQL优点</h3><ul><li>易整合</li><li>统一的数据源访问</li><li>兼容Hive</li><li>提供了标准的数据库连接</li></ul><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Spark语义中，DataFrame是一个分布式的行集合，可以想象为一个关系型数据库的表。</p><ul><li>Immuatable：一旦RDD、DataFrame被创建，就不能更改，只能通过transformation生成新的RDD、DataFrame</li><li>Lazy Evaluations：只有action才会触发Transformation的执行</li><li>Distributed：DataFrame和RDD一样都是分布式的</li><li>dataframe和dataset统一，dataframe只是dataset[ROW]的类型别名。由于Python是弱类型语言，只能使用DataFrame</li></ul><h3 id="DataFrame-vs-RDD"><a href="#DataFrame-vs-RDD" class="headerlink" title="DataFrame vs RDD"></a>DataFrame vs RDD</h3><ul><li>RDD:分布式的对象的集合，Spark并不知道对象的详细模式信息</li><li>DataFrame：分布式的Row对象的集合，其提供了由列组成的详细模式信息，使得Spark SQL可以进行某些形式的执行优化。</li><li>DataFrame和普通的RDD的逻辑框架区别如下所示：</li></ul><p><img src="/blog/img/Spark_5.png"></p><ul><li>左侧的RDD Spark框架本身不了解Person类的内部结构</li><li>右侧的DataFrame提供了详细的结构信息（schema—每列的名称、类型）</li><li>DataFrame还配套了新的操作数据方法，DataFrame API（如：df.select()）和SQL(select id, name from ***)</li><li>DataFrame还引入了off-heap,意味着JVM堆以外的内存，这些内存直接受操作系统管理(而不是JVM)</li><li>RDD是分布式的java对象集合，DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化</li><li>DataFrame的抽象后，我们处理数据更加简单了，甚至可以用SQL来处理数据</li><li>通过DataFrame API或SQL处理数据，会自动经过Spark优化器(Catalyst)的优化，即使你写的程序或SQL不高效，也可以运行很快。</li><li>DataFrame相当于是一个带着schema的RDD</li></ul><h3 id="Pandas-DataFrame-vs-Spark-DataFrame"><a href="#Pandas-DataFrame-vs-Spark-DataFrame" class="headerlink" title="Pandas DataFrame  vs  Spark DataFrame"></a>Pandas DataFrame  vs  Spark DataFrame</h3><ul><li>Cluster Parallel:集群并行执行</li><li>Lazy Evaluations:只有action才会触发Transformation的执行</li><li>Immutable：不可更改</li><li>Pandas rich API：比Spark SQL api丰富</li></ul><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><ul><li>创建DataFrame</li></ul><p>调用方法例如：spark.read.xxx方法</p><ul><li><p>其他方式创建dataframe</p><ul><li>createDataFrame：pandas dataframe、list、RDD</li><li>数据源：RDD、csv、json、parquet、orc、jdbc</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jsondf &#x3D; spark.read.json(&quot;xxx.json&quot;)</span><br><span class="line">jsondf &#x3D; spark.read.format(&quot;json&quot;).load(&quot;xxx.json&quot;)</span><br><span class="line">parquetdf &#x3D; spark.read.parquet(&quot;xxx.parquet&quot;)</span><br><span class="line">jdbcDF &#x3D; spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;,&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_name&quot;).option(&quot;dbtable&quot;,&quot;table_name&quot;).option(&quot;user&quot;,&quot;xxx&quot;).option(&quot;password&quot;,&quot;xxx&quot;).load()</span><br></pre></td></tr></table></figure></li><li><p>Transformation:延迟性操作</p></li><li><p>action：立即操作</p></li></ul><p><img src="/blog/img/Spark_6.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&#x27;test&#x27;</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"><span class="comment">## 直接创建</span></span><br><span class="line">list_rdd = [(<span class="string">&#x27;a&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">25</span>)]</span><br><span class="line">rdd = sc.parallelize(list_rdd)</span><br><span class="line"><span class="comment">#为数据添加列名</span></span><br><span class="line">people = rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: Row(name=x[<span class="number">0</span>], age=<span class="built_in">int</span>(x[<span class="number">1</span>])))</span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">df = spark.createDataFrame(people)</span><br><span class="line"><span class="comment"># 显示数据结构</span></span><br><span class="line">df.printSchema()</span><br><span class="line"><span class="comment"># 显示前10条数据</span></span><br><span class="line">df.show()</span><br><span class="line"><span class="comment"># 统计行数</span></span><br><span class="line">df.count()</span><br><span class="line"><span class="comment"># 显示列名</span></span><br><span class="line">df.columns</span><br><span class="line"><span class="comment"># 增加一个新列，如果列名是原本就有的，就会替换原有列</span></span><br><span class="line">df.withColumn(<span class="string">&quot;列名&quot;</span>，df.age*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 删除列</span></span><br><span class="line">df.drop(<span class="string">&#x27;列名&#x27;</span>).show()</span><br><span class="line"><span class="comment"># 提取部分列</span></span><br><span class="line">df.select(<span class="string">&#x27;列名1&#x27;</span>，<span class="string">&#x27;列名2&#x27;</span>).show()</span><br><span class="line"><span class="comment"># 分组统计</span></span><br><span class="line">df.groupby().age(&#123;<span class="string">&#x27;列名1&#x27;</span>:<span class="string">&#x27;函数名&#x27;</span>, <span class="string">&#x27;列名2&#x27;</span>:<span class="string">&#x27;函数名&#x27;</span>&#125;).show()</span><br><span class="line"><span class="comment"># 自带函数</span></span><br><span class="line"><span class="comment"># avg(), count(), countDistinct(), first(), kurtosis(),</span></span><br><span class="line"><span class="comment"># max(), mean(), min(), skewness(), stddev(), stddev_pop(),</span></span><br><span class="line"><span class="comment"># stddev_samp(), sum(), sumDistinct(), var_pop(), var_samp() variance()</span></span><br><span class="line"><span class="comment"># 自定义的汇总方法</span></span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> fn</span><br><span class="line"><span class="comment"># 调用函数并起一个别名</span></span><br><span class="line">df.agg(fn.count(<span class="string">&#x27;SepalWidth&#x27;</span>).alias(<span class="string">&#x27;width_count&#x27;</span>),fn.countDistinct(<span class="string">&#x27;cls&#x27;</span>).alias(<span class="string">&#x27;distinct_cls_count&#x27;</span>)).show()</span><br><span class="line"><span class="comment"># 按比例拆分数据集</span></span><br><span class="line">trainDF，testDF = df.randomSplit([<span class="number">0.8</span>, <span class="number">0.2</span>])</span><br><span class="line"><span class="comment"># 采样数据sample(是否有放回的采样，采样比例，随机种子)</span></span><br><span class="line">df.sample(<span class="literal">False</span>, <span class="number">0.2</span>, <span class="number">100</span>).show()</span><br><span class="line"><span class="comment"># 查看两个数据集在类别上的差异</span></span><br><span class="line">testDF.select(<span class="string">&#x27;cls&#x27;</span>).subtract(trainDF.select(<span class="string">&#x27;cls&#x27;</span>)).distinct().count()</span><br><span class="line"><span class="comment"># 交叉表</span></span><br><span class="line">df.crosstab(<span class="string">&#x27;cls&#x27;</span>,<span class="string">&#x27;SepalLength&#x27;</span>).show()</span><br></pre></td></tr></table></figure><h1 id="SparkStreaming"><a href="#SparkStreaming" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h1><h3 id="SparkStreaming概述"><a href="#SparkStreaming概述" class="headerlink" title="SparkStreaming概述"></a>SparkStreaming概述</h3><ul><li>它是一个可扩展，高吞吐具有容错性的流式计算框架</li></ul><p>spark-core和spark-sql都是处理属于离线批处理任务。数据一般都是在固定位置上，通常我们写好一个脚本，每天定时取处理数据、计算、保存数据结果。但是有些任务是需要实时处理的，仅仅能够容忍的延迟1秒内。</p><h3 id="实时计算框架对比"><a href="#实时计算框架对比" class="headerlink" title="实时计算框架对比"></a>实时计算框架对比</h3><ul><li>Storm<ul><li>流式计算框架</li><li>以record为单位处理数据</li><li>也支持micro-batch方式(Trident)</li></ul></li><li>Spark<ul><li>批处理计算框架</li><li>以RDD为单位处理数据</li><li>支持micro-batch流式处理数据(Spark Streaming)</li></ul></li><li>对比<ul><li>吞吐量：Spark Streaming优于Storm</li><li>延时：Spark Streaming差于Storm</li></ul></li></ul><h3 id="SparkStreaming组件"><a href="#SparkStreaming组件" class="headerlink" title="SparkStreaming组件"></a>SparkStreaming组件</h3><ul><li>Streaming Context<ul><li>一旦一个Context已经启动(调用了Streaming Context的start()),就不能有新的流算子(Dstream)建立或者是添加到context中</li><li></li><li>一旦一个context已经停止,不能重新启动(Streaming Context调用了stop方法之后 就不能再次调 start())</li><li>在JVM(java虚拟机)中, 同一时间只能有一个Streaming Context处于活跃状态, 一个SparkContext创建一个Streaming Context</li><li>在Streaming Context上调用Stop方法, 也会关闭SparkContext对象, 如果只想仅关闭Streaming Context对象,设置stop()的可选参数为false</li><li>一个SparkContext对象可以重复利用去创建多个Streaming Context对象(不关闭SparkContext前提下), 但是需要关一个再开下一个</li></ul></li><li>DStream (离散流)<ul><li>代表一个连续的数据流</li><li>在内部, DStream由一系列连续的RDD组成</li><li>DStreams中的每个RDD都包含确定时间间隔内的数据</li><li>任何对DStreams的操作都转换成了对DStreams隐含的RDD的操作</li><li>数据源<ul><li>基本源<ul><li>TCP/IP Socket</li><li>FileSystem</li></ul></li><li>高级源<ul><li>Kafka</li><li>Flume</li></ul></li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 配置spark driver和pyspark运行时，所使用的python解释器路径</span></span><br><span class="line">PYSPARK_PYTHON = <span class="string">&quot;python解释器路径&quot;</span></span><br><span class="line">JAVA_HOME=<span class="string">&#x27;jdk路径&#x27;</span></span><br><span class="line">SPARK_HOME = <span class="string">&quot;spark路径&quot;</span></span><br><span class="line"><span class="comment"># 当存在多个版本时，不指定很可能会导致出错</span></span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_DRIVER_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&#x27;JAVA_HOME&#x27;</span>]=JAVA_HOME</span><br><span class="line">os.environ[<span class="string">&quot;SPARK_HOME&quot;</span>] = SPARK_HOME</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> pyspark.streaming <span class="keyword">import</span> StreamingContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    sc = SparkContext(<span class="string">&quot;local[2]&quot;</span>,appName=<span class="string">&quot;NetworkWordCount&quot;</span>)</span><br><span class="line">    <span class="comment">#参数2：指定执行计算的时间间隔</span></span><br><span class="line">    ssc = StreamingContext(sc, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#监听ip，端口上的上的数据</span></span><br><span class="line">    lines = ssc.socketTextStream(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#将数据按空格进行拆分为多个单词</span></span><br><span class="line">    words = lines.flatMap(<span class="keyword">lambda</span> line: line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="comment">#将单词转换为(单词，1)的形式</span></span><br><span class="line">    pairs = words.<span class="built_in">map</span>(<span class="keyword">lambda</span> word:(word,<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#统计单词个数</span></span><br><span class="line">    wordCounts = pairs.reduceByKey(<span class="keyword">lambda</span> x,y:x+y)</span><br><span class="line">    <span class="comment">#打印结果信息，会使得前面的transformation操作执行</span></span><br><span class="line">    wordCounts.pprint()</span><br><span class="line">    <span class="comment">#启动StreamingContext</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    <span class="comment">#等待计算结束</span></span><br><span class="line">    ssc.awaitTermination()</span><br></pre></td></tr></table></figure><h1 id="Spark-Streaming的状态操作"><a href="#Spark-Streaming的状态操作" class="headerlink" title="Spark Streaming的状态操作"></a>Spark Streaming的状态操作</h1><ul><li>在Spark Streaming中存在两种状态操作<ul><li>UpdateStateByKey</li><li>Windows操作</li></ul></li><li>使用有状态的transformation，需要开启Checkpoint<ul><li>Spark streaming的容错机制</li><li>它将足够多的信息checkpoint到某些具备容错性的存储系统，如HDFS上，以便出错时能够迅速恢复</li></ul></li></ul><h3 id="updateStateByKey"><a href="#updateStateByKey" class="headerlink" title="updateStateByKey"></a>updateStateByKey</h3><ul><li>Spark Streaming实现的时一个实时批处理操作，每隔一段时间将数据进行打包，封装成RDD，是无状态的。</li><li>如果我们需要拿一天的数据来进行离线处理，我们得把rdd数据放让mysql中，再取再进行计算，而updateStateByKey可以解决这种问题</li></ul><p>监听网络端口的数据，获取到每个批次的出现的单词数量，并且需要把每个批次的信息保留下来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 配置spark driver和pyspark运行时，所使用的python解释器路径</span></span><br><span class="line">PYSPARK_PYTHON = <span class="string">&quot;python解释器路径&quot;</span></span><br><span class="line">JAVA_HOME=<span class="string">&#x27;java路径&#x27;</span></span><br><span class="line">SPARK_HOME = <span class="string">&quot;spark路径&quot;</span></span><br><span class="line"><span class="comment"># 当存在多个版本时，不指定很可能会导致出错</span></span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_DRIVER_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&#x27;JAVA_HOME&#x27;</span>]=JAVA_HOME</span><br><span class="line">os.environ[<span class="string">&quot;SPARK_HOME&quot;</span>] = SPARK_HOME</span><br><span class="line"><span class="keyword">from</span> pyspark.streaming <span class="keyword">import</span> StreamingContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.session <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SparkContext</span></span><br><span class="line">spark = SparkSession.builder.master(<span class="string">&quot;local[2]&quot;</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">ssc = StreamingContext(sc, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#开启检查点</span></span><br><span class="line">ssc.checkpoint(<span class="string">&quot;checkpoint&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义state更新函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateFunc</span>(<span class="params">new_values, last_sum</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(new_values) + (last_sum <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">lines = ssc.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment"># 对数据以空格进行拆分，分为多个单词</span></span><br><span class="line">counts = lines.flatMap(<span class="keyword">lambda</span> line: line.split(<span class="string">&quot; &quot;</span>)) \</span><br><span class="line">    .<span class="built_in">map</span>(<span class="keyword">lambda</span> word: (word, <span class="number">1</span>)) \</span><br><span class="line">    .updateStateByKey(updateFunc=updateFunc)<span class="comment">#应用updateStateByKey函数</span></span><br><span class="line"></span><br><span class="line">counts.pprint()</span><br><span class="line"></span><br><span class="line">ssc.start()</span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li><p>窗口长度L：运算的数据量</p></li><li><p>滑动间隔G：控制每隔多长时间做一次运算     </p></li></ul><p>每隔G秒，统计最近L秒的数据</p><p><img src="/blog/img/Spark_7.png"></p><ul><li>操作细节<ul><li>Window操作是基于窗口长度和滑动间隔来工作的</li><li>窗口的长度控制考虑前几批次数据量</li><li>默认为批处理的滑动间隔来确定计算结果的频率           </li></ul></li><li>相关函数</li></ul><p><img src="/blog/img/Spark_8.png"></p><p>reduceByKeyAndWindow(func,invFunc,windowLength,slidelnterval,[num,Tasks])</p><p>func:正向操作，类似于updateStateByKey</p><p>invFunc:反向操作                                                                                                                                                                                                                                                                                      </p><p>监听网络端口的数据，每隔3秒统计前6秒出现的单词数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 配置spark driver和pyspark运行时，所使用的python解释器路径</span></span><br><span class="line">PYSPARK_PYTHON = <span class="string">&quot;python解释器&quot;</span></span><br><span class="line">JAVA_HOME=<span class="string">&#x27;java路径&#x27;</span></span><br><span class="line">SPARK_HOME = <span class="string">&quot;spark路径&quot;</span></span><br><span class="line"><span class="comment"># 当存在多个版本时，不指定很可能会导致出错</span></span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_DRIVER_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&#x27;JAVA_HOME&#x27;</span>]=JAVA_HOME</span><br><span class="line">os.environ[<span class="string">&quot;SPARK_HOME&quot;</span>] = SPARK_HOME</span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> pyspark.streaming <span class="keyword">import</span> StreamingContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.session <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_countryname</span>(<span class="params">line</span>):</span></span><br><span class="line">    country_name = line.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> country_name == <span class="string">&#x27;usa&#x27;</span>:</span><br><span class="line">        output = <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> country_name == <span class="string">&#x27;ind&#x27;</span>:</span><br><span class="line">        output = <span class="string">&#x27;India&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> country_name == <span class="string">&#x27;aus&#x27;</span>:</span><br><span class="line">        output = <span class="string">&#x27;Australia&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (output, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#定义处理的时间间隔</span></span><br><span class="line">    batch_interval = <span class="number">1</span> <span class="comment"># base time unit (in seconds)</span></span><br><span class="line">    <span class="comment">#定义窗口长度</span></span><br><span class="line">    window_length = <span class="number">6</span> * batch_interval</span><br><span class="line">    <span class="comment">#定义滑动时间间隔</span></span><br><span class="line">    frequency = <span class="number">3</span> * batch_interval</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取StreamingContext</span></span><br><span class="line">    spark = SparkSession.builder.master(<span class="string">&quot;local[2]&quot;</span>).getOrCreate()</span><br><span class="line">    sc = spark.sparkContext</span><br><span class="line">    ssc = StreamingContext(sc, batch_interval)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#需要设置检查点</span></span><br><span class="line">    ssc.checkpoint(<span class="string">&quot;checkpoint&quot;</span>)</span><br><span class="line"></span><br><span class="line">    lines = ssc.socketTextStream(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    addFunc = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">    invAddFunc = <span class="keyword">lambda</span> x, y: x - y</span><br><span class="line">    <span class="comment">#调用reduceByKeyAndWindow，来进行窗口函数的调用</span></span><br><span class="line">    window_counts = lines.<span class="built_in">map</span>(get_countryname) \</span><br><span class="line">        .reduceByKeyAndWindow(addFunc, invAddFunc, window_length, frequency)</span><br><span class="line">    <span class="comment">#输出处理结果信息</span></span><br><span class="line">    window_counts.pprint()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 推荐系统 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor进程管理</title>
      <link href="/blog/2018/06/02/supervisor/"/>
      <url>/blog/2018/06/02/supervisor/</url>
      
        <content type="html"><![CDATA[<h1 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h1><p><strong>sudo pip install supervisor :安装supervisor，因为对python3支持不好，所以不能安装到虚拟环境中</strong></p><p><strong>echo_supervisord_conf &gt; supervisord.conf : 运行echo_supervisord_conf命令输出默认的配置项保存到文件中</strong></p><p><strong>用vim打开supervisord.conf，在最后加入如下代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include] </span><br><span class="line">files &#x3D; &#x2F;ec&#x2F;supervisor&#x2F;*.conf </span><br></pre></td></tr></table></figure><p><strong>sudo cp supervisord.conf /etc/:将编辑后的supervisord.conf文件复制到/etc/目录下</strong></p><p><strong>然后我们在/etc目录下新建子目录supervisor（与配置文件里的选项相同），并在/etc/supervisor/中新建tuotiao</strong></p><p><strong>管理的配置文件toutiao.conf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[group:toutiao]  # 组名 </span><br><span class="line">programs&#x3D;toutiao-app  </span><br><span class="line"></span><br><span class="line">[program:toutiao-app]  #配置项名字 </span><br><span class="line">command&#x3D;&#x2F;home&#x2F;python&#x2F;scripts&#x2F;toutiao_app.sh #执行命令 </span><br><span class="line">directory&#x3D;&#x2F;home&#x2F;python&#x2F;toutiao-backend # app文件夹 user&#x3D;python  </span><br><span class="line"># 执行用户 </span><br><span class="line">autorestart&#x3D;true </span><br><span class="line">redirect_stderr&#x3D;false </span><br><span class="line">loglevel&#x3D;info </span><br><span class="line">stopsignal&#x3D;KILL </span><br><span class="line">stopasgroup&#x3D;true </span><br><span class="line">killasgroup&#x3D;true  </span><br><span class="line"></span><br><span class="line">[program:im] </span><br><span class="line">command&#x3D;&#x2F;home&#x2F;python&#x2F;scripts&#x2F;im.sh </span><br><span class="line">directory&#x3D;&#x2F;home&#x2F;python&#x2F;toutiao-backend </span><br><span class="line">user&#x3D;python </span><br><span class="line">autorestart&#x3D;true </span><br><span class="line">redirect_stderr&#x3D;false </span><br><span class="line">loglevel&#x3D;info </span><br><span class="line">stopsignal&#x3D;KILL </span><br><span class="line">stopasgroup&#x3D;true </span><br><span class="line">killasgroup&#x3D;true </span><br></pre></td></tr></table></figure><p><strong>supervisord -c /etc/supervisord.conf：启动</strong></p><p><strong>ps aux | grep supervisord：查看supervisord是否启动</strong></p><p><strong>我们可以利用supervisorctl来管理supervisor。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl</span><br><span class="line"></span><br><span class="line">status    # 查看程序状态</span><br><span class="line">start apscheduler  # 启动 apscheduler 单一程序</span><br><span class="line">stop toutiao:*   # 关闭 toutiao组 程序</span><br><span class="line">start toutiao:*  # 启动 toutiao组 程序</span><br><span class="line">restart toutiao:*    # 重启 toutiao组 程序</span><br><span class="line">update    ＃ 重启配置文件修改过的程序</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="/blog/2018/05/17/unittest/"/>
      <url>/blog/2018/05/17/unittest/</url>
      
        <content type="html"><![CDATA[<h1 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h1><p><strong>assert(断言)</strong>:和if not expression:/n    raise AssertionError /n  AssertionError效果一样</p><p><strong>使用unittest的TestCase编写单元测试</strong></p><figure class="highlight plain"><figcaption><span>unittest</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from ** import app  #导入flask的app对象</span><br><span class="line">class Mytest(unittest.TestCase):</span><br><span class="line"># 只要是以test开头的方法都会自动执行测试</span><br><span class="line">def setUp(self):</span><br><span class="line"># 该方法会首先执行，方法名为固定写法</span><br><span class="line">print(&#39;setUp&#39;)</span><br><span class="line">self.cli &#x3D; app.test_client()  #生成测试客户端</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line"># 该方法会在测试代码执行完后执行，方法名为固定写法</span><br><span class="line">print(&#39;tearDown&#39;)</span><br><span class="line"></span><br><span class="line">def test_wrong_mobile(self):</span><br><span class="line">print(&#39;test_wrong_mobile&#39;)</span><br><span class="line">mobile &#x3D; &#39;12345678901&#39;</span><br><span class="line">ret &#x3D; self.cli.get(&#39;&#x2F;ret_mobile&#x2F;%s&#39; %(mobile))</span><br><span class="line"># assert ret.status_code &#x3D;&#x3D; 404</span><br><span class="line">self.assertEqual(ret.status_code, 404) #效果和assert一样</span><br><span class="line"></span><br><span class="line">def test_right_mobile(self):</span><br><span class="line">print(&#39;test_right_mobile&#39;)</span><br><span class="line">mobile &#x3D; &#39;13411111111&#39;</span><br><span class="line">ret &#x3D; self.cli.get(&#39;&#x2F;ret_mobile&#x2F;%s&#39; % (mobile))</span><br><span class="line">assert ret.status_code &#x3D;&#x3D; 200</span><br><span class="line">assert ret.data.decode() &#x3D;&#x3D; mobile</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p><strong>使用TestSuite套件添加已有测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suite &#x3D; unittest.Testsuite()    #创建套件实例 </span><br><span class="line">suite.addTest(类名(&#39;方法名&#39;))或(类名.方法名)  #添加测试的函数方法</span><br><span class="line">suite.addTest(unittest.makeSuitw(类名))  # 添加需要运行的测试类 </span><br></pre></td></tr></table></figure><p><strong>使用TextTestRunner套件执行测试套件实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runner &#x3D; unittest.TextTestRunner()   #创建运行实例 </span><br><span class="line">runner.run(suite)   # 运行测试套件 </span><br></pre></td></tr></table></figure><p><strong>使用defaultTestLoader添加测试类文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disconver &#x3D; unittest.defaultTestLoader.discover(&#39;.py文件路径&#39;,pattern&#x3D;&#39;*.py&#39;)  # 匹配路径下的&#39;*.py&#39;文件 </span><br><span class="line">runner &#x3D; unittest.TextTestRunner() </span><br><span class="line">runner.run(disconver) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>断言：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.assertEqual(arg1, arg2,msg&#x3D;None)    #验证arg1&#x3D;arg2，不等于就抛出错误</span><br><span class="line">self.assertNotEqual(arg1, arg2, msg&#x3D;None)   #验证arg1!&#x3D;arg2, 相等就抛出错误 </span><br><span class="line">self.assertTrue(expr, msg&#x3D;None)           # 验证expr是True，如果是False则抛出错误 </span><br><span class="line">self.assertFalse(expr, msg&#x3D;None)         # 验证ecpr为False，如果是True则抛出错误 </span><br><span class="line">self.assertlsNone(expr, msg&#x3D;None)        #验证expr为None，不是则抛出错误 </span><br><span class="line">self.assertlsNotNone(expr, msg&#x3D;None)     # 验证expr不为None，不是则抛出错误 </span><br><span class="line">self.assertIn(arg1, arg2, msg&#x3D;None)     # 验证arg1是arg2的子串，不是则抛出错误</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署flask项目全流程</title>
      <link href="/blog/2018/05/02/web%E9%83%A8%E7%BD%B2/"/>
      <url>/blog/2018/05/02/web%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-购买阿里云服务器"><a href="#1-购买阿里云服务器" class="headerlink" title="1.购买阿里云服务器"></a>1.购买阿里云服务器</h3><ul><li><p>基础配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.计费方式 - 按量付费</span><br><span class="line">2.地域选择 - 华南（深圳）</span><br><span class="line">3.实例</span><br><span class="line">  架构-&gt; x86计算</span><br><span class="line">  分类-&gt; 计算型</span><br><span class="line">  规格族-&gt; 计算型c5 4vCPU 8GiB</span><br><span class="line">  价格: 1.260&#x2F;小时</span><br><span class="line">4.操作系统 - centos 7.2 64位</span><br><span class="line">5.存储 - 高效云盘 40g</span><br></pre></td></tr></table></figure></li><li><p>网络和安全组 - 不用改</p></li><li><p>系统配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自定义密码</span><br><span class="line">root 密码(大小写字符+数字):</span><br><span class="line">主机名-&gt; toutiao-web</span><br></pre></td></tr></table></figure></li><li><p>分组设置 - 不用填</p></li><li><p>确认订单 - 下一步</p></li><li><p>购买成功(得先充钱，最低100)</p></li><li><p>进入控制台</p></li><li><p>找到公网ip地址</p></li><li><p>使用Termius连接服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.NEW HOST</span><br><span class="line">Label-&gt; ali-toutiao-web</span><br><span class="line">Address-&gt; 服务器的公网ip地址</span><br><span class="line">SSH</span><br><span class="line">Username -&gt; root</span><br><span class="line">Password -&gt; 密码</span><br><span class="line">2.保存</span><br><span class="line">3.双击打开</span><br><span class="line">4.创建python用户</span><br><span class="line">useradd python</span><br><span class="line">5.修改python用户密码</span><br><span class="line">passwd python</span><br></pre></td></tr></table></figure></li><li><p>设置网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装ifconfig工具</span></span><br><span class="line">sudo yum install net-tools -y</span><br></pre></td></tr></table></figure></li><li><p>设置主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname toutiao-web</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-安装主MySQL"><a href="#2-安装主MySQL" class="headerlink" title="2.安装主MySQL"></a>2.安装主MySQL</h3><ul><li><p>添加MariaDB软件源</p><ul><li><p>在/etc/yum.repos.d/目录中添加MariaDB.repo文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo vi /etc/yum.repos.d/MariaDB.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加以下内容:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> MariaDB 10.3 CentOS repository list - created 2018-11-24 14:39 UTC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://downloads.mariadb.org/mariadb/repositories/</span></span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl = http://yum.mariadb.org/10.3/centos7-amd64</span></span><br><span class="line">baseurl = http://mirrors.ustc.edu.cn/mariadb/yum/10.3/centos7-amd64</span><br><span class="line"><span class="meta">#</span><span class="bash">gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB</span></span><br><span class="line">gpgkey=http://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装MariaDB(1分钟)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install MariaDB-server MariaDB-client mariadb-devel MariaDB-shared -y</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/my.cnf.d/server.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [mysqld] 标签下方添加</span></span><br><span class="line"></span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27; </span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27; </span><br><span class="line">character-set-server=utf8 </span><br><span class="line">collation-server=utf8_unicode_ci </span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/my.cnf.d/client.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [client] 标签下方添加</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/my.cnf.d/mysql-clients.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [mysql] 标签下方添加</span></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line">sudo systemctl enable mariadb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mariadb</span></span><br><span class="line">sudo systemctl start mariadb</span><br></pre></td></tr></table></figure></li><li><p>设置root账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始密码为空</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码为: mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面的设置一路yes即可</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试: mysql -uroot -p</span></span><br></pre></td></tr></table></figure></li><li><p>Python客户端依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要使用mysql的python客户端库mysqlclient，安装依赖包</span></span><br><span class="line">sudo yum install python-devel zlib-devel openssl-devel -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用docker安装从MySQL"><a href="#3-使用docker安装从MySQL" class="headerlink" title="3. 使用docker安装从MySQL"></a>3. 使用docker安装从MySQL</h3><ul><li><p>安装Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装docker依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载并安装docker (2-3分钟)</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试docker</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></li><li><p>使用Docker安装MySQL(1分钟)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mariadb:10.3.13</span><br></pre></td></tr></table></figure></li><li><p>配置MySQL主从同步</p><ul><li><p>配置MySQL master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master 配置文件: /etc/my.cnf.d/server.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/my.cnf.d/server.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [mysqld] 标签下方添加</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure></li><li><p>重启主mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure></li><li><p>配置MySQL slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把master的配置拷过去作为从的配置</span></span><br><span class="line">sudo cp -r /etc/my.cnf.d/ /opt/my.cnf.d-slave</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改从的配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /opt/my.cnf.d-slave/server.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [mysqld] 标签下方修改</span></span><br><span class="line">server-id=10</span><br><span class="line">read_only=on</span><br><span class="line">port=8306</span><br></pre></td></tr></table></figure></li><li><p>启动docker容器mysql slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name mariadb -v /opt/my.cnf.d-slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mysql -v /opt/mysql-slave-data:/var/lib/mysql -d --network=host mariadb:10.3.13</span><br></pre></td></tr></table></figure></li><li><p>为mysql master添加用于同步复制的账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27; identified by &#x27;slave&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li><li><p>查看mysql master状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></li><li><p>设置mysql slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -h 127.0.0.1 -P 8306</span><br><span class="line">change master to master_host&#x3D;&#39;127.0.0.1&#39;, master_user&#x3D;&#39;slave&#39;, master_password&#x3D;&#39;slave&#39;,master_log_file&#x3D;&#39;mysql-bin.000001&#39;, master_log_pos&#x3D;637;</span><br></pre></td></tr></table></figure></li><li><p>注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master_log_file要改成show master status中的文件名</span><br><span class="line">master_log_pos要改成show master status中的Position值</span><br><span class="line">start slave;</span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从虚拟机中导出数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -pmysql --databases toutiao &gt;&#x2F;home&#x2F;python&#x2F;toutiao.sql</span><br></pre></td></tr></table></figure></li><li><p>导入头条数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传sql文件到服务器中(5分钟)</span></span><br><span class="line">scp toutiao.sql root@39.108.69.171:/home/python</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从sql文件中导入数据</span></span><br><span class="line">mysql -uroot -p &lt; toutiao.sql</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-安装redis"><a href="#4-安装redis" class="headerlink" title="4.安装redis"></a>4.安装redis</h3><ul><li><p>从虚拟机中上传redis压缩文件到服务器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp redis-4.0.13.tar.gz root@120.77.33.51:/root/</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-4.0.13.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装gcc。 编译redis，需要用到gcc编译器</span></span><br><span class="line">sudo yum install gcc -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再装redis</span></span><br><span class="line">cd redis-4.0.13</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="5-配置redis集群"><a href="#5-配置redis集群" class="headerlink" title="5.配置redis集群"></a>5.配置redis集群</h3></li><li><p>从虚拟机中上传redis集群配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在服务器中创建redis目录, 用于存放redis配置</span></span><br><span class="line">mkdir -p /etc/redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机中上传文件</span></span><br><span class="line">scp /etc/redis/* root@120.77.33.51:/etc/redis</span><br></pre></td></tr></table></figure></li><li><p>安装Ruby</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载ruby (1分钟)</span></span><br><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.1.tar.gz</span><br><span class="line">tar -zxvf ruby-2.6.1.tar.gz</span><br><span class="line">cd ruby-2.6.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置(1分钟)</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta">#</span><span class="bash"> make 比较耗时(4分钟)</span></span><br><span class="line">sudo make </span><br><span class="line">sudo make install</span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure></li><li><p>从服务器中上传redis启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;opt&#x2F;redis-* root@39.108.69.171:&#x2F;opt</span><br></pre></td></tr></table></figure></li><li><p>创建存放redis数据库的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lib/redis/7000</span><br><span class="line">mkdir -p /var/lib/redis/7001</span><br><span class="line">mkdir -p /var/lib/redis/7002</span><br><span class="line">mkdir -p /var/lib/redis/7003</span><br><span class="line">mkdir -p /var/lib/redis/7004</span><br><span class="line">mkdir -p /var/lib/redis/7005</span><br><span class="line">mkdir -p /var/lib/redis/6381</span><br><span class="line">mkdir -p /var/lib/redis/6380</span><br></pre></td></tr></table></figure></li><li><p>启动redis集群实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先给脚本执行权限</span></span><br><span class="line">chmod +x /opt/redis-cluster-start.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令</span></span><br><span class="line">/opt/redis-cluster-start.sh</span><br></pre></td></tr></table></figure></li><li><p>启动cluster集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拷贝redis-trib.rb命令到搜索路径下</span></span><br><span class="line">sudo cp /home/python/redis-4.0.13/src/redis-trib.rb /usr/local/bin/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建集群</span></span><br><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure></li><li><p>测试redis集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 7000</span><br></pre></td></tr></table></figure><h3 id="6-redis主从"><a href="#6-redis主从" class="headerlink" title="6.redis主从"></a>6.redis主从</h3></li><li><p>使用脚本启动redis主从</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加执行权限</span></span><br><span class="line">chmod +x /opt/redis-replication-start.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行脚本，启动主从redis、哨兵</span></span><br><span class="line">/opt/redis-replication-start.sh</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-安装rabbitmq"><a href="#7-安装rabbitmq" class="headerlink" title="7.安装rabbitmq"></a>7.安装rabbitmq</h3><ul><li><p>安装erlang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/etc/yum.repos.d/目录中添加rabbitmq_erlang.repo文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo vim /etc/yum.repos.d/rabbitmq_erlang.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件中添加</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In /etc/yum.repos.d/rabbitmq_erlang.repo</span></span><br><span class="line">[rabbitmq-erlang]</span><br><span class="line">name=rabbitmq-erlang</span><br><span class="line">baseurl=https://dl.bintray.com/rabbitmq-erlang/rpm/erlang/21/el/7</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行安装(测试时安装1分钟，实际安装，需要换源)</span></span><br><span class="line">sudo yum install erlang -y</span><br></pre></td></tr></table></figure></li><li><p>安装RabbitMQ</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/etc/yum.repos.d/目录中添加rabbitmq_server.repo文件</span></span><br><span class="line">vim /etc/yum.repos.d/rabbitmq_server.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件中添加</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In /etc/yum.repos.d/rabbitmq_server.repo</span></span><br><span class="line">[bintray-rabbitmq-server]</span><br><span class="line">name=bintray-rabbitmq-rpm</span><br><span class="line">baseurl=https://dl.bintray.com/rabbitmq/rpm/rabbitmq-server/v3.7.x/el/7/</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行安装(实际安装1分钟)</span></span><br><span class="line">sudo yum install rabbitmq-server -y</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig rabbitmq-server on</span><br><span class="line">sudo systemctl start  rabbitmq-server.service</span><br></pre></td></tr></table></figure></li><li><p>头条项目账号设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user python rabbitmqpwd</span><br><span class="line">sudo rabbitmqctl add_vhost toutiao</span><br><span class="line">sudo rabbitmqctl set_user_tags python administrator</span><br><span class="line">sudo rabbitmqctl set_permissions -p toutiao python &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-安装Elasticsearch5"><a href="#8-安装Elasticsearch5" class="headerlink" title="8.安装Elasticsearch5"></a>8.安装Elasticsearch5</h3><ul><li><p>安装wget</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install wget -y</span><br></pre></td></tr></table></figure></li><li><p>下载jdk 官网密码: 13423682841_qinzhiWang</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载页:</span><br><span class="line">https:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;java&#x2F;javase&#x2F;downloads&#x2F;jdk8-downloads-2133151.html</span><br><span class="line">下载前得先创建账号</span><br><span class="line">选中xxx-linux-x64.rpm 或者 xxx-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh &#x2F;home&#x2F;python&#x2F;jdk-8u221-linux-x64.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装后查看java版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>设置python登录时的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在最后添加</span></span><br><span class="line">export JAVA_HOME=/usr/java/default</span><br></pre></td></tr></table></figure></li><li><p>安装Elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/etc/yum.repos.d/ 中编辑elasticsearch5x.repo</span></span><br><span class="line">vim /etc/yum.repos.d/elasticsearch5x.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加以下内容</span></span><br><span class="line">[elasticsearch-5.x]</span><br><span class="line">name=Elasticsearch repository for 5.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/5.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>执行安装(7分钟, 实测30秒)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install elasticsearch -y</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">sudo systemctl enable elasticsearch.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动elasticsearch</span></span><br><span class="line">sudo systemctl start elasticsearch.service</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200&#x2F;_cluster&#x2F;health?pretty</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-安装中文分词器"><a href="#9-安装中文分词器" class="headerlink" title="9.安装中文分词器"></a>9.安装中文分词器</h3><ul><li><p>上传ik文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp elasticsearch-analysis-ik-5.6.16.zip root@120.77.33.51:&#x2F;root</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/share/elasticsearch/bin/elasticsearch-plugin install file:///home/python/elasticsearch-analysis-ik-5.6.16.zip</span><br></pre></td></tr></table></figure></li><li><p>重新启动elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET 127.0.0.1:9200/_analyze?pretty -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;我是&amp;中国人&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl -X GET 127.0.0.1:9200/_analyze?pretty -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;我是&amp;中国人&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="10-安装git"><a href="#10-安装git" class="headerlink" title="10.安装git"></a>10.安装git</h3></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure></li><li><p>拉取项目代码(python)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;git.meiduo.site&#x2F;csjy6&#x2F;toutiao-backend.git</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-Logstach安装-换成脚本导入import-es-data-py"><a href="#11-Logstach安装-换成脚本导入import-es-data-py" class="headerlink" title="11.Logstach安装(换成脚本导入import_es_data.py)"></a>11.Logstach安装(换成脚本导入import_es_data.py)</h3><ul><li><p>安装Logstach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加Logstach yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/yum.repos.d/logstash.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入内容</span></span><br><span class="line">[logstash-6.x]</span><br><span class="line">name=Elastic repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>安装 (超慢，提前安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install logstash -y</span><br></pre></td></tr></table></figure></li><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/logstash/bin/</span><br><span class="line">sudo ./logstash-plugin install logstash-input-jdbc</span><br><span class="line">sudo ./logstash-plugin install logstash-output-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>上传mysql-connector到服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp mysql-connector-java-8.0.13.tar.gz python@120.78.184.139:/home/python</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mysql-connector-java-8.0.13.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>执行脚本导入数据到elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/python/toutiao-backend/scripts/import_elasticsearch_data.sh</span><br></pre></td></tr></table></figure></li><li><p>使用import_es_data.py导入es数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workon toutiao</span><br><span class="line">cd /home/python/toutiao-backend</span><br><span class="line">python scripts/import_es_data.py</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-安装虚拟环境"><a href="#12-安装虚拟环境" class="headerlink" title="12.安装虚拟环境"></a>12.安装虚拟环境</h3><ul><li><p>安装虚拟环境(使用python 用户)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure></li><li><p>配置虚拟环境命令环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录用来存放虚拟环境</span></span><br><span class="line">mkdir $HOME/.virtualenvs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开~/.bash_profile文件，并添加如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim ~/.bash_profile</span></span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source /usr/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重连</span></span><br><span class="line">workon</span><br></pre></td></tr></table></figure></li><li><p>安装python3</p><ul><li><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.4&#x2F;Python-3.6.4.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d Python-3.6.4.tar.xz</span><br><span class="line">tar -xf Python-3.6.4.tar</span><br></pre></td></tr></table></figure></li><li><p>安装sqlite3(一定要先装，再装python，不然会报各种未知错误)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install sqlite-devel -y</span><br></pre></td></tr></table></figure></li><li><p>编译&amp;安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line">./configure prefix=/usr/local/python3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译&amp;安装(2分钟)</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>配置python3命令可以搜索 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加以下内容</span></span><br><span class="line">export PATH=$PATH:/usr/local/python3/bin/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建头条虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv -p python3 toutiao</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workon toutiao</span><br><span class="line">cd /home/python/toutiao-backend</span><br><span class="line"><span class="meta">#</span><span class="bash"> 大概(5分钟)</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-配置项目代码"><a href="#13-配置项目代码" class="headerlink" title="13.配置项目代码"></a>13.配置项目代码</h3><ul><li><p>git配置永久保存密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></li><li><p>创建logs日志文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;python&#x2F;logs</span><br></pre></td></tr></table></figure></li><li><p>运行代码测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=toutiao.main</span><br><span class="line">export FLASK_ENV=production</span><br><span class="line">flask run</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:5000</span><br></pre></td></tr></table></figure></li><li><p>使用脚本运行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  sh /home/python/toutiao-backend/scripts/toutiao_app.sh</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 加上可执行权限</span></span><br><span class="line">chmod +x /home/python/toutiao-backend/scripts/toutiao_app.sh</span><br><span class="line">  /home/python/toutiao-backend/scripts/toutiao_app.sh</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-安装supervisord"><a href="#14-安装supervisord" class="headerlink" title="14.安装supervisord"></a>14.安装supervisord</h3><ul><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure></li><li><p>生成默认配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/supervisord.conf 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/supervisord.conf</span> </span><br><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改成</span></span><br><span class="line">[include]</span><br><span class="line">files = /home/python/etc/supervisor/*.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建存放supervisor配置文件夹</span></span><br><span class="line">mkdir -p /home/python/etc/supervisor/</span><br></pre></td></tr></table></figure></li><li><p>启动supervisord(使用python用户)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure></li><li><p>配置项目由supervisord管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建toutiao_app_supervisor软链接</span></span><br><span class="line">ln -s /home/python/toutiao-backend/scripts/toutiao_app_supervisor.conf /home/python/etc/supervisor/toutiao_app_supervisor.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建im_supervisor软链接</span></span><br><span class="line">ln -s /home/python/toutiao-backend/scripts/im_supervisor.conf /home/python/etc/supervisor/im_supervisor.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建apscheduler_supervisor软链接</span></span><br><span class="line">ln -s /home/python/toutiao-backend/scripts/apscheduler_supervisor.conf /home/python/etc/supervisor/apscheduler_supervisor.conf</span><br></pre></td></tr></table></figure></li><li><p>给命令加上执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /home/python/toutiao-backend/scripts/im.sh</span><br><span class="line">chmod +x /home/python/toutiao-backend/scripts/toutiao_app.sh</span><br><span class="line">chmod +x /home/python/toutiao-backend/scripts/apscheduler.sh</span><br></pre></td></tr></table></figure></li><li><p>重新加载配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:5000</span><br></pre></td></tr></table></figure><h3 id="15-nginx"><a href="#15-nginx" class="headerlink" title="15.nginx"></a>15.nginx</h3></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li><li><p>创建nginx日志文件夹(python用户)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/python/logs/nginx</span><br></pre></td></tr></table></figure></li><li><p>配置反向代理访问项目</p></li><li><p>添加toutiao配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/nginx/conf.d/toutiao.conf</span></span><br><span class="line">upstream toutiao-api-backend &#123;</span><br><span class="line">      server localhost:5000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name toutiao.com;</span><br><span class="line">    access_log /home/python/logs/nginx/toutiao.com.access.log main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        client_max_body_size 5M;</span><br><span class="line">        proxy_pass http://toutiao-api-backend;</span><br><span class="line">        proxy_set_header X-Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header Connection &#x27;&#x27;;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加im配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/nginx/conf.d/im.conf</span></span><br><span class="line">upstream im-backend &#123;</span><br><span class="line">      server localhost:7777;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name toutiao_im.com;</span><br><span class="line">    access_log /home/python/logs/nginx/toutiao_im.com.access.log main;</span><br><span class="line"></span><br><span class="line">    location /socket.io/ &#123;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header User-Agent $http_user_agent;</span><br><span class="line">        proxy_pass http://im-backend;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>配置本地hosts指向服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/hosts</span></span><br><span class="line">120.77.33.51 toutiao.com</span><br><span class="line">120.77.33.51 toutiao_im.com</span><br></pre></td></tr></table></figure></li><li><p>测试 - 关注测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toutiao.com</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crontab定时任务</title>
      <link href="/blog/2017/08/12/crontab/"/>
      <url>/blog/2017/08/12/crontab/</url>
      
        <content type="html"><![CDATA[<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>crontab时linux自带的定时运行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  # 进入编辑任务行</span><br><span class="line">* * * * * 要执行的命令</span><br><span class="line">----------------</span><br><span class="line">| | | | |</span><br><span class="line">| | | | ---- 周当中的某天 (0 - 7) (周日为 0 或 7)</span><br><span class="line">| | | ------ 月份 (1 - 12)</span><br><span class="line">| | -------- 一月当中的某天 (1 - 31)</span><br><span class="line">| ---------- 小时 (0 - 23)</span><br><span class="line">------------ 分钟 (0 - 59)</span><br><span class="line"></span><br><span class="line"># 如</span><br><span class="line">### 每隔 5 分钟运行一次 backupscript 脚本 ##</span><br><span class="line">*&#x2F;5 * * * * &#x2F;root&#x2F;backupscript.sh</span><br><span class="line">### 每天的凌晨 1 点运行 backupscript 脚本 ##</span><br><span class="line">0 1 * * * &#x2F;root&#x2F;backupscript.sh</span><br><span class="line">### 每月的第一个凌晨 3:15 运行 backupscript 脚本 ##</span><br><span class="line">15 3 1 * * &#x2F;root&#x2F;backupscript.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  # 修改crontab文件，如果不存在会自动创建 </span><br><span class="line">crontab -l  # 显示crontab文件 </span><br><span class="line">crontab -r  # 删除crontab文件 </span><br><span class="line">crontab -ir  # 删除crontab文件前提醒用户  </span><br><span class="line">service crond status  #查看crontab服务状态 </span><br><span class="line">service crond start   # 启动服务 </span><br><span class="line">service crond stop    # 关闭服务 </span><br><span class="line">service crond restart  # 重启服务 </span><br><span class="line">service crond reload  # 重新载入配置</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cenos </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/blog/2017/05/13/git/"/>
      <url>/blog/2017/05/13/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol><li><p>git是代码多版本管理工具</p></li><li><p>分为线上和线下：</p><ul><li><p>用户机：用户机上传git push</p><ul><li>工作区：添加文件到暂存区 git add 文件或目录；删除文件git rm 文件</li><li>版本库：<ul><li>暂存区：从暂存区恢复文件git checkout –文件；查看记录git status</li><li>仓库区：提交到仓库git commit -m“”；恢复到暂存区git reset HEAD或版本号</li></ul></li></ul></li><li><p>服务器：服务器下载git pull或git checkout dev</p><p><img src="/blog/img/git_1.png"></p></li></ul></li><li><p>安装应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">yum install git   #安装git</span><br><span class="line">git init  #在本地新建仓库</span><br><span class="line"># 配置个人信息</span><br><span class="line">git config user.name &quot;name&quot;</span><br><span class="line">git config user.email &quot;email&quot;</span><br><span class="line">git status  # 查看文件状态</span><br><span class="line">git diff 文件名  # 查看文件修改部分</span><br><span class="line">git add 文件名   # 把工作区的文件添加到暂存区</span><br><span class="line">git commit 文件名 -m &quot;版本描述&quot; #把暂存区的文件提交到仓库区</span><br><span class="line"># 查看历史版本</span><br><span class="line">git log</span><br><span class="line">git reflog  #可以查看所有分支的所有操作记录，包括被删除了的</span><br><span class="line"># 版本回退</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">HEAD:表示最新版</span><br><span class="line">HEAD^:最新版的上一个版本</span><br><span class="line">HEAD^^：表示最新版的前两个版本，以此类推</span><br><span class="line">HEAD~1:最新版的第前一个版本</span><br><span class="line">HEAD~10：最新版的第前十个版本</span><br><span class="line">git reset --hard 版本号  #退回到指定版本</span><br><span class="line">ssh-keygen #生成公钥私钥，然后把公钥配置给GitHub</span><br><span class="line">git clone url #克隆远程仓库</span><br><span class="line">git pull  # 把远程仓库的代码拉下来</span><br><span class="line">git push  # 把本地仓库的代码传到远程仓库</span><br><span class="line">##############标签############</span><br><span class="line">git tag -a 标签名 -m “标签描述”  # 新建本地标签</span><br><span class="line">git push origin 标签名  # 把本地标签推送到远程</span><br><span class="line">git tag -d 标签名  # 删除本地标签</span><br><span class="line">git push origin --delete tag 标签名  # 删除远程标签</span><br><span class="line">##############分支##############</span><br><span class="line">git branch  # 查看分支</span><br><span class="line">git checkout -b 分支名   # 新建分支，并切换到分支</span><br><span class="line">git push -u origin 分支名   # 将分支推送到远程</span><br><span class="line">git checkout 分支名   # 切换分支</span><br><span class="line">git merge 分支名   #将分支与当前分支合并</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cenos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socketio即时通讯</title>
      <link href="/blog/2017/05/13/socketio/"/>
      <url>/blog/2017/05/13/socketio/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h1><p> pip install python-socketio</p><p> 以协程方式运行服务端（推荐）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import eventlet</span><br><span class="line">eventlet.monkey_patch()</span><br><span class="line">import socketio</span><br><span class="line">import eventlet.wsgi</span><br><span class="line">sio &#x3D; socketio.Server(async_mode&#x3D;&#39;eventlet&#39;) # 创建socket对象，并指定以协程方式运行</span><br><span class="line">app &#x3D; socketio.Middleware(sio) # 使用sio创建符合WSGI协议的app对象</span><br><span class="line">@sio.on(&#39;监听事件名&#39;) </span><br><span class="line">有两个特殊事件：</span><br><span class="line">connect(两个参数(sid,environ))：建立连接立即执行，并比其他事件多接收一个参数environ(握手数据)。</span><br><span class="line">disconnect(一个参数(sid))：断开连接立即执行。普通事件可以接收两个参数(sid,data(用户发过来是消息))</span><br><span class="line"></span><br><span class="line">def on_函数名(参数):</span><br><span class="line">sio.emit(&#39;事件名&#39;, 要发送的数据) #群发</span><br><span class="line">sio.send(要发送的数据，skip_sid&#x3D;sid) #跳过sid进行群发</span><br><span class="line">sio.emit(&#39;事件名&#39;, 要发送的数据,room&#x3D;room_name) # 只给roon_name房间里的人发送消息</span><br><span class="line">sio.enter_room(sid,房间名) #把sid加入带房间，每次连接时会默认执行一句sio.enter_room(sid,sid)</span><br><span class="line">如果是message消息，可以直接使用sio.send(data, room&#x3D;room_name)</span><br><span class="line"></span><br><span class="line">socket &#x3D; eventlet.listen((&#39;IP&#39;, 端口(整数)))  #创建socket对象</span><br><span class="line">eventlet.wsgi.server(socket, app) # 以协程的方式启动服务器</span><br></pre></td></tr></table></figure><p> web可调用的socketio：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mgr &#x3D; socketio.KombuManager(&#39;列队URL&#39;)  #创建列队对象</span><br><span class="line">sio &#x3D; socketio.Server(async_mode&#x3D;&#39;eventlet&#39;，client_manager&#x3D;mgr) # 创建socket对象，并指定以协程方式运行</span><br></pre></td></tr></table></figure><p> 视图调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.mgr &#x3D; socketio.KombuManager(&#39;列队URL&#39;)</span><br><span class="line">current_app.mgr.emit(&#39;事件名&#39;, 要发送的数据, room&#x3D;room_name)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 聊天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cenos配置静态IP</title>
      <link href="/blog/2017/05/10/network/"/>
      <url>/blog/2017/05/10/network/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络配置"><a href="#1-网络配置" class="headerlink" title="1. 网络配置"></a>1. 网络配置</h2><h3 id="1-1-编辑虚拟网卡"><a href="#1-1-编辑虚拟网卡" class="headerlink" title="1.1 编辑虚拟网卡"></a>1.1 编辑虚拟网卡</h3><ul><li><p>Mac参考<a href="https://kb.vmware.com/s/article/1026510">https://kb.vmware.com/s/article/1026510</a></p></li><li><p>Windows编辑VMware Workstation的虚拟网卡</p><ul><li><p>打开VMware Workstation 编辑虚拟网卡</p></li><li><p>由于需要管理员权限才能修改网络配置，我们点击更改设置</p></li><li><p>仅保留NAT模式的虚拟网卡</p></li><li><p>设置网关，固定前三位网段</p></li><li><p>点击确定生效</p></li></ul></li></ul><h3 id="1-2-虚拟机网络配置"><a href="#1-2-虚拟机网络配置" class="headerlink" title="1.2 虚拟机网络配置"></a>1.2 虚拟机网络配置</h3><ul><li>关闭防火墙,三台机器都需要关闭</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable firewalld # systemctl设置 重启之后也是关闭的</span><br><span class="line">$ systemctl stop firewalld # 关闭当前开启的防火墙</span><br></pre></td></tr></table></figure><ul><li>编辑网卡文件</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-ens33</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens33</span></span><br><span class="line"><span class="built_in">TYPE</span>=<span class="string">&quot;Ethernet&quot;</span></span><br><span class="line">PROXY_METHOD=<span class="string">&quot;none&quot;</span></span><br><span class="line">BROWSER_ONLY=<span class="string">&quot;no&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">DEFROUTE=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV4_FAILURE_FATAL=<span class="string">&quot;no&quot;</span></span><br><span class="line">IPV6INIT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_AUTOCONF=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_DEFROUTE=<span class="string">&quot;yes&quot;</span></span><br><span class="line">IPV6_FAILURE_FATAL=<span class="string">&quot;no&quot;</span></span><br><span class="line">IPV6_ADDR_GEN_MODE=<span class="string">&quot;stable-privacy&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;ens33&quot;</span></span><br><span class="line">UUID=<span class="string">&quot;24f1055b-3faa-44a2-89ba-d7ec625b9a40&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;ens33&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">BROADCAST=<span class="number">192.168</span>.<span class="number">19.255</span> <span class="comment"># 广播地址</span></span><br><span class="line">IPADDR=<span class="number">192.168</span>.<span class="number">19.137</span> <span class="comment"># ip地址</span></span><br><span class="line">NETMASK=<span class="number">255.255</span>.<span class="number">255.0</span> <span class="comment"># 子网掩码</span></span><br><span class="line">GATEWAY=<span class="number">192.168</span>.<span class="number">19.2</span> <span class="comment"># 网关地址</span></span><br><span class="line">DNS1=<span class="number">192.168</span>.<span class="number">19.2</span> <span class="comment"># DNS地址</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart network  # 重启网卡</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ping www.baidu.com</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cenos </tag>
            
            <tag> 网卡配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>miniconda</title>
      <link href="/blog/2017/04/23/miniconda/"/>
      <url>/blog/2017/04/23/miniconda/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Conda是什么"><a href="#1-Conda是什么" class="headerlink" title="1. Conda是什么"></a>1. Conda是什么</h2><p>Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。</p><p>Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。</p><p>Anaconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> 下载。</p><p>Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。</p><p>Miniconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a> 下载。</p><h2 id="2-cones安装Miniconda"><a href="#2-cones安装Miniconda" class="headerlink" title="2. cones安装Miniconda"></a>2. cones安装Miniconda</h2><ol><li><p>在linxu中通过该链接下载得到脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;miniconda&#x2F;Miniconda-3.16.0-Linux-x86_64.sh</span><br><span class="line">已保存 “Miniconda-3.16.0-Linux-x86_64.sh” [24166764&#x2F;24166764])</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">Miniconda-3.16.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本，进行安装, 在安装过程中，会要你进行几次选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# &#x2F;bin&#x2F;bash Miniconda-3.16.0-Linux-x86_64.sh</span><br><span class="line">Do you approve the license terms? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; yes</span><br><span class="line">Miniconda will now be installed into this location:</span><br><span class="line">&#x2F;root&#x2F;miniconda</span><br><span class="line">  - Press ENTER to confirm the location</span><br><span class="line">  - Press CTRL-C to abort the installation</span><br><span class="line">  - Or specify a different location below</span><br><span class="line">[&#x2F;root&#x2F;miniconda] &gt;&gt;&gt; &#x2F;miniconda</span><br><span class="line">Do you wish the installer to prepend the Miniconda install location</span><br><span class="line">to PATH in your &#x2F;root&#x2F;.bashrc ? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; no</span><br><span class="line">You may wish to edit your .bashrc or prepend the Miniconda install location:</span><br><span class="line">$ export PATH&#x3D;&#x2F;miniconda&#x2F;bin:$PATH</span><br><span class="line">Thank you for installing Miniconda!</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>~/.bash_profile</code>, 参照第3步执行命令后的提示，把<code>export PATH=/miniconda/bin:$PATH</code>添加到<code>~/.bash_profile</code>文件末尾，最后执行<code>source ~/.bash_profile</code>让其生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim ~&#x2F;.bash_profile</span><br><span class="line">您在 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root 中有邮件</span><br><span class="line">[root@localhost ~]# cat ~&#x2F;.bash_profile</span><br><span class="line"># .bash_profile</span><br><span class="line"># Get the aliases and functions</span><br><span class="line">if [ -f ~&#x2F;.bashrc ]; then</span><br><span class="line">        . ~&#x2F;.bashrc</span><br><span class="line">fi</span><br><span class="line"># User specific environment and startup programs</span><br><span class="line">PATH&#x3D;$PATH:$HOME&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line">export PATH&#x3D;&#x2F;miniconda&#x2F;bin:$PATH</span><br><span class="line">[root@localhost ~]# source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>测试<code>conda -V</code>查看conda版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# conda -V</span><br><span class="line">conda 3.16.0</span><br></pre></td></tr></table></figure><p>至此<strong>miniconda安装成功！</strong></p></li></ol><h2 id="3-windows安装miniconda"><a href="#3-windows安装miniconda" class="headerlink" title="3.windows安装miniconda"></a>3.windows安装miniconda</h2><ol><li><p><a href="https://conda.io/miniconda.html%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BDMiniconda%E5%AE%89%E8%A3%85%E5%8C%85">https://conda.io/miniconda.html进入官网下载Miniconda安装包</a></p></li><li><p>然后安装一路Next；</p><p><img src="blog/img/miniconda_1.jpg" alt="miniconda_1"></p><p><img src="blog/img/miniconda_2.jpg" alt="miniconda_2"></p></li></ol><h2 id="4-Conda的使用"><a href="#4-Conda的使用" class="headerlink" title="4. Conda的使用"></a>4. Conda的使用</h2><ol><li><p>配置anaconda仓库镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">[root@localhost ~]# conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">[root@localhost ~]# conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>创建虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# conda create -n py36 python&#x3D;3.6</span><br><span class="line">Fetching package metadata: ........</span><br><span class="line"># 中途下载会需要一点点时间，请耐心等待 </span><br><span class="line">100%</span><br><span class="line"># To activate this environment, use:</span><br><span class="line"># $ source activate py36</span><br><span class="line">#</span><br><span class="line"># To deactivate this environment, use:</span><br><span class="line"># $ source deactivate</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></li><li><p>进入虚拟环境，并查看有哪些已经安装好的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# source activate py36</span><br><span class="line">(py36)[root@localhost ~]# conda list</span><br><span class="line"># packages in environment at &#x2F;miniconda&#x2F;envs&#x2F;py36:</span><br><span class="line"># 省略...</span><br><span class="line">python                    3.6.2                         0    defaults</span><br><span class="line">readline                  6.2                           2    &lt;unknown&gt;</span><br><span class="line">setuptools                41.0.1                   py36_0   </span><br><span class="line"># 省略...</span><br></pre></td></tr></table></figure></li><li><p>尝试安装其他第三方的包，这里我们以<code>requests</code>和<code>pyspark</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(py36)[root@localhost ~]# pip install requests</span><br><span class="line">Successfully installed chardet-3.0.4 idna-2.8 requests-2.22.0 urllib3-1.25.3</span><br><span class="line"># 这个第三方包比较小，还能容易的安装，但如果碰到比较大的第三方包就尴尬了，因此这里我们添加一个国内的pypi镜像地址</span><br><span class="line">(py36)[root@localhost ~]# mkdir -p ~&#x2F;.pip&#x2F;</span><br><span class="line">(py36)[root@localhost ~]# vim ~&#x2F;.pip&#x2F;pip.conf</span><br><span class="line">(py36)[root@localhost ~]# cat ~&#x2F;.pip&#x2F;pip.conf # pip.conf内容如下</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;pypi.douban.com</span><br><span class="line">(py36)[root@localhost ~]# pip install pyspark</span><br><span class="line">Looking in indexes: http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple</span><br><span class="line">Collecting pyspark</span><br><span class="line">  Downloading http:&#x2F;&#x2F;pypi.doubanio.com&#x2F;...&#x2F;pyspark-2.4.3.tar.gz (215.6MB)</span><br><span class="line">     |████████████████████████████████| 215.6MB 2.0MB&#x2F;s</span><br><span class="line">     # 如果发现下载速度慢，可以Ctrl+C取消重试，这里我第二次才达到2.0MB&#x2F;s</span><br><span class="line">Successfully installed pyspark-2.4.3</span><br><span class="line">(py36)[root@localhost ~]# pip list</span><br><span class="line"># 省略...</span><br><span class="line">pyspark    2.4.3</span><br><span class="line">requests   2.22.0</span><br><span class="line"># 省略...</span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/blog/2017/04/22/Elasticsearch/"/>
      <url>/blog/2017/04/22/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch搜索引擎"><a href="#Elasticsearch搜索引擎" class="headerlink" title="Elasticsearch搜索引擎"></a>Elasticsearch搜索引擎</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Eladticsearch</strong>是一个基于<strong>Lucene库</strong>的搜索引擎</p><p>他提供了一个<strong>分布式</strong>、支持多用户的全文搜索引擎，采用的是<strong>HTTP</strong>接口的方式对外提供服务</p><p><strong>Elasticsearch 是一个实时的分布式搜索分析引擎，它被用作全文检索、结构化搜索、分析以及这三个功能的组合</strong></p><p><strong>属于面向文档的数据库</strong></p><ul><li>Elasticsearch 是 <em>面向文档</em> 的，意味着它存储整个对象或 <em>文档。Elasticsearch 不仅存储文档，而且 索引</em>每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤–而不是对行列数据。</li></ul><h2 id="搜索原理"><a href="#搜索原理" class="headerlink" title="搜索原理"></a>搜索原理</h2><h3 id="倒排索引："><a href="#倒排索引：" class="headerlink" title="倒排索引："></a>倒排索引：</h3><ul><li>倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在文档或者一组文档中的存储位置的映射。<strong>它是文档检索系统中最常用的数据结构</strong>（会对文档数据进行标准化处理）</li></ul><h3 id="相关性排序："><a href="#相关性排序：" class="headerlink" title="相关性排序："></a>相关性排序：</h3><ul><li>检索词频率：检索词在该文档中出现的次数，出现次数越多，相关性越高</li><li>反向文档频率：检索词在整个文档中出现的频率，出现次数越多相关性越低</li><li>字段长度准则：长度越长，相关性越低</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul><li><strong>节点（node）</strong>：<ul><li><strong>一个运行中的Elasticsearch实例称为一个节点</strong>。</li><li>每个节点都知道任意文档的所处位置，可以将请求发给任意一个节点（包括主节点），所以主节点不会成为不会成为集群的瓶颈</li><li><strong>主节点</strong>：当一个节点被选举成主节点时，它将负责管理集群范围内所有变更，例如增加、删除索引，或者增加删除节点。而主节点并不需要涉及到文档级别的变更和搜索等操作。</li></ul></li><li><strong>分片（shard）</strong>：<ul><li>一个分片是一个底层的工作单元 它仅保存了 全部数据中的一部分。Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</li><li><strong>主分片（primary shard）</strong>：索引内的任意一个文档都属于一个主分片，所以主分片（按50G时查询和写入的性能较好）的数目决定着能够保存的最大数据量</li><li>**复制分片(replica shard)**：复制分片是主分片的拷贝。复制分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</li><li><strong>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改.</strong></li><li>每一个分片是一个功能完整的搜索引擎，它可以使用一个节点上的所有资源的能力。复制分片越多，也将拥有越高的吞吐量</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置索引的分片</span><br><span class="line">curl -X PUT IP:9200&#x2F;库名 -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;number_of_shards&quot; : 3,</span><br><span class="line">            &quot;number_of_replicas&quot; : 1</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br><span class="line"># 修改副分片数量</span><br><span class="line">PUT IP:9200&#x2F;库名&#x2F;_settings &#123;&quot;number_of_replicas&quot; : 2&#125;</span><br><span class="line"># 查看集群健康状态</span><br><span class="line">GET IP:9200&#x2F;_cluster&#x2F;health</span><br></pre></td></tr></table></figure><p>未完待续。。。。。。。。。。</p><h2 id="ES的单机部署"><a href="#ES的单机部署" class="headerlink" title="ES的单机部署"></a>ES的单机部署</h2><h4 id="一、配置网卡（无网环境忽略此条）"><a href="#一、配置网卡（无网环境忽略此条）" class="headerlink" title="一、配置网卡（无网环境忽略此条）"></a>一、配置网卡（无网环境忽略此条）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-*</span><br><span class="line"></span><br><span class="line">BOOTPROTO=static# 修改为静态网路，可以不修改</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h4 id="二、配置本地yum源（有网环境忽略此条）"><a href="#二、配置本地yum源（有网环境忽略此条）" class="headerlink" title="二、配置本地yum源（有网环境忽略此条）"></a>二、配置本地yum源（有网环境忽略此条）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /centos7#存放本地yum源</span><br><span class="line"></span><br><span class="line">mount /iso  ./tmp#将iso镜像挂载到本地文件中</span><br><span class="line"></span><br><span class="line">cp -vrf ./tmp/* /centos7#将挂载后到本地文件copy到本地yum源文件中</span><br><span class="line"></span><br><span class="line">cd /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">mv ./CentOS-*/root/tmp#移除yum到网络源信息</span><br><span class="line"></span><br><span class="line">vi yum.repo#编写本地yum</span><br><span class="line">[centos7-yum]</span><br><span class="line">name=&quot;yum.local&quot;</span><br><span class="line">baseurl=file:///centos7</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">yum clean all#刷新缓存</span><br><span class="line"></span><br><span class="line">rm -rf /var/cache/yum</span><br><span class="line"></span><br><span class="line">yum list#显示数据则表示本地yum配置成功</span><br><span class="line"></span><br><span class="line">yum install net-tools#安装net-tools，查看ifconfig</span><br></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    本地挂载完镜像之后，如果还要使用该文件的话，必须先umount该文件，否则会报错，提示权限不够</p><h4 id="三、关闭防火墙及selinux"><a href="#三、关闭防火墙及selinux" class="headerlink" title="三、关闭防火墙及selinux"></a>三、关闭防火墙及selinux</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line">SELINUX=disabled</span><br><span class="line">setenforce 0</span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>​    安装docker时可以不用关闭，当es进行集群部署时，必须关闭，否则集群无法生效</p><h4 id="四、安装docker"><a href="#四、安装docker" class="headerlink" title="四、安装docker"></a>四、安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp docker.zip root@ip:~#没网手动copy</span><br><span class="line">unzip docker.zip</span><br><span class="line">cd docker</span><br><span class="line">sh setup_without_container-selinux-2.9#虚拟机/实体机</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器，直接联网安装，不赘述</span></span><br></pre></td></tr></table></figure><p>setup_without_container-selinux-2.9.sh 脚本内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">auto-mount</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum remove -y docker-engine</span><br><span class="line">mkdir -p /data/tmp</span><br><span class="line">chmod -R 777 /data/tmp</span><br><span class="line">mkdir -p /data/sys/var/docker</span><br><span class="line">chmod -R 777 /data/sys/var/docker</span><br><span class="line">ln -s /data/sys/var/docker /var/lib/docker</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">echo &quot;vm.max_map_count=655360&quot; &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</span><br><span class="line">yum install -y net-tools</span><br><span class="line">useradd -d /data/duser -m duser</span><br><span class="line">echo &quot;duser:5VSDHai4&quot; |chpasswd</span><br><span class="line">echo &quot;duser    ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br><span class="line">rpm -ivh container-selinux-2.9-4.el7.noarch.rpm</span><br><span class="line">yum install -y ./docker-ce-17.09.0.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">usermod -aG docker duser</span><br><span class="line">rm -fr ./*</span><br><span class="line">cd ../</span><br><span class="line">rm -fr docker_install docker_install.tar.gz</span><br></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><p>​    sh脚本可以根据具体情况进行修改</p><p>​    当出现无法安装成功，且提示rpm安装问题时，在rpm安装命令之后，加 —nodeps —force  ，意思为不考虑分析包之间的依赖关系，即可安装成功</p><h4 id="五、开启docker服务"><a href="#五、开启docker服务" class="headerlink" title="五、开启docker服务"></a>五、开启docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl status docker</span><br><span class="line">docker version#查询是否开启docker</span><br></pre></td></tr></table></figure><h4 id="六、安装java-部署es-的依赖"><a href="#六、安装java-部署es-的依赖" class="headerlink" title="六、安装java(部署es 的依赖)"></a>六、安装java(部署es 的依赖)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version#查看是否有java，如果有，忽略以后步骤</span><br></pre></td></tr></table></figure><h5 id="本地安装java"><a href="#本地安装java" class="headerlink" title="本地安装java"></a>本地安装java</h5><p>​    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">cp jdk-8u171-linux-x64.rpm /usr/java</span><br><span class="line">cd /usr/java</span><br><span class="line">chmod +x jdk-8u171-linux-x64.rpm</span><br><span class="line">rpm -ivh jdk-8u171-linux-x64.rpm</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h4 id="七、读取镜像（根据实际情况）"><a href="#七、读取镜像（根据实际情况）" class="headerlink" title="七、读取镜像（根据实际情况）"></a>七、读取镜像（根据实际情况）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker load -i image.tar#如果是zip的镜像，则先unziip成tar文件</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器，并且将本地的文件目录挂载至容器data目录下</span></span><br><span class="line">docker run -itd -p 8888:8888 -v /data/origin_file:/data/duser/patent_similaruty/data/origin_file --name patent_preprocess patent_preprocess:1.1 bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">docker exec -it patent_preprocess bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">docker stop patent_preprocess</span><br></pre></td></tr></table></figure><h4 id="八、如果需要docker-compose启动"><a href="#八、如果需要docker-compose启动" class="headerlink" title="八、如果需要docker-compose启动"></a>八、如果需要docker-compose启动</h4><p>安装并使用docker-compose</p><p>方法一：</p><p>使用curl命令下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>方法二：</p><p>使用pip命令下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line">yum -y install python-pip</span><br><span class="line"></span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h2 id="ES集群部署"><a href="#ES集群部署" class="headerlink" title="ES集群部署"></a>ES集群部署</h2><h3 id="一、部署集群"><a href="#一、部署集群" class="headerlink" title="一、部署集群"></a>一、部署集群</h3><p>user用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch_bak.zip#解压引擎文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认的配置文件</span></span><br><span class="line">cd elasticsearch_bak/config</span><br><span class="line">vi elasctsearch.yml</span><br><span class="line">cluster.name: es-zl#修改集群名，所有节点配置的该名称必须一样</span><br><span class="line">node.name: es-46#修改每个节点的名称，必须不同，以区分每个节点</span><br><span class="line">node.master:true#是否可作为主节点</span><br><span class="line">path.data: /data/es_data#es数据存放的位置</span><br><span class="line">network.host:127.17.30.46#每个节点的ip地址</span><br><span class="line">http.port: 9200#节点的端口，必须相同，默认9200</span><br><span class="line"></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line">bootstrap.system_call_filter: false#内存锁定，防止swap使es产生内存交互</span><br><span class="line">discovery.zen.ping.unicast.hosts:[&quot;127.17.30.44&quot;,&quot;127.17.30.45&quot;,,]#集群master节点的ip，不需要所有节点的ip，其他节点只要能与任意一个master节点通讯，即可加入到该集群当中</span><br><span class="line">discovery.zen.minimum_master_nodes:2#当2个有资格成为主节点的从节点认为主节点挂了，则进行重新选主，一般设置为(n/2)+1，防止es出现脑裂情况</span><br><span class="line">gateway.recover_after_nodes: 3#节点数量达到多少之后，进行数据恢复处理</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">vi yvm.options</span><br><span class="line">-Xms16g#默认为2g，可根据服务器内存，自行修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过一下命令查看内存</span></span><br><span class="line">cat /proc/cpuinfo | grep &#x27;cpu cores&#x27; | wc -l#查看cpu核数</span><br><span class="line">cat /proc/meminfo | grep MemTotal#只查看内存</span><br><span class="line">free -h#查看内存的使用</span><br><span class="line">df -h#查看硬盘存储</span><br></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><p>​    该操作必须在每台服务器上都要部署，并不能在root用户下操作，要在user下操作，如果没有usr用户，则创建</p><h5 id="如果没有操作权限，则执行："><a href="#如果没有操作权限，则执行：" class="headerlink" title="如果没有操作权限，则执行："></a>如果没有操作权限，则执行：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root下，将文件权限设置为duser用户可操作</span></span><br><span class="line">chown duser *</span><br><span class="line">chgrp duser *</span><br></pre></td></tr></table></figure><h4 id="当不使用es远程词典时："><a href="#当不使用es远程词典时：" class="headerlink" title="当不使用es远程词典时："></a>当不使用es远程词典时：</h4><p>修改elasticsearch-5.3.0/plugins/ik/config/IKAnalyzer.cfg.xml </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>custom/mydict.dic;custom/single_word_low_freq.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>custom/ext_stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;http://10.172.80.229:9301/mydict.dic&lt;/entry&gt; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;http://10.172.80.229:9301/stopword.dic&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>​    注释后两项即可</p><h5 id="添加自定义同义词"><a href="#添加自定义同义词" class="headerlink" title="添加自定义同义词"></a>添加自定义同义词</h5><p>替换config/synonyms.txt文件</p><p>synonyms.txt文件内格式，所有同义词为一行，且用 “, ” 隔开</p><h3 id="二、修改集群配置"><a href="#二、修改集群配置" class="headerlink" title="二、修改集群配置"></a>二、修改集群配置</h3><p>root用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一下语句</span></span><br><span class="line">*      soft    nofile    65536</span><br><span class="line">*      hard    nofile    65536</span><br><span class="line">*      soft   nproc     65536</span><br><span class="line">*   hard   nproc 65536</span><br><span class="line">duser  soft    memlock   unlimited </span><br><span class="line">    duser  hard    memlock   unlimited </span><br><span class="line"></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改以下语句</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h3 id="三、启动集群"><a href="#三、启动集群" class="headerlink" title="三、启动集群"></a>三、启动集群</h3><p>user用户下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch_bak/bin</span><br><span class="line">./elasticsearch  -d#后台启动集群</span><br><span class="line">curl 172.17.30.45:9200/_cat/nodes#查看所有节点，*为主节点</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动不了时候，查看es-log</span></span><br></pre></td></tr></table></figure><h3 id="四、搜索部署"><a href="#四、搜索部署" class="headerlink" title="四、搜索部署"></a>四、搜索部署</h3><p>user用户下的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi index_search_mapping.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">修改的ip和端口与集群一样</span></span><br><span class="line">curl -XPUT &quot;http://10.25.114.90:9200/index&quot; </span><br><span class="line">&#123;</span><br><span class="line">        settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 6,#主分片数量，一般为 服务器总核数</span><br><span class="line">        &quot;number_of_replicas&quot;: 2,#副本分片的数量，防止数据丢失</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><p>​    分词器anslyzer可以根据实际情况进行修改、删除和添加</p><h4 id="添加删除字段"><a href="#添加删除字段" class="headerlink" title="添加删除字段"></a>添加删除字段</h4><p>​    当需要添加字段时，只要在以下位置添加即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">  &quot;id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">       &quot;&quot;: &#123;#需要添加的字段名</span><br><span class="line">           &quot;type&quot;:&quot;&quot;#添加的字段的约束条件</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h5 id="注意：-5"><a href="#注意：-5" class="headerlink" title="注意："></a>注意：</h5><p>​    修改某个文件的字段之前，需要先删除该文件的core</p><p>​    重新启动搜索时，也需要进行以下步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE &quot;http://172.19.30.45:9200/index&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">修改完之后，重新运行该文件</span></span><br><span class="line">sh index_search_mapping.sh</span><br></pre></td></tr></table></figure><h3 id="五、查询启动结果"><a href="#五、查询启动结果" class="headerlink" title="五、查询启动结果"></a>五、查询启动结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip:9200/index?pretty#查询字段</span><br><span class="line">curl http://ip:9200/_cat/nodes#查询节点</span><br><span class="line">curl http://ip:9200/_cat/health#查询加群健康，green</span><br><span class="line">curl http://ip:9200/_cat/shards#查询集群分片状态</span><br></pre></td></tr></table></figure><h3 id="六、数据量查询"><a href="#六、数据量查询" class="headerlink" title="六、数据量查询"></a>六、数据量查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip:9200/one_index/_stats#查询某一个index下的数据量</span><br><span class="line">curl http://ip:9200/one_index,two_index/_stats#查询多个index的数据量，使用,隔开</span><br><span class="line">curl http://ip:9200/_all/_stats#查询所有index下的数据量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回search、fetch、get、index、bulk、segment、counts</span></span><br><span class="line"></span><br><span class="line">curl http://ip:9200/_cat/count/index#只查询某个index下的文档数，如果不加index，则查询所有的index的文档总数</span><br></pre></td></tr></table></figure><h3 id="七、search-guard为es集群配置auth"><a href="#七、search-guard为es集群配置auth" class="headerlink" title="七、search-guard为es集群配置auth"></a>七、search-guard为es集群配置auth</h3><h4 id="1、安装search-guard插件和ssl插件"><a href="#1、安装search-guard插件和ssl插件" class="headerlink" title="1、安装search-guard插件和ssl插件"></a>1、安装search-guard插件和ssl插件</h4><h5 id="查询es的版本"><a href="#查询es的版本" class="headerlink" title="查询es的版本"></a>查询es的版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl ip:9200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果中的number数据即代表版本号</span></span><br></pre></td></tr></table></figure><h5 id="安装search-guard"><a href="#安装search-guard" class="headerlink" title="安装search-guard"></a>安装search-guard</h5><p><a href="https://repo1.maven.org/maven2/com/floragunn/search-guard-5">https://repo1.maven.org/maven2/com/floragunn/search-guard-5</a></p><p>找到对应的版本，下载即可</p><p>或者使用命令行下载，es目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-plugin install -b com.floragunn:search-guard-5:5.3.0-12</span><br></pre></td></tr></table></figure><h5 id="安装search-guard-ssl"><a href="#安装search-guard-ssl" class="headerlink" title="安装search-guard-ssl"></a>安装search-guard-ssl</h5><p><a href="https://repo1.maven.org/maven2/com/floragunn/search-guard-ssl">https://repo1.maven.org/maven2/com/floragunn/search-guard-ssl</a></p><p>命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-plugin install -b com.floragunn:search-guard-ssl:5.3.0-22</span><br></pre></td></tr></table></figure><h5 id="注意：-6"><a href="#注意：-6" class="headerlink" title="注意："></a>注意：</h5><p>当es版本较高时，可能并不需要这两个都存在，取search-guard即可</p><h4 id="2、生成es证书文件"><a href="#2、生成es证书文件" class="headerlink" title="2、生成es证书文件"></a>2、生成es证书文件</h4><h5 id="下载search-guard源码工具，生成证书的工具"><a href="#下载search-guard源码工具，生成证书的工具" class="headerlink" title="下载search-guard源码工具，生成证书的工具"></a>下载search-guard源码工具，生成证书的工具</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/floragunncom/search-guard-ssl.git</span><br></pre></td></tr></table></figure><h5 id="修改ca配置"><a href="#修改ca配置" class="headerlink" title="修改ca配置"></a>修改ca配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd search-guard-ssl/example-pki-scripts/etc/</span><br><span class="line"></span><br><span class="line">vi root-ca.conf# 根证书配置</span><br><span class="line">0.domainComponent       = &quot;www.test.com”    # 域名</span><br><span class="line">1.domainComponent       = &quot;www.test.com&quot;    # 域名</span><br><span class="line">organizationName        = &quot;Test&quot;            # 组织名称</span><br><span class="line">organizationalUnitName  = &quot;Test Root CA&quot;    # 组织单位名称</span><br><span class="line">commonName              = &quot;Test Root CA&quot;    # 通用名称</span><br><span class="line"></span><br><span class="line">vi signing-ca.conf# 签名证书配置</span><br><span class="line">0.domainComponent       = &quot;www.test.com”    # 域名</span><br><span class="line">1.domainComponent       = &quot;www.test.com&quot;    # 域名</span><br><span class="line">organizationName        = &quot;Test&quot;            # 组织名称</span><br><span class="line">organizationalUnitName  = &quot;Test Signing CA&quot; # 组织单位名称</span><br><span class="line">commonName              = &quot;Test Signing CA&quot; # 通用名称</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    以上信息填写，必须保证和生成证书时信息一致</p><h5 id="修改sh文件"><a href="#修改sh文件" class="headerlink" title="修改sh文件"></a>修改sh文件</h5><p>返回example-pki-scripts目录下，修改example.sh文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">./clean.sh</span><br><span class="line"></span><br><span class="line">./gen_root_ca.sh 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_node_cert.sh 0 12345678 12345678&amp;&amp; ./gen_node_cert.sh 1 12345678 12345678 &amp;&amp;  ./gen_node_cert.sh 2 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_client_node_cert.sh <span class="built_in">test</span> 12345678 12345678</span><br><span class="line"></span><br><span class="line">./gen_client_node_cert.sh <span class="built_in">test</span> 12345678 12345678</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>./gen_root_ca.sh 12345678 12345678</p><p>第一个参数为CA_PASS，即CA密码（根证书密码）</p><p>第二个参数为TS_PASS，即TS密码（truststore，信任证书密码）</p><p>./gen_node_cert.sh 0 12345678 12345678</p><p>第一个参数为node编号，生成证书后的文件名为node-0*</p><p>第二个参数为KS_PASS（keystore文件密码）</p><p>第三个参数为CA_PASS</p><p>./gen_client_node_cert.sh test 12345678</p><p>第一个参数为客户端节点名称，生成证书后的文件名为test*</p><p>第二个参数为KS_PASS</p><p>第三个参数为CA_PASS</p><h5 id="生成证书，运行example-sh"><a href="#生成证书，运行example-sh" class="headerlink" title="生成证书，运行example.sh"></a>生成证书，运行example.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh example.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下会生成证书文件</span></span><br></pre></td></tr></table></figure><h4 id="3、配置es，启动search-guard"><a href="#3、配置es，启动search-guard" class="headerlink" title="3、配置es，启动search-guard"></a>3、配置es，启动search-guard</h4><h5 id="将生成的各个节点的证书，分别copy到各个节点上"><a href="#将生成的各个节点的证书，分别copy到各个节点上" class="headerlink" title="将生成的各个节点的证书，分别copy到各个节点上"></a>将生成的各个节点的证书，分别copy到各个节点上</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将node-0-keystore.jks和truststore.jks复制到es的config目录下</span></span><br><span class="line"></span><br><span class="line">cp node-0-keystore.jks ~/elasticsearch/config/</span><br><span class="line">cp truststore.jks ~/elasticsearch/config/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将test-keystore.jks和truststore.jks复制到es的plugins/search-guard-2/sgconfig目录下</span></span><br><span class="line"></span><br><span class="line">cp test-keystore.jks ~/elasticsearch/plugins/search-guard-2/sgconfig/</span><br><span class="line">cp truststore.jks ~/elasticsearch/plugins/search-guard-2/sgconfig/</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    保持证书的一致性，因此只需要在一台机器上生成CA证书即可</p><h5 id="修改es的配置文件config-elaticsearch-yml"><a href="#修改es的配置文件config-elaticsearch-yml" class="headerlink" title="修改es的配置文件config/elaticsearch.yml"></a>修改es的配置文件config/elaticsearch.yml</h5><p>在之前修改的基础上，增加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置ssl</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_filepath:</span> <span class="string">node-0-keystore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_filepath:</span> <span class="string">truststore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.enforce_hostname_verification:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.resolve_hostname:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置https</span></span><br><span class="line"><span class="comment"># http配置，这里我只是为了测试方便，配置完，应该设置为true</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.keystore_filepath:</span> <span class="string">node-0-keystore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.keystore_password:</span> <span class="number">12345678</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.truststore_filepath:</span> <span class="string">truststore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.http.truststore_password:</span> <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CN为生成CA证书时填写的信息，即./gen_client_node_cert.sh test 12345678 命令的第一个参数</span></span><br><span class="line"><span class="attr">searchguard.authcz.admin_dn:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">CN=test,</span> <span class="string">OU=client,</span> <span class="string">O=client,</span> <span class="string">L=Test,</span> <span class="string">C=DE</span></span><br></pre></td></tr></table></figure><h5 id="启动es"><a href="#启动es" class="headerlink" title="启动es"></a>启动es</h5><h4 id="4、将search-guard的配置写入es中"><a href="#4、将search-guard的配置写入es中" class="headerlink" title="4、将search-guard的配置写入es中"></a>4、将search-guard的配置写入es中</h4><p>添加权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 plugins/search-guard-5/tools/sgadmin.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn clustername -h hostname -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/admin-keystore.jks -kspass password -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass password -nhnv</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><p>​    clustername为集群的名称</p><p>​    hostname为elasticsearch.yml 文件中 network.host 的值</p><p>​    password生成证书设置的密码</p><h5 id="以上配置生成的命令为"><a href="#以上配置生成的命令为" class="headerlink" title="以上配置生成的命令为"></a>以上配置生成的命令为</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn es-nlp -h 192.168.124.18 -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/test-keystore.jks -kspass 12345678 -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass 12345678 -nhnv</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、添加es用户及密码"><a href="#5、添加es用户及密码" class="headerlink" title="5、添加es用户及密码"></a>5、添加es用户及密码</h4><h5 id="生成md5加密密码"><a href="#生成md5加密密码" class="headerlink" title="生成md5加密密码"></a>生成md5加密密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 plugins/search-guard-2/tools/hash.sh</span><br><span class="line"></span><br><span class="line">cd plugins/search-guard-2/tools/</span><br><span class="line"></span><br><span class="line">plugins/search-guard-2/tools/hash.sh -p 123456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存生成的<span class="built_in">hash</span>密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="添加用户及密码"><a href="#添加用户及密码" class="headerlink" title="添加用户及密码"></a>添加用户及密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim plugins/search-guard-5/sgconfig/sg_internal_users.yml</span><br><span class="line"></span><br><span class="line">sunww:</span><br><span class="line">  hash: 加密后的字符串</span><br><span class="line"><span class="meta">  #</span><span class="bash"> password: 123456</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后一行时password提示，防止忘记</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="添加用户的权限"><a href="#添加用户的权限" class="headerlink" title="添加用户的权限"></a>添加用户的权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim plugins/search-guard-5/sgconfig/sg_roles_mapping.yml</span><br><span class="line"></span><br><span class="line">ag_all_access:</span><br><span class="line">  users:</span><br><span class="line">    - admin</span><br><span class="line">    - sunww</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有权限给sunww用户</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="重新将配置写入es中生效"><a href="#重新将配置写入es中生效" class="headerlink" title="重新将配置写入es中生效"></a>重新将配置写入es中生效</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./plugins/search-guard-5/tools/sgadmin.sh -cn es-nlp -h 192.168.124.18 -cd plugins/search-guard-5/sgconfig -ks plugins/search-guard-5/sgconfig/test-keystore.jks -kspass 12345678 -ts plugins/search-guard-5/sgconfig/truststore.jks -tspass 12345678 -nhnv</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl http://sunww:123456@127.0.0.1:9200</span><br><span class="line"></span><br><span class="line">curl -u sunww:123456 http://127.0.0.1:9200</span><br><span class="line"></span><br><span class="line">curl --user sunww:123456 http://127.0.0.1:9200</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八、x-pack为es集群配置auth"><a href="#八、x-pack为es集群配置auth" class="headerlink" title="八、x-pack为es集群配置auth"></a>八、x-pack为es集群配置auth</h3><h5 id="1、要求"><a href="#1、要求" class="headerlink" title="1、要求"></a>1、要求</h5><p>es的版本必须为6.X及以上，5.X的es配置x-pack只能通过api修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.3.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、安装x-pack"><a href="#2、安装x-pack" class="headerlink" title="2、安装x-pack"></a>2、安装x-pack</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install x-pack</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash-system，kibana用户名为kibana）"><a href="#3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash-system，kibana用户名为kibana）" class="headerlink" title="3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash_system，kibana用户名为kibana）"></a>3、对elasticsearch、logstash、kibana分别设置登录密码（默认es用户名为elastic，logstash用户名为logstash_system，kibana用户名为kibana）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/x-pack/setup-passwords interactive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><p>​    此时的es必须时启动状态</p><h5 id="4、配置-config-elasticsearch-yml"><a href="#4、配置-config-elasticsearch-yml" class="headerlink" title="4、配置./config/elasticsearch.yml"></a>4、配置./config/elasticsearch.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># es6.X配置：</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">Authorization,X-Requested-With,Content-Length,Content-Type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es5.X配置</span></span><br><span class="line"><span class="string">xpack.graph.enabled</span><span class="comment">#设置为false以禁用X-Pack图形功能。</span></span><br><span class="line"><span class="string">xpack.ml.enabled</span><span class="comment">#设置为false以禁用X-Pack机器学习功能。</span></span><br><span class="line"><span class="string">xpack.monitoring.enabled</span><span class="comment">#设置为false以禁用X-Pack监视功能。</span></span><br><span class="line"><span class="string">xpack.reporting.enabled</span>     <span class="comment">#设置为false以禁用X-Pack报告功能。</span></span><br><span class="line"><span class="string">xpack.security.enabled</span>      <span class="comment">#设置为false以禁用X-Pack安全功能。</span></span><br><span class="line"><span class="string">xpack.watcher.enabled</span>       <span class="comment">#设置为false以禁用Watcher。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5、测试访问"><a href="#5、测试访问" class="headerlink" title="5、测试访问"></a>5、测试访问</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -u elastic:password ip:port</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="6、x-pack默认账号密码"><a href="#6、x-pack默认账号密码" class="headerlink" title="6、x-pack默认账号密码"></a>6、x-pack默认账号密码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">账号：elastic</span><br><span class="line">密码：changeme</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="注意：-7"><a href="#注意：-7" class="headerlink" title="注意："></a>注意：</h5><p>​    x-pack只有一个月的使用时间，适合poc使用</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 未完成 </tag>
            
            <tag> web </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/blog/2017/04/20/Docker/"/>
      <url>/blog/2017/04/20/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1.Docker"></a>1.Docker</h1><ol><li>本文基于centos7环境编写</li></ol><h2 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h2><ol><li><p>删除旧的docker版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker<span class="literal">-client</span> \</span><br><span class="line">                  docker<span class="literal">-client</span><span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-common</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span><span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-engine</span></span><br></pre></td></tr></table></figure></li><li><p>安装依赖包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install <span class="literal">-y</span> yum<span class="literal">-utils</span> device<span class="literal">-mapper</span><span class="literal">-persistent</span><span class="literal">-data</span> lvm2</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>添加docker稳定版的yum源</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum<span class="literal">-config</span><span class="literal">-manager</span> -<span class="literal">-add</span><span class="literal">-repo</span> https://download.docker.com/linux/centos/docker<span class="literal">-ce</span>.repo</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker<span class="literal">-ce</span> docker<span class="literal">-ce</span><span class="literal">-cli</span> containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service docker <span class="built_in">start</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">systemctl restart docker <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure></li><li><p>测试，PS：为了后面不走弯路，不要省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>如果执行命令后，能在输出中看到 Hello from Docker! 字样表明docker可以正常工作了</p></li><li><p>添加镜像地址（<strong>非必须的步骤，但能加快下载镜像的速度，强烈建议进行配置</strong>）</p><blockquote><p>此处选择阿里云给每个人提供的私人加深地址，速度很快推荐</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json <span class="comment"># 使用vim将文件编辑成如下样式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://i47cfdfa.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>至此docker服务安装配置和启动完毕！</p></li></ol><h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 登陆自己的docker仓库</span><br><span class="line">docker login url</span><br><span class="line"># 退出仓库</span><br><span class="line">docker logout url</span><br><span class="line"># 搜索镜像</span><br><span class="line">docker search 内容 </span><br><span class="line">#images镜像查看</span><br><span class="line">docker images -a # 查看所有本地镜像</span><br><span class="line">docker images -qa # 查看所有本地镜像ID</span><br><span class="line"># 查看指定镜像创建历史</span><br><span class="line">docker history 镜像名</span><br><span class="line">#rm容器删除</span><br><span class="line">docker rm 容器ID # 删除容器</span><br><span class="line">docker rm -f 容器ID # 强制删除容器</span><br><span class="line">#rmi镜像删除</span><br><span class="line">docker rmi 镜像名&#x2F;镜像ID  # 删除镜像</span><br><span class="line">docker rmi -f 镜像名&#x2F;镜像ID  # 强制删除镜像</span><br><span class="line">#ps查看容器</span><br><span class="line">docker ps -a #查看所有容器</span><br><span class="line">#logs日志查看</span><br><span class="line">docker logs --tail 20 容器ID # 显示最后20条数据</span><br><span class="line">docker logs --since 20m 容器ID   # 显示最后20分钟的数据</span><br><span class="line">docker logs --until 20m 容器ID   # 显示20分钟之前的数据</span><br><span class="line">#inspect查看容器或镜像的元数据</span><br><span class="line">docker inspect 容器ID或NAME </span><br><span class="line">#run把依据镜像创建出容器并运行</span><br><span class="line">docker run -itd 镜像名 </span><br><span class="line">#exec进入容器</span><br><span class="line">docker exec -it 容器ID 进入容器后执行的第一条命令</span><br></pre></td></tr></table></figure><h1 id="2-Docker-Swarm"><a href="#2-Docker-Swarm" class="headerlink" title="2.Docker Swarm"></a>2.Docker Swarm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr IP #创建集群，指定IP与集群连接</span><br><span class="line">docker info #查看集群的相关信息</span><br><span class="line">docker swarm join --token TOKEN IP:Port #在辅集群机器上连接主，TOKEN为第一条命令创建生成的</span><br><span class="line">docker node ls #查看集群中的机器状态</span><br><span class="line">docker node update --availability active&#x2F;drain HOSTNAME # 上线或下线节点</span><br><span class="line">docker stack deploy -c **.yml -c **.yml name  # 启动服务</span><br><span class="line">docker service ls #查看所有服务</span><br><span class="line">docker service ps 服务id  # 查看对应服务的所有容器的详情</span><br><span class="line">docker service logs  服务名称 # 查看服务日志</span><br><span class="line">docker service update --force 服务名 #重启服务</span><br><span class="line">docker logs --tail 200 镜像id   #显示容器最后200行日志</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
